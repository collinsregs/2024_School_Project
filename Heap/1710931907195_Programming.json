[
  {
    "id": "t3_1bjalyf",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://devopscycle.com/blog/the-ultimate-docker-compose-cheat-sheet/",
    "title": "Do You Have A Hard Time Understanding Docker Compose?",
    "points": null,
    "comments": [
      {
        "comment": "Hello Programming Community!\nAs a university lecturer, I know the importance of sharing knowledge. That‚Äôs why I‚Äôm excited to share a comprehensive Docker Compose Cheat Sheet that I‚Äôve created. It is available as¬†PDF¬†and¬†PNG. It‚Äôs completely free, with no email signup or any other requirements.\nThis Cheat Sheet is part of my detailed¬†blog post¬†about Docker Compose. Here is the link:¬†https://devopscycle.com/blog/the-ultimate-docker-compose-cheat-sheet/¬†It walks through the essentials of managing multi container application with Docker Compose. You will also learn about accessing running containers and how to persist data. The post also includes a¬†public GitHub repository. It comes with all the source code, available for anyone to use and learn from. It is an excellent entry point for an internal hackathon at your company or university.\nIf you like the blog post, the Docker Compose Cheat Sheet or the GitHub repository, I would appreciate it if you share it. Your feedback and experiences are always welcome. Let‚Äôs keep learning and growing together!\nCheers,\nMr_LA",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bja93r",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://ricomariani.medium.com/100-unit-testing-now-its-ante-f0e2384ffedf",
    "title": "Why you should aim for 100% unit testing coverage",
    "points": null,
    "comments": [
      {
        "comment": "I disagreed with the title and I still do, but you raised some interesting points for me to think on. Good piece and I'd recommend others with opposing views give it a read too",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bj9zb4",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://cyberbnk.com",
    "title": "üöÄ Introducing CYBERBNK: Banking for Architects of Tomorrow",
    "points": null,
    "comments": [
      {
        "comment": "LMAO still tryna sell crypto wallets in 2024. Find a new grift.",
        "points": "0 points",
        "children": [
          {
            "comment": "LOL - great feedback! This is why we are giving away the wallet for free :-)\n\nIf we assume that crypto will be around for a few years to come, wallets will be more then important to move and hold funds...",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bj9kvf",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://shiftmag.dev/meet-devin-the-ai-software-engineer-2949/",
    "title": "Engineer, meet Devin. Here‚Äôs how he will change your career.",
    "points": null,
    "comments": [
      {
        "comment": "Hey mods can we please ban this lame Devin astroturfing?",
        "points": "13 points",
        "children": [
          {
            "comment": "I'm starting to think that their marketing is doing irreparable damage. Everybody is hating on them now. It might have been better for them to not do any marketing at all.",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Blow me,¬†Devin.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Fuck you Devin. The worst engineer since sliced bread. - Should be article title.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bj9drz",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://medium.com/swift-and-beyond/navigating-swiftly-understanding-swiftuis-mvvm-c-architecture-with-a-real-world-example-66aa97fa4090?sk=5b68c4a235e4de42f4776a261b4452f7",
    "title": "A Real-world Guide to use SwiftUI framework to implement MVVM-C",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1bj97l1",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.linkedin.com/pulse/edition-1-our-subtle-habit-misusing-managerial-authority-jesse-watson-ietsc/",
    "title": "I quit. After 25 years in tech (17 as a dev manager), I finally got that one, truly horrible boss who drove me to the brink of madness. Literally ‚Äî I needed 3 months of mental health leave. But it inspired me to quit tech and make it my mission in life to reform bad managers... Here goes nothing!",
    "points": null,
    "comments": [
      {
        "comment": "End stage LinkdInitis",
        "points": "61 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "All i hear is a project with 3-4+ layer of managers and only 1 engineer pressured from them all.\n\nMaybe a sixth layer of managers could solve the problem! /s",
        "points": "43 points",
        "children": [
          {
            "comment": "Well, that was not the project that caused me to quit. I am contemplating telling that more personal story next, but I need to be careful because people will know exactly who I‚Äôm talking about.",
            "points": "7 points",
            "children": [
              {
                "comment": "exactly who I‚Äôm talking about.\n\nYou might end up saving another dev's sanity/career if the truth comes out.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I salute the effort, but in my opinion, these people are irredeemable.\n\nIt comes down to one thing, they are weak. They have any pressure from above they immediately cave in and pass the issue down. Then they encounter you, who probably refuses to dump his truckload of shit on the team. Shouting matches ensue.\n\nWhat you need is to stop companies from promoting pushovers as managers. You can not teach someone to have balls and say: \"This is simply not feasible, and not what we agreed to.\"",
        "points": "44 points",
        "children": [
          {
            "comment": "I certainly believe that some of these managers are beyond hope. Maybe most. But the power that one unskillful manager has to wreak havoc on people‚Äôs lives and mental health is so great that I think it‚Äôs worth trying. If I can spare one person from having to go through what I went through, it will have been worth it.",
            "points": "19 points",
            "children": [
              {
                "comment": "Like I said, I salute the effort! Just manage expectations :).",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "I went through something very similar as Dan. I ended up leaving for another team and the manager eventually left (he got promoted in the meantime though. Managers watch each others backs) and I‚Äôm still here but he acknowledged he lost trust and I had to go over his head to get transferred. Very stressful experience for me over a super dumb project",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "It's very common for devs to move back and forth from management back to IC roles. I've been in management for about 8 years, I'm considering going back to an IC role too. Principal engineer is a nice place to be too, you just don't have as much control, which is kinda nice honestly. If coding is your passion, rediscover it. Nothing wrong with it.",
        "points": "9 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "lol 3 months of mental health leave. You Gotta Pump Those Numbers Up, Those Are Rookie Numbers.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bj8vdq",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://youtube.com/watch?v=BlbeqGpTL8k&si=PipefTjiHTWbMS4W",
    "title": "Environment Setup & Visual Optimization (Unity)",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1bj8per",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.craftengineer.com/what-agile-development-means-in-2024-10-practical-tips-tricks/",
    "title": "What Agile Development Means in 2024",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1bj8lm5",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://github.com/iByteABit256/tic-tac-toes",
    "title": "Tic Tac Toes - A \"three dimensional\" Tic Tac Toe game I made. A twist of Tic Tac Toe inspired by VSauce written in React + JS. I will happily accept contributions, if you‚Äôre interested you can check for any open issues or create your own!",
    "points": null,
    "comments": [
      {
        "comment": "Not what I imagined when I heard 3D tic tac toe, but cool idea.\n\nInstead of the player with the most wins, what if it was the player who got tic tac toe in the 3x3 larger grid, getting your mark if you win the inner game?",
        "points": "1 point",
        "children": [
          {
            "comment": "Not what I imagined when I heard 3D tic tac toe\n\nI feared so, though I still think it's a catchy description\n\nThis is the original version from VSauce, but it seems to me like it's not as intuitive when playing. I think with the overall score condition, it keeps the game simple and intuitive while also adding a deeper strategic level to the game so it's not extremely easy and unbalanced for the second player.",
            "points": "1 point",
            "children": [
              {
                "comment": "Fair enough, good work!",
                "points": "0 points",
                "children": [
                  {
                    "comment": "Thank you :)",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bj7bra",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.reuters.com/technology/cybersecurity/microsoft-says-cyber-threat-actor-has-been-able-access-internal-systems-2024-03-08/",
    "title": "Fake 7 zip on Microsoft Store just caught them using remoteconnect and installing malware on my gf‚Äôs computer.",
    "points": null,
    "comments": [
      {
        "comment": "What does this have to do with programming?\n\nI had to google \"Romanithos\" which is not a thing, do you mean the developer \"Romanitho\" on Github and one of their specific projects? https://github.com/Romanitho/Winget-AutoUpdate\n\nWhat did you do to \"trace all the bad events\"? Why would both 7zip and this guy's .. package manager for windows (?) be in cahoots and both be executing malware independently?\n\nThat package manager thing has less than 1k stars and the author seems to be French. Why do you think they're Russian again?\n\nIgor Pavlov is Russian, but 7zip is so widely used I think we'd have heard about this already?",
        "points": "16 points",
        "children": [
          {
            "comment": "Wish I could upload a pic but I thought I have deleted all the malware, but RomanithoS with an S, (same as Romanitho that you found) is the developer on this winget auto-update program program. And it has spammed install a million times in the last hour.\n\nMy gf works at an NGO and this is her work computer, and if you see the article I linked, Midnight Blizzard, the group that specifically hacks US NGO‚Äôs is currently Deploying this hack as we speak. I was lucky enough to catch it in real time.",
            "points": "-12 points",
            "children": [
              {
                "comment": "Did you install that \"Winget auto update\" tool or are you saying it appeared on the computer on its own?",
                "points": "4 points",
                "children": [
                  {
                    "comment": "It appeared on its own. 100%. She did install 7-zip last year to unzip something. I am almost certain these two are related.\n\nI got rid of 7-zip, winget autoupdate, and computer is no longer slow af. Microsoft Teams no longer uses up 50% disk and 90% memory. I still can‚Äôt figure out why winget-autoupdate Romanithos keeps trying to install itself and asking for permission, but I‚Äôm working on it.",
                    "points": "-4 points",
                    "children": [
                      {
                        "comment": "\"almost certain the 2 are related\" isn't reason enough to create a PSA confidently declaring the WinStore package is compromised. A gut feeling isn't evidence.",
                        "points": "8 points",
                        "children": [
                          {
                            "comment": "Evidence\n\nhttps://winaero.com/fake-russian-version-of-7-zip-in-microsoft-store-distributed-malware/amp/",
                            "points": "9 points",
                            "children": [
                              {
                                "comment": "Probably should have led with this in your description!",
                                "points": "3 points",
                                "children": [
                                  {
                                    "comment": "Yeah, I can‚Äôt edit. This is going down in real time rn. I am digging up news pertaining to this and trying to keep remoteconnect/winget-autoupdate from spamming install permission notifications.",
                                    "points": "0 points",
                                    "children": [
                                      {
                                        "comment": "You need to reformat",
                                        "points": "3 points",
                                        "children": [],
                                        "isDeleted": false
                                      }
                                    ],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              },
                              {
                                "comment": "No mention of the use of any of the stuff you said though. And it was using a really obvious fake name \"7z-soft\" -- did you install that? Is it possible that another fake 7zip binary was installed?\n\nYou said that the dev behind 7zip was Russian so therefore nationstate hacking was involved. Now you're saying there's an unknown party who once uploaded a very fake 7zip lookalike on the MS store?\n\nI mean I'm not saying your gut is wrong here, but the technical details just aren't adding up. If it really is malware you may never know how it got on there.",
                                "points": "0 points",
                                "children": [
                                  {
                                    "comment": "Chinese security company QiAnXin explains it here: https://ti.qianxin.com/blog/articles/UTG-Q-003-Supply-Chain-Poisoning-of-7ZIP-on-the-Microsoft-App-Store-EN/ I had to use a VPN (singapore) because that site blocks the US\n\nYeah it does say 7z-soft. I take it back all the mean things I said about 7z. The icon/install name and everything legit looked identical to the 7z ones.",
                                    "points": "1 point",
                                    "children": [],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              },
                              {
                                "comment": "Edit and add this link to your first comment, so, people will read earlier than thinking that this is just a drama.",
                                "points": "0 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "You said it's a work computer. Is it possible the IT department is deploying software using this tool?",
                        "points": "3 points",
                        "children": [
                          {
                            "comment": "They don‚Äôt have an IT dept. Got rid of their sysadmin a few years ago",
                            "points": "0 points",
                            "children": [
                              {
                                "comment": "Sounds more likely that they simply installed winget to use it as a utility.",
                                "points": "0 points",
                                "children": [
                                  {
                                    "comment": "Yeah, that‚Äôs what I‚Äôm guessing, but it‚Äôs trying to reinstall itself over and over again and asking for permission. However ~5 times though, even though I deleted winget-autoupdate Romanithos, files and everything, it has found itself installed again, no prompt for permission. Then I have to uninstall again and go through the ascii art thing.",
                                    "points": "0 points",
                                    "children": [
                                      {
                                        "comment": "There must be something else installing it. I would format the disk and reinstall windows.",
                                        "points": "0 points",
                                        "children": [],
                                        "isDeleted": false
                                      }
                                    ],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Bro is taking meds",
        "points": "6 points",
        "children": [
          {
            "comment": "Nah, this hack is legit. It's just being activated now by Midnight Blizzard (Russian state hacker that targets NGO's), but a Chinese security firm picked it up a few months ago.\n\nChinese security company QiAnXin explains it here: https://ti.qianxin.com/blog/articles/UTG-Q-003-Supply-Chain-Poisoning-of-7ZIP-on-the-Microsoft-App-Store-EN/\n\nI had to use a VPN (singapore) because that site blocks the US",
            "points": "-1 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "https://winaero.com/fake-russian-version-of-7-zip-in-microsoft-store-distributed-malware/amp/",
        "points": "1 point",
        "children": [
          {
            "comment": "Did your girlfriend use the Russian version of 7z?",
            "points": "1 point",
            "children": [
              {
                "comment": "No, she got it off of the Microsoft Store November of last year.\n\nChinese security company QiAnXin explains it here:\n\nhttps://ti.qianxin.com/blog/articles/UTG-Q-003-Supply-Chain-Poisoning-of-7ZIP-on-the-Microsoft-App-Store-EN/\n\nI had to use a VPN (singapore) because that site blocks the US",
                "points": "-2 points",
                "children": [
                  {
                    "comment": "Well, both sources say the same -- the malicious app¬†was the fake Russian version of 7z. If your gf prefers another language for software interface she must be safe from this particular malware threat. (but there might be other fake apps too, why not)\n\nEdit: added \"the fake\" part just for accuracy.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "And that surely wasn't archive contents?..",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Makes you wonder what else in the AppStore may be infected - VS, .Net, etc.",
        "points": "-3 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bj799b",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.codeproject.com//Articles/732679/HTML-Event-Calendar-Scheduler",
    "title": "JavaScript Event Calendar for Resource Scheduling",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1bj6yzm",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://voidb.in/",
    "title": "voidb.in: An end-to-end encrypted pastebin",
    "points": null,
    "comments": [
      {
        "comment": "What does that mean? Like I can't seem to input a key, so how is it e2e encrypted?",
        "points": "1 point",
        "children": [
          {
            "comment": "They key gets automatically generated and then appended as the hash to the url. So you can still easily share it, like any other pastebin, but with the benefit of it being encrypted.",
            "points": "0 points",
            "children": [
              {
                "comment": "If the key is automatically generated by the server than you can't really argue that it is fully end to end encrypted. The server at some point k ows the key so could always store it to decrypt later.",
                "points": "1 point",
                "children": [
                  {
                    "comment": "No, they key is generated by the client and the server never knows the key. The client appends it to the hash and the hash will also never be transmitted over the network.",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "Ah ok",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bj6y37",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://jerf.org/iri/post/2024/goto/",
    "title": "Goto Is Not A Horror",
    "points": null,
    "comments": [
      {
        "comment": "I‚Äôd say¬†stringly typing¬†is¬†multiple orders of magnitude¬†a greater menace to your code than¬†goto, at least a good 6 or 7\n\nThis is the single biggest reason why ORM is preferred option when working with SQL databases.\n\nI know people will complain about ORM is bad and magic, however I learn ORM using debugger and show_sql = true\n\nand for Goto - He is correct, sometime, someone needs to us Goto for some reason\n\nHowever, that someone can read high level language like Java, C/C++ or C# and translate it into assembler (in his mind) without any tool",
        "points": "4 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Yes. Very useful thing, when you don't have destructors",
        "points": "4 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Dijkstra was right, and is still right.",
        "points": "9 points",
        "children": [
          {
            "comment": "I feel like you didn't read the very short article...",
            "points": "4 points",
            "children": [
              {
                "comment": "I did in fact read it. He did not make a good enough case for the use of goto beyond advanced forms of escaping loops.\n\nJust like sealed ancient evils from fantasy novels, releasing goto from its seals will cause widespread damage and untold mayhem upon your codebase.",
                "points": "4 points",
                "children": [
                  {
                    "comment": "I feel like you actually agree with the article.",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "25 years of C++ and I have never used goto. I have never needed to use goto. I suspect that that is most people‚Äôs experience. He‚Äôs right that modern goto is not 60s goto, but so what? It is still best avoided as it is different to the other control flows and so is easy to get to wrong. Maybe C programmers need it sometimes.",
        "points": "2 points",
        "children": [
          {
            "comment": "I've been programming in C for a year now at my job and I've used goto in a couple of projects in a few places. It's really useful for error handling and early returns when you have some clean up code that needs to run.",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Not sometimes, mostly in every function which allocates resources that should be released: memory allocations, locks, fd, etc",
            "points": "0 points",
            "children": [
              {
                "comment": "That‚Äôs actually quite astonishing. I really thought that its use was rare, but apparently not.",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Stop freaking out about goto. Stop acting like the 1960s goto is the same as today‚Äôs goto.\n\nHowever, please try to rewrite your code so that you do not have to use the modern locally scoped goto constructions either. If too much work at least try to extract the aberration to a small method with only that control flow and no further logic.",
        "points": "3 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Only thing slightly close to goto is throwing and catching exceptions. I've seen people do some crazy BS abusing them.\n\nBack in the 00s I was looking at a C# project don't m some contractors wrote and found a few old fashioned gotos. Those were the days!",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bj5k9e",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.blackslate.io/articles/a-comprehensive-guide-to-trumbowyg-the-wysiwyg-editor-for-web-developers",
    "title": "A Comprehensive Guide to Trumbowyg: The WYSIWYG Editor for Web Developers",
    "points": null,
    "comments": [
      {
        "comment": "Trumbowyg 2024",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bj4aje",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://favtutor.com/articles/how-to-solve-1000-leetcode-problems/",
    "title": "Solving 1000 LeetCode Problems (Is it Really Worth it?)",
    "points": null,
    "comments": [
      {
        "comment": "No",
        "points": "255 points",
        "children": [
          {
            "comment": "duuuuude but i gotta build my resume up somehow",
            "points": "18 points",
            "children": [
              {
                "comment": "The amount of people who think Leetcode improves their resume is hilarious.",
                "points": "59 points",
                "children": [
                  {
                    "comment": "You only grind leetcode if your interview will include leetcode.",
                    "points": "8 points",
                    "children": [
                      {
                        "comment": "Even then, there's limited efficacy. Sure run Meta's questions if you're interviewing at Meta, but also you need to know how to talk to the interviewer. People are amazed they \"get the right answer\" and don't move on.. and it's because they act like automatons in their interviews.",
                        "points": "5 points",
                        "children": [
                          {
                            "comment": "People can tell if you regurgitated an answer or actually used your brain.",
                            "points": "0 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "do projects, leet code ain't gonna tell you about how real life shit works.\n\nyou won't be dealing writing complex algorithms for the most time.",
                "points": "32 points",
                "children": [
                  {
                    "comment": "you won't be dealing writing complex algorithms for the most time.\n\nIn that you will often be using libraries that are better tested than anything you wrote yourself, you're correct.\n\nBut if you don't understand how they are implemented, and the tradeoffs made, you will misuse them, so I will expect a decent dev to have at least once written their own version of many algorithms somewhere along the way.\n\nEDIT: Perhaps the anonymous downvoters think I'm somehow endorsing LeetCode. I'm not. I do expect a competent dev to understand how everyday algorithms are implemented, and some of those are not trivial.",
                    "points": "4 points",
                    "children": [
                      {
                        "comment": "I AGREE! Idk why you are getting downvoted but understanding how they work or are implemented is super useful in cases where you know that in this specific use-case you can optimize the algorithm to be more simple, or perform better, etc.",
                        "points": "7 points",
                        "children": [
                          {
                            "comment": "because he made alot of questionable assumptions about what makes a decent dev. not that id downvote him for that opinion.",
                            "points": "0 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "I iihuhuhiu hiuuuuu hu i uuuuuuu",
                    "points": "-12 points",
                    "children": [
                      {
                        "comment": "I don‚Äôt think your chat bot is working lil bro",
                        "points": "4 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Build projects and put them on GitHub.",
                "points": "3 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Cuuhuyouihiihiiiiiiiiiiiiiihhihihihiiihiiuuuiuuuuuouhhiihihihihihuuhuuuhchouuuuuuuuuhuhiuhihiuihoiihiƒßuuiu",
            "points": "-21 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Iiii√¨iiiiihiiihiiiiiihiihihi",
            "points": "-22 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Hot take: leetcode is kinda fun and I just do them as a brain break",
        "points": "225 points",
        "children": [
          {
            "comment": "Building the entire industry's interview process around them was probably a mistake but I'm not sure if there's a better option.",
            "points": "71 points",
            "children": [
              {
                "comment": "Really? I just went through a few job interview code tests and most of them were 3-hour take-home tests centered around the type of work I would actually be doing, not random algorithm brain teasers.",
                "points": "48 points",
                "children": [
                  {
                    "comment": "3 hours each? Fuck me",
                    "points": "15 points",
                    "children": [
                      {
                        "comment": "If you treat the job search as a full-time job (which you should), you can crank out at least 13 tests per week. If you have progressed to the coding assessment in the first place and are actually fit for the job, that shouldn't be a problem.",
                        "points": "-23 points",
                        "children": [
                          {
                            "comment": "Treat the job search as a full time job on top of my already existing full time job? Hard pass.\n\nNow if you're unemployed, yes, that's a different story.",
                            "points": "13 points",
                            "children": [
                              {
                                "comment": "Yeah fr screw that. Frankly even when I was unemployed I walked out of a 4-hour skills test, 10 minutes in. Signed an offer for 23k more than they were paying two weeks later anyway. That job had a much more realistic 20 minute interactive session with my future manager and one of my future teammates.\n\nDefinitely burned a bridge, but I sent the hiring manager a not-especially-cheery \"thanks but no thanks, and you probably shouldn't do that to prospective talent.\"\n\nSurprise, surprise, the employer I pursued respects my life and my time. I'm sure the place paying below average and expecting 4 hours of my time for free would have too, right?",
                                "points": "2 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "Great! You can pay someone from India to do them and they get free work done.\n\nEither that or you waste three hours and not even a call back.\n\nBest case scenario is you actually get hired but find out all your coworkers cheated and are imposters.\n\nIf a company gives me a take home then I'm immediately worried.",
                    "points": "19 points",
                    "children": [
                      {
                        "comment": "I just cheat man. I‚Äôve gotten ‚Äúexceeds expectations‚Äù on past performance reviews, I get positive feedback about my code, like, I‚Äôll be a goddamn asset whether I have niche method implementations memorized or not",
                        "points": "11 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "If I give you a take home task, I‚Äôm sure as hell gonna grill you on the decisions you‚Äôve made to get it done. If you can keep the conversation going about the topic and you can explain everything, I guess you got me.",
                        "points": "2 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "Depends on the company. I also had a pleasant interview experience recently where I was even paid. There's certainly people who are trying to rethink how interviewing is done but I have to imagine that algorithm quizzes are still common because of the low cost of administrating them, and how the results are easy to compare, even if they're not predictive.",
                    "points": "2 points",
                    "children": [
                      {
                        "comment": "No offence but your two statements are contradictory. You say you're not sure if there's a better option then elaborate that you underwent a better option?\n\nLow cost of administration in a critical process as building the team members that will build the company is the bottom of the barrel.",
                        "points": "5 points",
                        "children": [
                          {
                            "comment": "That better option was pretty time intensive and costly to the small company that administered it. I had a good experience but I've also seen the argument made that leetcode is actually pretty easy for most engineers even if you fuck up a few of them. I also had a bad experience recently where I spent two days writing 4000 lines of code for a coding challenge that was unpaid and I didn't even get to the next round (did learn some useful stuff though). So there's a balance. Some people might prefer standardized leetcode questions that are easier to prepare for rather than a time intensive process, even if I think it's not the best way for companies to interview people with.",
                            "points": "1 point",
                            "children": [
                              {
                                "comment": "In my opinion, a small company should focus on the tech stack, while a big company should focus on the engineering part. From my experience nearly everything in a small company is solvable via a slice/vector while in big companies you usually need more than that. When I interview candidates for smaller companies and startups, I focus on the programming knowledge the candidate has for the languages and technologies she'll use. Also I pay attention to the potential. Usually that's not hard. It's 30 minutes with a cup of tea.\n\nWhen I interviewed engineers at FAANG I didn't also go full leetcode on them but I picked some issues we worked on, dumped them down and asked engineers to try to solve them. Most of these questions were more about how you'd interact with a system and design rudimentary stuff like buffering or custom allocators. These things at best use recursion or circular ring buffers.\n\nThe length of the process should be proportional to the position. A tech lead or senior position needs maybe 4 rounds or more. A junior position doesn't need more than two rounds with attention from the interviewer. I can understand how tough managing all that en masse can be but I trusted my colleagues and usually that's how we approached it. It's really not that hard to gauge a good engineer, one with potential or a future tech influencer in a couple of minutes, from my experience. Maybe I'm wrong.",
                                "points": "0 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          },
                          {
                            "comment": "You say you're not sure if there's a better option\n\nno they didn't",
                            "points": "-5 points",
                            "children": [
                              {
                                "comment": "They literally did!\n\nhttps://old.reddit.com/r/programming/comments/1bj4aje/solving_1000_leetcode_problems_is_it_really_worth/kvp2zcp/\n\nbut I'm not sure if there's a better option.\n\nYou do have to remember three comments back so I can see that that is hard but come on!",
                                "points": "5 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "it's a mixed bag, some are even pair programming",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "I'm not sure if there's a better option.\n\nThere are definitely better approaches. Leetcode problems don't really tell you much as an interviewer, and obviously have a huge bias towards people who practice those types of questions. I've known plenty of developers who solve tons of leetcode problems, but if you put them in front of a large codebase with a given task, they're completely lost.\n\nA better approach (in my opinion) is to prepare a small project that resembles your day-to-day work. This could be something like a simple CRUD app and frontend on something like Hackerrank (or on a laptop if the interview is in-person). Have a few bugs that the interviewee has to solve, and maybe a few features or enhancements to add.\n\nThe goal of this type of interview is to judge how an applicant approaches the tasks. Get them to verbalise their thought process, allow them to Google what they need, and give them hints if they get stuck. Essentially, you're trying to see how they would perform in the actual role that they're interviewing for (and with the tools they'd have in the job).\n\nIt's also important that solved problems isn't your only metric. It's great if they manage to complete all the tasks, but how they approach the tasks is also important. They might bull ahead, and make assumptions without asking clarifying questions. They might have the right approach, but just not be familiar enough with the technology used to get the full answer. They might need a lot of nudging and hand holding. All of these factors play into your decision in the end.\n\nI'll end on a small anecdote. I once had a colleague that wanted to add a riddle in as an interview question. I was vehemently opposed to this, my argument being that it was simple if you knew the answer, but you could flounder and fail if you didn't realise the trick that the riddle hinged on. I see leetcode questions as falling into the same category - they're easy once you know the trick (or have seen it before).\n\nAs a bonus, he explained how it was easy to arrive at the answer - and I pointed out that his answer was wrong (from what I remember it was the riddle about having 1 item of a different weight to all the other items, and figuring out which it was).",
                "points": "6 points",
                "children": [
                  {
                    "comment": "I designed something very similar at my old job. We call it as work simulation. We send the use case a week before the onsite interview, have the candidate put the code in github and we do sort of code review with them while they are onsite. Quality of the candidates greatly improved. In the current market conditions during and post covid, there is a strong push back by candidates in this sort of thing. We modified the setup and explain a use case at the beginning of the interview, and ask them how they would approach a problem. It has mixed results.",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "IDK about Junior positions but for Senior I definietly prefer some type of discussion about different topics. Some more low level technical, maybe a small coding task, some more about higher level concepts. Leet code tests a very specific skills and the results are too binary",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I've always told people, do what you want to on your time.\n\nBut if you want to get better at interviewing, Leetcode has less value than you think. (it's good to learn approaches to coding, but just having a mock interview with a REAL interviewer who points out how you came off is so much more important)",
            "points": "9 points",
            "children": [
              {
                "comment": "I think it's because people still believe FAANG uses these methods. Thanks to YouTube and leetcode itself. Ironically now the FAANG interview process is hardly using algorithms and data structures that aren't baked into most of the languages with some recursion from time to time and the interviews are language agnostic with focus on system programming and system design.\n\nThe interview process has changed since 2017 a lot. Back then I remember in MSFT they used to ask some algorithmic questions in the second interview. But after taking a break and lately returning to another FAANG, I was surprised by how the furthest they went was using a hash map and recursion.",
                "points": "0 points",
                "children": [
                  {
                    "comment": "I think it's because people still believe FAANG uses these methods.\n\nI'll flat out tell you, FAANG uses these ... questions. I think the reason FAANG hasn't gone away from leetcode, is leetcode teaches the wrong thing. (The answer is all that matters) and it's really all about the communication between you and the interviewer.\n\nIronically now the FAANG interview process is hardly using algorithms and data structures that aren't baked into most of the languages with some recursion from time to time and the interviews are language agnostic with focus on system programming and system design\n\nWhere did you hear this? I literally did phone interviews this year where I had questions I could find on leetcode or hackerank (PS. Passed both... And then reorgs killed the process so F that.) . So they haven't fully moved away from any of that. (Granted I'm talking Meta and Google)",
                    "points": "1 point",
                    "children": [
                      {
                        "comment": "MSFT, Netflix and Datadog don't do that anymore. MSFT isn't a single unit because of the many teams. In 2017 I had these questions, lately not at all. My colleague works at Netflix and they do system design more than coding interviews especially for senior positions. At Datadog we focus on testing how engineers leverage the language to interact with various systems. In the second interview we use simple data structures like ring buffers or doubly linked lists to create something simple as a custom allocator. Third interview, system design. Fourth and fifth interviews are culture fit stuff. I didn't work or interview at Google nor Meta yet but if they're still doing these things then I guess not all FAANG is unified anymore.\n\nP.S: The second interview with leetcod-ish stuff isn't as important as the first one (the process stops if you fail) or the system design one (your position is shaky if you do bad in it)",
                        "points": "0 points",
                        "children": [
                          {
                            "comment": "That's great news then. I'm glad to hear companies moving beyond it. Because leetcode is kind of a broken system for \"right answers\" even if the site really misses out on the \"Interview\" part of an interview question.\n\nJust in general the number of times I had to implement something like leetcode and not either use a library that does, or just look up the code is exactly 0. It's one thing to know the algorithm, it's another thing to demand someone program it under huge time and stress pressures. Hell I rewrote a SHA1 function (Limited memory so we couldn't use the library) but I still has the source code next to me as well.\n\nAs a senior engineer and above, I find the system design to be way more important (Though get freaked out when companies don't even fizzbuzz) but ultimately I play the game as it's designed.",
                            "points": "0 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Having hobbies isn‚Äôt a hot take lol. And it‚Äôs ok if people don‚Äôt have the same hobbies as you.",
            "points": "21 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Yeah, hard agree, though I prefer project euler",
            "points": "4 points",
            "children": [
              {
                "comment": "Agreed. I have done Project Euler for fun. Leetcode focuses too much on the interview aspect and competition whereas Project Euler is more about solving puzzles and learning something from them.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I agree. I find it odd that programmers are often so hostile to programing problems. I would have thought programmers would find them fun and interesting. Maybe it's just the connection with interviews",
            "points": "-5 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "i use to be like you than i grew up and realized its a waste of time",
            "points": "-9 points",
            "children": [
              {
                "comment": "Sounds like you still have some growing up to do üëç",
                "points": "6 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Solving 1000 LeetCode problems is not important; solving questions in minimum time is important. In the coding round, you only have 1.5 hours to solve 3 questions\n\nThis is the conclusion the article makes. The author of the post is deciding if solving 1000 problems is worth it FOR participating in contests. Its probably key to understand what solving 1000 problems represent, if it means learning a new data structure or some algorithm it could be reasonably useful in certain scenarios, the key question is it worth it for what scenarios?\n\nFor a job interview ? - It could be worth it for jobs where leetcode is commonly asked (eg FAANG companies that ask it). There are other companies where leetcode is not asked so it may not be worth it.\nFor learning about interesting problem solving techniques and data structures ? - In a way yes, if you want to learn how a database like MySQL stores data in a tree, you'd want to know what a Tree even is and doing leetcode problems on trees would give you the knowledge on what a tree is and would give you practice to be able to manipulate trees and try different stuff with it. But it should be noted that leetcode problems are generally too simple in these cases for instance a tree problem in leetcode is just a simple tree of numbers whereas in real life it is probably a tree of objects (I know its not a big difference but it can trip up new programmers) but its still good for fundamentals before you jump into the actual mysql codebase\nDoing it as a hobby ? - If you're the kind of person who wants to solve programming problems for fun then leetcode is a great place to do it\nDoing it to participate in ds coding contests ? - It definitely is worth it especially for a beginner but once you get to a good level you'd have a lot more fun at codeforces\nFor performing well at the actual job ? - Its usefulness highly varies based on the kind of work you do at your job, if all you are doing is CRUD operations or building websites or standard run of the mill analytics software you can get by without knowing any of these. But if you are building something that has a data structure at its core (like a database) you atleast need to know that a data structure exists for a use case.\n\nOne example I heard from a friend was about how this dev (not exactly dev but a business analyst who knew coding) was storing a bunch of data in an array and then looping through it every single time to see if there was a duplicate file name that existed when they encountered a new file. The only problem was there was a huge number of files and this person did not know about databases so they couldn't just store it there and check nor did they know what a map or a key value pair was so it was just bad code. At the end of the day it has its own pros and cons and is nuanced as hell and it doesn't really make sense to just make a generic statement",
        "points": "35 points",
        "children": [
          {
            "comment": "Ah yes! I also invent new databases on every job!\n\nAlmost everything is already invented and tried and tested. Just use what there is and focus on the bussiness goals",
            "points": "4 points",
            "children": [
              {
                "comment": "I also invent new databases on every job!\n\nHence my disclaimer that it really depends on your job, if you work at a company that specifically builds database technology (Eg SurrealDb or with AI coming now Vector databases or extensions to add vector capabilities to existing databases are now all the rage now) then you definitely would have to know what a database is and how it works under the hood else how would you be able to write code for it. Also databases was just an example it could have been any other piece of tech.\n\nOn the other hand if you are working at a company that does simpler stuff then you don't have to worry about it. Again as I've mentioned it is extremely important to understand that there's a catch to everything and we can't just be making generic statements.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "If you're working for a company selling database software then it is the business. But I guess they don't know that everything is already invented, because they're still developing and releasing new versions...",
                "points": "-2 points",
                "children": [
                  {
                    "comment": "The algos where done in the 70s..",
                    "points": "-1 points",
                    "children": [
                      {
                        "comment": "\"Tell me you've never worked in that domain without telling me\".",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Iiii",
            "points": "-13 points",
            "children": [
              {
                "comment": "Iiiiiiihiiiiiiihiiihiiihiiiihiihiƒßhuuuuuuuuuuuhuhuihuuuuuuihuouuihhihhiiuuiiiiiiiiiiiiiiiiiiiiiiiiii",
                "points": "-9 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Answer: No.\n\nBecause when applicants sit in front of me for the interview, they get a piece of practical code, that has nothing go do with anything you see on [insert-comp.-coding-site-here] and a question like \"Lets talk about the approach taken here and its pros and cons\".\n\nI don't care about Leetcode. LLMs can solve Leetcode. I don't hire for skills the computer can do faster and cheaper. I hire for the skills it cannot.",
        "points": "92 points",
        "children": [
          {
            "comment": "we should generate code with LLM during an interview and then have the devs debug and fix it.",
            "points": "22 points",
            "children": [
              {
                "comment": "Being able to crawl through code written by someone else is one of the best skills any programmer can have.",
                "points": "11 points",
                "children": [
                  {
                    "comment": "I know, right? and how bad could this LLM code be anyways?",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "You monster!",
                "points": "10 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "The sweet spot is maybe 50-100 problems. Mostly easy/medium for fun and the occasional hard one for dedicated study. Its a fun exercise; not some holy grail of coding ascendance.",
        "points": "9 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Leetcode as a hobby is ok",
        "points": "8 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "https://en.wikipedia.org/wiki/Betteridge%27s_law_of_headlines",
        "points": "4 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "No, make a real project that people can use. Don't waste time with LC.",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "This tells something about you that is enough to get you a good job.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "It depends.\n\nLeetCode can be helpful to test your existing knowledge and get you thinking about different ways to breakdown solve the same problem to find approaches that yield better performance (time and space complexity). It should help you develop a mindset and thought process more so than wrote memorization; you should be able to explain why one solution is better than another. If you‚Äôre doing them right, you should be able to recognize a very differently worded problem as being similar/the same in terms of the solution, data structures involved, algorithm approach, etc.\n\nWhen Interviewing at Google, they are not testing you for any particular role or project. Their problems tend to be very direct and impersonal - here is the GIVEN info, implement a solution to do X and make it run in O(n) time. The candidates who get through all of the stages then essentially become the interviewer to team leads and managers for potential projects/teams that they want. (At least that was how it was done in my experience about a decade ago, maybe it has changed)\n\nOne problem in the industry is that technical interviewers are often not trained for that role at their company. They instead lean on these generalized technical screen platforms like LeetCode and/or the experiences they had when they interviewed. In the flip side, some companies do have a rather rigid and unhelpful guideline script that they want their interviewers to follow but which are way too generalized for the project/team/role and probably were written by someone in HR rather than engineering.\n\nAt the end of the day when I am screening candidates, I keep a git repo with all types of questions and various solutions with unit tests at my disposal. Depending on the role and the needs of the team and the position level, I look for different things. I always start with a general conversation and pick and choose which questions from the set to use. Sometimes people suck at one type of problem and that‚Äôs OK. If the domain doesn‚Äôt require using graphs ‚Ä¶ I‚Äôm not going to ask them to implement Dijkstra's algorithm. If they‚Äôre not senior level, I‚Äôm mostly looking to see if they have enough foundational knowledge and the mindset to learn and grow on the team.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I've lost out on jobs that would have been an otherwise great fit because of this nonsense interview style.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Not at all. It is a disposable knowledge and experience. You will quickly forget most of the tricks soon after you stop doing that exact same type of puzzles, i.e. even if you continue doing other type of LC puzzles.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Imo I only do leetcode because it is asked in an interview, other than it is nothing.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "No",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "You kind of missed something rather important.\n\nIf you're going to do FAANG level interviews, then Leetcode may prepare you for that... Except....\n\nThey also don't. \"I can solve the problem.\" isn't what these places are looking for. \"I can communicate about my solution and I come up with a reasonable algorithm.\" is\n\nYOU MUST practice the communication and collaboration of the ideas, YOU MUST be talking with your interviewer, YOU MUST take feedback and hints. I've done interviews as well and the person who nails every question is impressive, but the person who collaborates with the interviewer is the one was prefer to hire. And Leetcode does nothing for this type of thing.\n\nEven leetcode's testing is good for pressure but AWFUL for communication AND awful for actual interviews. The people who come in get a question, don't ask any follow up question and just turn in the \"Correct answer\" is staggering, and yet there's more than enough discussions from the FAANG interviewers to understand that those approaches don't get the job.\n\n\"Why?\" Because they didn't actually ask questions. When I give a problem I'm not giving an order, I'm giving a situation. Today I had an interview. \"Search a Doubly Linked list for a value.' you know what? I'm going to pass that, and not because I can do .... Because I started with asking \"How is the list designed? Is the list well formed? Can we be sure there's a end and we're at the proper beginning?\" and so on. Those questions showed I wasn't just answering the problem, I was designing the problem, and that's the key to a lot of interviews. (And man the interviewer didn't have a poker face, I could hear on the phone call he was happy with those questions rather than just jumping into code.)\n\nNow you want my story? Google gave me a thumbs up on the phone interview... then laid off people, so the position was gone.. A crypto company gave me the thumbs up on the phone interview and reorged the company (fired the HR person talking to me). Meta gave me thumbs up on the phone interview and they wanted me to come in.. except they sent out offers on the position they were looking at me for just before they did, and there's no others in Orange county right now.\n\nFML. I'm probably going to be taking a job in Orange County for potentially 160k because the market is in such a shitter of a position. I have the skills, I just have had rotten luck. The good news is I have 16 years experience, I have the knowledge, I have seen that I can pass the interviews. And you know what, there's always next time, but it'll be on my schedule, not when it's layoff time again.\n\nEdit: Also forgot System Design which is not easily teachable (is not teachable at all maybe?) with leetcode's system.",
        "points": "-3 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "It's fun and it improves your programming skills, so yes definitely. Although I wouldn't put a target on it.",
        "points": "-3 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Not really, no.",
        "points": "-1 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Do as many leetcodes as you can, as many projects outside of work as you can, have no girlfriend and please, do no have any time to exercise or a be a nice person outside of work, that is going to guarantee you get hired! /s",
        "points": "-1 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "if you are not yet sure what domain you want to eventually pursue, how about hopping over to https://github.com/RajaSrinivasan/assignments and explore. Explore broadly but get deep into some aspects of interest - would be my advice. best, Srini",
        "points": "-2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Iighuguijarro uuuiuuuuuhuuuuuuh",
        "points": "-6 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bj1x05",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://tau.net/wp-content/uploads/2024/03/Theories-and-Applications-of-Boolean-Algebras.pdf",
    "title": "New study could provide revolutionary way to build an AI that understands Logic and Time: Theories and Aplications of Boolean Algebras by Ohad Asor",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1bixcvw",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://medium.com/@JonathanSaring/11-monorepo-build-tools-you-should-know-35b83738b95f?source=friends_link&sk=cbff121377d709f6e30ab123b6b85a4e",
    "title": "11 most used Monorepo Build Tools",
    "points": null,
    "comments": [
      {
        "comment": "I was actually just thinking of building something like bit. It looks like they really try to force the enterprise commercial cloud offering though...",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1biwwy0",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.reddit.com/r/geek/comments/1j9tn3/speed_camera_sql_injection/?rdt=63222",
    "title": "Messing with AI programs",
    "points": null,
    "comments": [
      {
        "comment": "Search for AI \"poisoning\" - that's the terminology being used for this concept. Judging from headlines, yes, it's possible but I don't know any details.",
        "points": "11 points",
        "children": [
          {
            "comment": "awesome! Thank you for telling me",
            "points": "-1 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "At this point LLM poisoning is a moral imperative.",
        "points": "12 points",
        "children": [
          {
            "comment": "True. Feeding an LLM transperently on ‚Äúclean‚Äù/‚Äúattributed‚Äù data to prevent poisoning is the ideal response to those attempts. We should not be in the dark about what data is fed into these things. And we should know where the data came from, and be morally okay with that sourcing of data.",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I feel like it‚Äôll just open another arms race, but not one that will last very long in favor of the poison, without having some LLM make that poison to begin with.",
            "points": "1 point",
            "children": [
              {
                "comment": "I align on that. We'll see models to poison images and models to heal the images from this poisoning.\n\nThis won't really prevent anything from happening.\n\nWe would need to enforce IP at the physics level to prevent this arm race. Like we use QM to distribute keys using a channel protected against man in the middle attacks enforced by QM physics.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "A lot of professional art comes from sampling the work of other artists. Unless it's flat out spitting out a single piece of art and calling it its own I don't think you can claim there is anything illegal bout it.",
        "points": "-9 points",
        "children": [
          {
            "comment": "people learn via references and practice, AI art copies and pastes. Though there are thousands of arguments that can be said, I‚Äôm mainly interested in the programming part I asked about, though look at any interview asking creators of AI art programs about how it gets info and them trying to change the subject when asked about this it‚Äôs pretty clear it‚Äôs not only messed up but a legal nightmare",
            "points": "-3 points",
            "children": [
              {
                "comment": "AI art copies and pastes.\n\nIt doesn't, though. In the case of image generation, it ingests the source images, adds increasing amounts of noise to the image, and then reverses the process. It learns this pattern over time so that after sufficient training, it can start from the noise alone and get to an image output. There is no actual connection from the source image to the generated image.\n\nI'm not making any value judgement on whether or not this is unethical. I can certainly understand the side of the artist who has created some original work that was published online with his or her name, possibly a description, to have what is essentially an algorithm be able to derive work from that. Greg Rutkowski has a real gripe.",
                "points": "1 point",
                "children": [
                  {
                    "comment": "yes I agree it‚Äôs definitely a very tricky subject, I think more so ‚ÄòAI poisoning‚Äô is a balance to the issue as it gives artists a voice on whether the AI can use it or not. I think of it as when artists say under their posts on Instagram if people can repost/reuse/reference their art, people tend to respect their wishes and if they don‚Äôt, the art copied from their account can be taken down via Instagram guidelines, and now similarly AI poisoning can be used to respect those wishes I suppose",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "There are works of art that are literally stitched together pieces of other peoples art. Yet it's still an original piece of art. Copyright doesn't work like that. You can't copyright things that are derivative or made from your art.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1biwktf",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://aus.social/@zanchey/111760402786767224",
    "title": "David Adam: \"#fishshell rewrite-it-in #rust progress, 2024-01-15: 100 %\"",
    "points": null,
    "comments": [
      {
        "comment": "So, we're done? Well, yes and no.\n\nYes, in the sense that almost all the C++ has been rewritten in Rust (at a raw line count about 10% more, which is not a particularly insightful number). The fish_test_helper standalone binary remains in C++, because it's basically entirely libc calls, uses no other fish code and never gets run by end users.\n\nNo, in the sense that none of this code is shipped to users. We've still got work to do to get this into a tarball that someone can (say) brew install - at this stage I think it looks like CMake will be hanging around, much simplified, to handle some of the configure/install targets, while cargo is used for the actual build.\n\nHowever, some of the social goals have definitely been achieved. Large parts of the rewrite came from contributors who had never worked on fish before. There's been a lot of buzz in various online fora. Vibes are just as important to free/open source software as proprietary software and although there were solid technical reasons for the port, the PR outcomes are added benefits.\n\nFinally, this is definitely not proof that you should rewrite your software in Rust. It's a data point at best, and maybe check back when the answer to \"are we done\" is \"yes for sure\". [ ... ]",
        "points": "70 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Congratulations on the milestone, Fish Team!",
        "points": "26 points",
        "children": [
          {
            "comment": "Also interesting to read the link why and how it was planned and done - piecemeal and step by step. No big refactoring or added features at this phase.",
            "points": "5 points",
            "children": [
              {
                "comment": "I don't understand - how could it have been done piecemeal and step by step, yet not have any rust code shipped to the user at this point? What do they mean by:\n\nNo, in the sense that none of this code is shipped to users.\n\nAre they compiling, linting and running tests on the rust version that they have in parallel to the main build?",
                "points": "1 point",
                "children": [
                  {
                    "comment": "No new release but each commit must deal with external block first before touching core internals",
                    "points": "4 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "next: rewrite it in zig",
        "points": "15 points",
        "children": [
          {
            "comment": "What I miss in such suggestions of zig is a solid argument in what would be the advantage, in contrast of writing in Rust. They, for example, wanted to add concurrent execution and better safety, which Rust supports.",
            "points": "9 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "What is the performance increase? Or the main benefits of this great work?",
        "points": "0 points",
        "children": [
          {
            "comment": "It sounds like the goals were:\n\nincreased safety\neasier concurrency\nattracting new contributors",
            "points": "1 point",
            "children": [
              {
                "comment": "1 and 3 I get it but 'easier concurrency for a shell?? I don't understand.",
                "points": "1 point",
                "children": [
                  {
                    "comment": "Well shells can have multiple jobs running concurrently and there is also some concurrency when piping through several programs at once I guess (a | b | c)",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "I can only guess, but consider a scenario where the prompt fetches things like the current dir's git status. It's nicer for that to not block.",
                    "points": "-1 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Can we stop re-writing things in rust? Make new things if you are so enamoured with the language.",
        "points": "-42 points",
        "children": [
          {
            "comment": "Why do you care? Their lead devs made the decision that a Rust rewrite would be beneficial. If you're looking for a \"new thing\" in the same domain written in Rust there's nushell that I know of, but it's not personally my cup of tea\n\nBut again, why does it matter to you?",
            "points": "41 points",
            "children": [
              {
                "comment": "100%.",
                "points": "3 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "you ok bud?",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1biuyer",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://blog.pragmaticengineer.com/the-ai-developer/",
    "title": "Is the ‚ÄúAI developer‚Äùa threat to jobs ‚Äì or a marketing stunt?",
    "points": null,
    "comments": [
      {
        "comment": "One of their MRs for a test they supposedly passed was openly mocked by the maintainers for how bad it was.¬†https://github.com/pvolok/mprocs/pull/118",
        "points": "26 points",
        "children": [
          {
            "comment": "I thought that first comment was satire üò¨",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "It's corporate propaganda salivating over yet another way they can reduce salary expenditures, which they consider a cost sink.",
        "points": "26 points",
        "children": [
          {
            "comment": "yet another way they can reduce salary expenditures,\n\nReplace tech workers with Ai that causes a major problem and then requires the supervision of the same amount of tech workers. I can see it now.",
            "points": "11 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I mean many white collar tasks can (and should) be automated away so that these people can do real tasks that require real thinking. It‚Äôs just that those tasks require training that is more complex than ‚Äúdrag and drop these files‚Äù and breaks the corporate paradigm of ‚Äúfuck helping our employees we just want next quarter to be record profits.‚Äù",
            "points": "4 points",
            "children": [
              {
                "comment": "Not everyone is capable of that level thinking. You can‚Äôt employee train your way out of this issue in the long term",
                "points": "3 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "It‚Äôs VC backed startups pitching / selling AI hype to their investors, with the (dubious) claim they can sell their AI product to corporate MBAs to downsize / lay off their expensive engineering workforce",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "When I can get the AI to spit out a bug-free branch refactoring my 35k LoC React frontend to add a new feature or rewrite some existing functionality, I will happily welcome it and focus on figuring out what to improve instead of having to build it myself.",
        "points": "5 points",
        "children": [
          {
            "comment": "Yeah but if it were that simple business themselves could do that, there wouldn't be anything for you to do anymore.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "35k LoC React\n\nThose are rookie numbers. I'm currently modernizing a 2M lines spaghetti project from the late 90s-early 2000s. I wish AI could help with that.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Why not both?",
        "points": "6 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I thought everyone with half a coding brain worked this out last week...?\n\nAre there people still impressed by the magic smoke and mirrors...?",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "The current state is closer to a supercharged IDE that attempts to implement a feature or fix an issue.\n\nQuite promising for a V1: to handle easy PRs, boilerplate or just changes that are simple but take time to implement.\n\nHowever the V2 and V3 of such tools are probably going have much boarder confidence scope.",
        "points": "-3 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1biuh53",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.git-tower.com/blog/dev-philosophy-2/",
    "title": "Our Development Philosophy: Collaboration & Testing",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1biugh6",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.cyberkendra.com/2024/03/new-research-exposes-privacy-risks-of.html",
    "title": "New Research Exposes Privacy Risks of WebGPU Browser API",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1biu9yl",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://blog.sellmair.io/composition-over-inheritance-my-refactoring-recipe",
    "title": "Composition over Inheritance: My refactoring recipe",
    "points": null,
    "comments": [
      {
        "comment": "Maybe there's a language-specific subtlety that I'm missing (never touched Kotlin/java) but I don't understand why you're claiming that abstract classes are the problem.\n\nThe problem is not abstract classes, it's inheriting logic. A hierarchy of concrete classes would be just as problematic whereas pure abstract classes would not (they would basically just be interfaces).",
        "points": "8 points",
        "children": [
          {
            "comment": "I actually had to think for a second, but a hierarchy of concrete classes is a very rare thing in Kotlin because all classes are final by default. I hoped that the last section of the post acknowledged that using abstract classes as 'contract' is fine!",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I would just like to mention my own experience with abstract classes from a slightly different perspective: I was working on a project where abstract classes really were the best solution. However, it took me a long time to come to this conclusion and verify this because I was always told to go with composition over inheritance.\n\nIn this particular project, using composition resulted in incredibly complex code that was otherwise extremely simple using inheritance. Not only that, but inheritance also resulted in less code upkeep because the shared code changed very infrequently, if ever. Sometimes you want and benefit from tight coupling. It's very context-dependent.\n\nI think the important thing to focus on here is teaching people to look at their architecture and the structure of their code first. If you have an idea of what your architecture looks like, you can then determine what the best tool for the job is. Often, I agree, it will be composition. However, analyzing the architecture from the very beginning would have saved me so much headache.",
        "points": "1 point",
        "children": [
          {
            "comment": "Thanks for sharing, I would be very interested in this architecture. Is there any way for you to share more details? So far, in my entire career, I did not come across something like this",
            "points": "1 point",
            "children": [
              {
                "comment": "The gist is that it was a game that actually was pretty easily componentized. The game had variations which I'll call game modes. I started by creating independent components to a degree I felt was reasonable, and then the idea was to compose them together to get the various different game modes.\n\nThe problem was that there was a large amount of common code that simply didn't fit into the components I made. Even if you consider this code its own component, it would always be required for all game modes. This is exactly the purpose of an abstract class. So I ended up making a \"base\" game mode and the other game modes all inherited from it.\n\nYou could probably accomplish the exact same thing by creating a game manager that handles common code, but at least at the time that felt overly complex and the abstract class route was just easier, especially since each game mode has a unique set of rules and isn't necessarily purely represented as a composition of components. Since each game mode has a unique set of rules, you'd end up creating multiple managers of some sort anyway to handle that. Why do that instead of just using an abstract class and overriding or extending methods as necessary?\n\nPerhaps there's a different way to go about it compositionally that would be easier, but I felt abstract classes ended up working best in that situation because that's the exact kind of problem they're designed to be used for.",
                "points": "2 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bitgfp",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.thomasclaudiushuber.com/2021/02/05/what-is-actually-the-universal-windows-platform-and-what-is-winui-msix-and-project-reunion/",
    "title": "What is Actually the Universal Windows Platform and what is WinUI, MSIX, and Project Reunion / Windows App SDK?",
    "points": null,
    "comments": [
      {
        "comment": "Can you list some UWP apps (using the UWP app model) that you use on daily basis?",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bit2sb",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.itpro.com/software/development/python-stretches-its-lead-as-the-most-popular-programming-language-but-why-does-it-have-such-widespread-appeal",
    "title": "Python extends its lead as the most popular programming language ‚Äî but why does it have such widespread appeal?",
    "points": null,
    "comments": [
      {
        "comment": "The Tiobe institute aims to ... help companies make strategic decisions about what programming language should be adopted for new software\n\nWhat professional industry is using Scratch, which is in the top 10?",
        "points": "509 points",
        "children": [
          {
            "comment": "Tiobe is shit and should not be cited at all.",
            "points": "280 points",
            "children": [
              {
                "comment": "Oh of course, that was essentially my point. If one of your top 10 languages \"recommended to companies\" is an educational toy, no one should take you seriously.",
                "points": "130 points",
                "children": [
                  {
                    "comment": "As a full stack front end left handed Scratch dev I couldn‚Äôt disagree more. You just don‚Äôt understand the full potential of this flexible language.",
                    "points": "88 points",
                    "children": [
                      {
                        "comment": "Fucking lefties‚Ä¶",
                        "points": "33 points",
                        "children": [
                          {
                            "comment": "any language is commercially viable once you pull up your programming socks",
                            "points": "18 points",
                            "children": [
                              {
                                "comment": "These young devs really need to pull themselves up by their socks.",
                                "points": "9 points",
                                "children": [],
                                "isDeleted": false
                              },
                              {
                                "comment": "What about haskell",
                                "points": "2 points",
                                "children": [
                                  {
                                    "comment": "I'm aware of companies using Haskell in niche areas. Hedge funds and similar. For them, it's very viable.",
                                    "points": "5 points",
                                    "children": [],
                                    "isDeleted": false
                                  },
                                  {
                                    "comment": "Perhaps we can use haskell for the front end, and prolog for the back end. We might need some long programming socks though.",
                                    "points": "2 points",
                                    "children": [],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "",
                        "points": "",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Tiobe is the dumbest fucking thing to have hit the programming world and it's unbelievable how many people take it seriously.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I typed in +\"scratch programming\" in Walmart.com's search and started getting a bunch of \"learn Excel VBA programming from scratch\" books and stuff like that. The first result for it in wikipedia.org is the \"Plus and minus signs\" article, followed by \"Unicode subscripts and superscripts\", and then you finally get a wikipedia article that's actually about the programming language.\n\nAll of those count for TIOBE's metrics.",
            "points": "100 points",
            "children": [
              {
                "comment": "I'll be naming my next language \"The\". Get on this rocket to The top of TIOBE now!",
                "points": "45 points",
                "children": [
                  {
                    "comment": "That is probably skipped by google. I have high hopes for my new language \"milf\" though.",
                    "points": "28 points",
                    "children": [
                      {
                        "comment": "Man I Love Functional programming languages",
                        "points": "20 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "how about \"amateur\", a new programming language to teach new computer users how to program!",
                        "points": "4 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "\"The\" is a common word and was excluded from your search.\n\"Who\" is a common word and was excluded from your search.",
                        "points": "1 point",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "Heck, I'll name mine \"Programming language\".",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "All of those count for TIOBE's metrics.\n\nWhat - really??!",
                "points": "5 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Companies with slogans like ‚ÄúJust Scratch it!‚Äù",
            "points": "4 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "The education industry...lol...its almost like there is more than one market to sell products into.",
            "points": "3 points",
            "children": [
              {
                "comment": "",
                "points": "",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Education is definitely an industry, especially related to cs",
            "points": "5 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Considering the state of some colleagues, maybe the industry should use it more.",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I just checked and yup, it's ninth, just above Visual Basic.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Apple",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "For the record, TIOBE's rankings are based on how many hits you get when you search +\"<language> programming\" in a bunch of different random websites with search engines (8 are Google in different languages, 7 are Amazon in different languages, then you got stuff like Walmart and Ebay) put at seemingly random weights (I think it used to be based on the now discontinued Alexa rankings, not sure if they've updated them since).\n\nThat's it. That's what \"most popular programming language\" means, just that if you search +\"python programming\" in a bunch of different websites you get more results than +\"java programming\", when many of those sites are stores that give you \"learn C++ programming in 30 days!\" books when you try either.",
        "points": "420 points",
        "children": [
          {
            "comment": "day 25183261372 of asking r/programming to ban every article that uses tiobe as a serious index. this garbage leads to so many under and overratings. any serious index will tell you that python is almost definitely second to javascript in terms of usage, but tiobe placed it first and javascript sixth. pure garbage.",
            "points": "270 points",
            "children": [
              {
                "comment": "day 25183261372 of asking r/programming to ban every article that uses tiobe as a serious index.\n\nIf you want to be taken seriously, use epoch time like a real programmer. gg git gud",
                "points": "30 points",
                "children": [
                  {
                    "comment": "Instructions unclear, using NTP epoch.",
                    "points": "2 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "But my epoch resets every 50 days!",
                    "points": "2 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "if you're a real programmer, surely you can implement a multiplication by 86400 yourself ;)",
                    "points": "2 points",
                    "children": [
                      {
                        "comment": "Only 80085",
                        "points": "2 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "ggnore",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "",
                "points": "",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "This is especially frustrating to read given that a lot of search engines don't actually have as many results as they say anyway. Search for literally anything and you'll never get more than 1000 results in before it says nothing else can be found. They might as well be throwing sticks into a cup of water and reading the pattern on the bark",
            "points": "15 points",
            "children": [
              {
                "comment": "TIL",
                "points": "2 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "They might as well be throwing sticks into a cup of water and reading the pattern on the bark\n\n\"Why is chicken getting so expensive lately?\"\n\n\"Oh, Google upgraded their algorithm.\"",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Maybe measuring the usage of languages on code hosting services (like GitHub) would be better?",
            "points": "5 points",
            "children": [
              {
                "comment": "Almost anything would be better than this lol",
                "points": "3 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "Even that has biases. For years, and to an extent still, FOSS was obsessed with C/C++. So those languages will be dramatically over represented in Github.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Basically with this methodology the more noobs using a language asking questions online the higher ranked‚Ä¶ yup sounds like python!",
            "points": "23 points",
            "children": [
              {
                "comment": "Not just that, it has to include the word programming... Java won't typically have the word programming after",
                "points": "7 points",
                "children": [
                  {
                    "comment": "Keep getting results for coffee and Indonesia.",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "to be fair, if popularity is what you're trying to determine, then Google trends or number of mentions wouod be a oretty good indicator for how popular a language is.. if all they are doing is summing the number of results then hea that pretty bad, but seemingly they could just use existing metrics.",
            "points": "2 points",
            "children": [
              {
                "comment": "The problem is that Python is a word outside of programming, as are Java, Rust, Go, etc. That last one in particular will give a lot of false positive matches in Google, and even the other languages will get muddy results lower down the list where Google will also show results that don't match every word in your query.\n\nIf you want a somewhat reliable statistic, then you'd look at GitHub, Gitlab, etc. By determining which languages are used in a repository and tallying up the people that commit to repositories containing those languages will give you a much more interesting number. And even that number would be skewed towards hobby projects, considering companies often have their own servers for centralized version control.",
                "points": "6 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "To be clear, they're not using Google trends or similar data; those are based on how many people search for a certain term, and could actually be useful.\n\nTiobe is based on that number you get on Google (and other shit like eBay for some reason) for \"x results found\". It's complete garbage.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Basically keyword trends.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "",
            "points": "",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "This article really reads like it was written by a LLM lol",
        "points": "108 points",
        "children": [
          {
            "comment": "They all are now.",
            "points": "41 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "You honestly think that Steve Ranger, an award-winning reporter and editor who writes about technology and business, would use an LLM to write about technology and business‚ÄΩ",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "",
            "points": "",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I love typed python. I hate untyped python.",
        "points": "100 points",
        "children": [
          {
            "comment": "If I'm typing I'd rather use a more appropriate language.",
            "points": "77 points",
            "children": [
              {
                "comment": "Python is not synonymous to badly written scripts because shell is a pain to maintain.",
                "points": "10 points",
                "children": [
                  {
                    "comment": "Passing data from one step to another in shell is extremely fragile and tends to fail in ways that are truly ingenious and evil.",
                    "points": "4 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Pretty sure it is just type hints and not strict typing. I tend to use it now for function definitions.",
                "points": "29 points",
                "children": [
                  {
                    "comment": "And with a static type checker as a quality gate, the distinction becomes meaningless.",
                    "points": "10 points",
                    "children": [
                      {
                        "comment": "",
                        "points": "",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Python is the appropriate language when its typed",
                "points": "0 points",
                "children": [
                  {
                    "comment": "Problem is that as long as it remains untyped by default the ecosystem as a whole will never be typed. And third party libraries are exactly where strict typing is the most useful. It's great when your editor can just tell you instantly that you're using a library function wrong",
                    "points": "19 points",
                    "children": [
                      {
                        "comment": "From my experience majority libraries that I depend on are typed or someone created stubs for them (for example boto3).",
                        "points": "5 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "Python is strongly, dynamically typed.",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "Pyhon is strongly, dynamically, and optionally/gradually statically typed.",
                        "points": "2 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "Python has syntactically significant whitespace, so it cannot possibly the appropriate language.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I agree, but only when the type annotations are correct and meaningful. The fact that you can give something an incorrect type annotation is just insane to me (and I‚Äôm no Python hater - it‚Äôs 95% of my day job)",
            "points": "11 points",
            "children": [
              {
                "comment": "",
                "points": "",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "If you start 100% typed and all of your libraries are typed (lol) it can be good. But not even all of the stdlib has type hints and mypy will lie to you very consistently about the correctness of your types and instill a false sense of security without a lot of effort to both understand what mypy is and isn't checking. Typed python is better than untyped python in some regards, but I'm strongly opposed to relying on it in any capacity because it has bitten me far too many times.",
            "points": "11 points",
            "children": [
              {
                "comment": "What's your biggest bite in the ass moment",
                "points": "2 points",
                "children": [
                  {
                    "comment": "collections.abc.Iterable\n\nThis is great for checking for lists and tuples and sets. It's a dumpster fire when someone else might pass through a dictionary or a string.\n\nType checking will show those as acceptable, which seems fine to everyone who looks at it until someone passes a value into your lovingly crafted pipeline that hits it like a rock in a boxfan, bringing the entire thing to a screeching halt at 2 in the morning on a Saturday. So now you're getting a call in bed, your french-swiss manager is yelling \"APAC is down!\" in a tone and cadence you could not discern while awake and sober but is nonetheless very urgent and very loud. You step on the cat in your vaguely drunken career-fear undressed dash down the hallway and he retaliates in equal measure and brings you down to the ground like a frightened AT AT. You will rise and continue your mad, naked dash through the house, knocking over at least three (3) items of nondescript regard on the way to the computer while your manager says something you are very sure is not in a language you speak. The developers in India are insufferably smug when you join the group call and debug the issue. Thirty minutes later you make a two-line change that does an actual isinstance(obj, (list, tuple, set)) inspection. It will take two passes with the steam cleaner to get the blood out of the carpet where the cat got you but the trauma will last a lifetime.\n\nAnyway type checking is a good way to give yourself a false sense of security and workers comp will not pay for work-related psychological damage",
                    "points": "13 points",
                    "children": [
                      {
                        "comment": "AT AT fighting is a good description for this cat behavior.",
                        "points": "3 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "I still don't get what the issue is, it works fine as far as I can tell:\n\nfrom collections.abc import Iterable\n\ndef function(arg: Iterable[int]) -> int:\n    result = 0\n    for i in arg:\n        result += i\n\n    return result\n\ndef main() -> None:\n    l: list[int] = [1, 2, 3]\n    t: tuple[int, ...] = (4, 5, 6)\n    d1: dict[int, str] = {7: \"seven\", 8: \"eight\", 9: \"nine\"}\n    d2: dict[str, int] = {\"seven\": 7, \"eight\": 8, \"nine\": 9}\n    s = \"hello world\"\n\n    print(function(l))\n    print(function(t))\n    print(function(d1))\n    print(function(d2))\n    print(function(s))\n\nif __name__ == \"__main__\":\n    main()\n\n\nAnd then run:\n\n‚ùØ mypy --strict test.py\ntest.py:20: error: Argument 1 to \"function\" has incompatible type \"dict[str, int]\"; expected \"Iterable[int]\"  [arg-type]\ntest.py:21: error: Argument 1 to \"function\" has incompatible type \"str\"; expected \"Iterable[int]\"  [arg-type]\ntest.py:21: note: Following member(s) of \"str\" have conflicts:\ntest.py:21: note:     Expected:\ntest.py:21: note:         def __iter__(self) -> Iterator[int]\ntest.py:21: note:     Got:\ntest.py:21: note:         def __iter__(self) -> Iterator[str]\ntest.py:21: note:     Expected:\ntest.py:21: note:         def __iter__(self) -> Iterator[int]\ntest.py:21: note:     Got:\ntest.py:21: note:         def __iter__(self) -> Iterator[str]\nFound 2 errors in 1 file (checked 1 source file)\n\n\nLine 20 is print(function(d2)) and 21 is print(function(s)) which is correct.\n\nEdit: really? downvote because I showed it works? Or am I missing a point? What is the non-working example, because I myself didn't run into issues with Iterable.",
                        "points": "3 points",
                        "children": [
                          {
                            "comment": "Edit: really? downvote because I showed it works?\n\nNew user? No problem: you'll get used to it.\n\nTo answer your question, you're using Iterable[int] while the other user is probably using Iterable.\n\nAlso, referring to the other user's fix, I don't see the point in adding an isinstance(obj, (list, tuple, set)) check when one can replace Iterable with list | tuple | set.",
                            "points": "2 points",
                            "children": [
                              {
                                "comment": "To answer your question, you're using Iterable[int] while the other user is probably using Iterable\n\nOk but then if you type Iterable you're essentially typing Iterable[Any] so why being surprised that suddenly a string can be passed? It matches Iterable[Any].\n\nAlso, referring to the other user's fix, I don't see the point in adding an isinstance(obj, (list, tuple, set)) check when one can replace Iterable with list | tuple | set.\n\nYeah, type checker will enforce whatever you tell it to enforce. Unfortunately, Any has special meaning, that also means \"suppress type errors\". It is meant for dynamic parts of code, that one can't express using the type system. The goal should be to minimize use of Any. There are options enabled in --strict mode that warn about using Any.",
                                "points": "4 points",
                                "children": [
                                  {
                                    "comment": "Ok but then if you type Iterable you're essentially typing Iterable[Any] so why being surprised that suddenly a string can be passed? It matches Iterable[Any].\n\nPeople can be wrong, you know :)",
                                    "points": "1 point",
                                    "children": [],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "That's not my experience. Majority of libraries that I was using are actually typed or have stubs, and the typing for stdlib is in typeshed.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I haven‚Äôt tried typed Python. I generally don‚Äôt like working with untyped languages, so that may turn me around on Python.",
            "points": "5 points",
            "children": [
              {
                "comment": "typed python isnt fantastic. its type system has a clunky syntax. it does the job and i always use typed python over untyped python, but i would have liked more things reminiscent of typescript",
                "points": "9 points",
                "children": [
                  {
                    "comment": "I think your problem is that you're familiar with typescript and not so much type annotations in python.",
                    "points": "1 point",
                    "children": [
                      {
                        "comment": "",
                        "points": "",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Regular python is strongly, dynamically typed.\n\nStrong typing means that the type of a value doesn't change in unexpected ways. A string containing only digits doesn't magically become a number, as may happen in Perl. Every change of type requires an explicit conversion.\n\nDynamic typing means that runtime objects (values) have a type, as opposed to static typing where variables have a type.\n\nC++ is weakly, statically typed as you can assign an int to a char for example as everything is all just binary at the end of the day!\n\nint main() {\n  int i = 0;\n  void *v = &i;\n  char *c = v;\n  return *c;\n}\n\n\nEveryone of these threads we always have people confusing static declaration with typed.",
            "points": "10 points",
            "children": [
              {
                "comment": "",
                "points": "",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I prefer my python written in cursive. (/s)",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "That's why I don't use python",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I love typing pythong",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Exactly. Typed python is actually quite good programming language. And really enjoyable.\n\nI actually have also Go, and frankly I rally don't enjoy it, it forces me to do a quite ugly code.\n\nSupposedly one of its selling points is that it is simple so the resulting code is simple too, but for anyone saying that I can show the ugly and hard to follow code I have to work with. I think Go failed to deliver what it was promising.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "",
            "points": "",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "As someone who has been a python dev for 4 years: it helps you build something that provides business value from data quickly.\n\nNot saying it will be the most robust in the long term, nor enable good habits in the process of building a product in all cases... But it lets you go from nothing to something usable that gets you value from data you already have in \"no time\". And using a \"developer\" who is a bit less experienced or even comes from a non dev background.\n\nAll other reasons are trumped by this imo, although this ultimately feeds back into lot of them. The momentum of the language (ongoing support of open source libraries, language improvements) is provided by hundreds of companies out there finding fast and valuable usage of it.\n\nCompanies don't care that it's interpreted. They don't care about the GIL. They don't care that environment management and deployment can be a pain. (Until you are.5 years into the project and hit issues with these things lol) Because ultimately it gets a data oriented products out the door and in a useable state with less effort than anything else. And that means $$$",
        "points": "65 points",
        "children": [
          {
            "comment": "Python is amazing for standing up MVPs and Proof of Concepts.\n\nAnd even better, it provides support for you to re-write important parts of your product with languages better suited for things like memory safety and execution efficiency if that's what's bottlenecking you.\n\nPython is a great language because it's like Duct Tape. It's useful in almost every situation you can find yourself in even if it's not always the best tool for the job, and it's good enough to hold the fucking world together if that's what you need it to do.",
            "points": "17 points",
            "children": [
              {
                "comment": "Python is also amazing for that weird space in between shell scripting and reaching for something like Go.\n\nWhen grep/sed/awk wizardry starts to become a bit unreadable is when I start going ‚Äúyep, python‚Äù ‚Äî it‚Äôs a bad habit, but it really gets me to churn out stuff fast.\n\nLove my little scripts that do something quickly & neatly. Sometimes all you need for an MVP is to unmarshall something and turn it into a readable format.\n\nI don‚Äôt like using it for anything beyond that though.",
                "points": "6 points",
                "children": [
                  {
                    "comment": "Yeah, it occupies a kind of \"advanced shell\" position that used to be Perl's domain, except it's a lot more pleasant over time. It has more positions too, but I find the stuff I'm willing to do in shell scripts these days is limited to ‚Ä¶ half a screen of lines or so?\n\nLike it's a good trowel, if shell is just digging with your hands. There are bigger shovels and excavators available, but sometimes all you need is a garden trowel.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "",
                "points": "",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "This. It‚Äôs all about how fast can you create value.",
            "points": "27 points",
            "children": [
              {
                "comment": "100% even if it‚Äôs if slow process slap a cron job or task scheduler to move data once at day at 3am. Pythons avantage IMO is that value your talking about that can be added in a day.¬†\n\nAnd you can clean, parse transform data sooo much easier in python. Even complicated sqls easy to call",
                "points": "14 points",
                "children": [
                  {
                    "comment": "I didn't see the value of Python until I used Polars. It's wicked easy to manipulate huge amounts of data. It's still garbage from a multiprocessing and threading perspective.",
                    "points": "7 points",
                    "children": [
                      {
                        "comment": "It's still garbage from a multiprocessing and threading perspective.\n\nAgreed. But 95% of business applications don't need threading. And things that do tend to be written in low-level compiled languages like C/C++, Rust, or Go.\n\nHonestly, the computing power we have for general tasks is thousands of time faster than we actually need. Most managers aren't going to care if your program executes in 50 ms vs. 2 seconds, even though the former is 40 times faster than the latter. And frankly for the majority of tasks you aren't going to get a factor that large or have execution times as long as either of those things.\n\nAs a practical matter, I have some scripts that perform actions on our servers by searching through a bunch of files, combining them into MP3's based on a CSV data output, and then sends the audio to an SFTP. I wrote the whole thing in Python in 3 days.\n\nCould I have written it in Rust or C++? Yeah, sure. I could have used parallel processing and maybe made it run in 30 seconds instead of the 1-2 minutes it currently takes. But it's a passive script that runs once a day in the middle of the night and the majority of the processing time is spent transferring files to the remote server, which isn't any faster in Rust compared to Python.\n\nCould I have written it in Rust in 3 days?\n\nNo. And at the end of the day, my boss pays me by the hour, and isn't going to be happy if I take 3 weeks on something they want done as soon as possible.",
                        "points": "12 points",
                        "children": [
                          {
                            "comment": "We used multiprocessing all the time in our production environment all the time generally to load a ton of entities from our dynamodb. I feel like I can write Python just a tiny bit faster than c# but c# offers a much better multiprocessing piepline out of the box.",
                            "points": "1 point",
                            "children": [
                              {
                                "comment": "Anything with a GUI tends to be pretty heavily multi threaded, too. Especially if it's customer facing and not a purely internal tool.",
                                "points": "0 points",
                                "children": [
                                  {
                                    "comment": "Those generally use threading for concurrency. That works fine in Python.",
                                    "points": "0 points",
                                    "children": [],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "It's an accessible language which means there are a lot of people who will be able to pick it up and be effective with it. That also means that if you have an issue, another person would have posted it somewhere on the internet.\n\nOn top of that, it's quite straightforward to get something running. You don't have to learn why you cannot have an unused variable when you're building your app -- python doesn't even have a compile step since it's interpreted.\n\nGoing 0 to 1, python will be better than a lot of languages. Going from 1 to 2, if you're on python, you'll keep it in order to continue forward momentum.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I guess there are network effects combined with a very gradual learning curve. It's popular, people build libraries, tutorials etc. This in turn makes it even more popular.",
        "points": "11 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "it‚Äôs widely available by default\nscripting and easy prototyping\nvast amount of libraries across almost every field\nreads like a human language\n\nperformance..shmornance.. write that stuff in C and give me Python bindings to it.",
        "points": "13 points",
        "children": [
          {
            "comment": "write that stuff in C and give me Python bindings to it.\n\nYeah, so now your code dependencies are system dependencies instead. Brilliant!",
            "points": "-5 points",
            "children": [
              {
                "comment": "it's not actually a problem, it's just annoying once in a while",
                "points": "4 points",
                "children": [
                  {
                    "comment": "yep, our team was tasked to take over a legacy python project without any tests and any sort of documentation available, and it's using an old dependency that can't compile on any of our machines so we had to update the dependency and hope the code still works.",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "Dockerizing legacy apps is the first step.\n\nI know the pain, supporting an app requiring pre-Heartbleed SSL libraries. It has to run on a docker container running an old linux distro.",
                        "points": "1 point",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "You can write them in Rust as well.\n\nNow we're back to code dependencies.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Python is popular for two reasons. First, of course, it is easy and interpreted and has some decent tools to work with.\n\nBut the second is the insane number of packages written for it. When you can find something to do anything you want, you lean in that direction. Java has lots of libraries but they are either commercial or annoying or both",
        "points": "35 points",
        "children": [
          {
            "comment": "I always thought motto that \"Python has batteries included\" was really fitting.",
            "points": "8 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "the insane number of packages written for it\n\nYeah! Like PySci. Oh wait, that‚Äôs just wrappers around C++ code\n\nOr I guess more like PyTorch. Oh wait, that‚Äôs also wrappers around C++ code.\n\nI think I see a pattern developing here.",
            "points": "2 points",
            "children": [
              {
                "comment": "Sure. Learn C++. I did, back in the 80s. I still work in Python. Because, honestly, its quicker and easier. And when I want to do \"serious\" work, I write it in C++ and call it from Python.\n\nTo be fair, I feel the same way about C#.",
                "points": "24 points",
                "children": [
                  {
                    "comment": "",
                    "points": "",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Is there a standard C++ package manager where users can easily install those libraries?",
                "points": "10 points",
                "children": [
                  {
                    "comment": "No. Integrating other people's code in C++ is often times a huge pain that might very well involve setting up a separate build system just for that dependency",
                    "points": "8 points",
                    "children": [
                      {
                        "comment": "",
                        "points": "",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "Maybe.\n\nI hear it has a name, but its commands are unpronounceable, and therefore unusable unless you have at least 13 mouthes, breathe sulfur, and deal in souls.\n\nI love the ideas of C and C++...but JFC do I hate how aggressively the language maintaners seem to plot out a route to modernity, about face, and then run as fast as they can in the opposite direction sometimes.\n\nI shouldn't need to set environment variables to compile against the SFML. Not when it's competition in a language like Python, Ruby, node, or even fucking Rust is as simple as \"pip install pygame\" and doesn't install anything for all system users.",
                    "points": "1 point",
                    "children": [
                      {
                        "comment": "My critique of Python (and all other scripting languages) is that you have to rely on native libraries when you have to do anything performant. This is in contrast to JVM / CLR languages, which can accomplish almost everything that you can do with C++.",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "A standard package management format is being developed (called CPS).\n\nHowever xmake already exists (it's a build system/package manager in one) which is easy to use and it works with the ecosystem (including CMake). Something doesn't need to be standard for people to choose to use it.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "Honestly, the easiest way I've found is Bazel-ifying everything. Huge pain in the ass at first, but I got the hang of it eventually, and don't really want to use C++ any other way now. A lot of libraries are actually pretty simple to Bazel-ify, and the most popular big ones are already Bazel-ified.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "",
                    "points": "",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "the wrappers exist though and that's more than can be said about many languages, why do devs get so hung up on the technical details and miss the important part, which is getting shit done?",
                "points": "3 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "Just because those libraries utilize C++ does not imply the same capabilities exist in C++. You surely know that though, so what‚Äôs your argument? That you wish these data science libraries were just written in and available for C++ to begin with? We just don‚Äôt live in that world but it‚Äôs an interesting thought experiment to wonder if ML/AI would have taken off so fast of written in C++.\n\nThe ease of python makes it a lot more transferrable between developers and disciplines. One of ML/AI‚Äôs great promises is its applicability to any disciplines, where we can utilize all of the crazy data we have on anything now. Except all the engineers and scientists in disciplines outside of CS/SWE don‚Äôt know C++ and never will. They learn python at best, so we come back to the start.",
                "points": "2 points",
                "children": [
                  {
                    "comment": "I mean, that's pretty much the cause of Python's popularity, because once PySci came out, and everyone in the physics and engineering communities figured out that it was way better than Matlab. Which wasn't really the highest bar to cross. Then came along the first generations of AI scientists, who again, were scientists, not SWEs. At least, most of them. Of course, there's the core contingent of brilliant computer scientists who wrote the underlying C++ libs like Tensorflow etc.\n\nBut the question of whether the language does useful things for smart people is a separate question from the question of whether the language is good. By analogy, genius musicians can have shitty technique and still make great music. But that, likewise, doesn't make those musicians authorities on what techniques are best.\n\nJava and C# and C/C++ have stood the test of time for a reason. I believe Rust will also. I don't see the same future for Python.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "The difference is the package manager making it so you can trivially add it to your project and it \"just works\" as opposed to the C++ version where you'll have to figure out how their build system works, resolve issues with your chosen compiler, figure out dependencies yourself...",
                "points": "0 points",
                "children": [
                  {
                    "comment": "The difference is the package manager making it so you can trivially add it to your project and it \"just works\"\n\nIt doesn't \"just work\" 10 years later, which is at the heart of my critique of trying to accomplish serious work by using a scripting language to call native code.",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "Can you be more specific? I‚Äôve written plenty of wrappers over the past decade for c/c++/rust libs",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "I think that's the proper way to use Python: need something to show first? then use Python; need performance later for some loops, or making Python fast in some of your code is impossble? delegate to C++ or Rust or whatever, and it is quite easy to do so e.g. pybind11, as opposed to something like JNI.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "And both of those contribute to usage but not necessarily usefulness.\n\nThere‚Äôs still many people I know who program in VB because they consider it easy to understand and ‚ÄúI can use it in excel!‚Äù Which basically means they only learned programming through excel scripting. Meanwhile VB is one of the worst languages to ever exist.\n\nPython is great at many things but an insane amount of people use it for everything under the sun because it‚Äôs taught in a lot of non-programming fields such as engineering, sciences, finance, and statistics.\n\nIt‚Äôs the old adage of ‚Äúwhen all you have is a hammer‚Ä¶‚Äù",
            "points": "0 points",
            "children": [
              {
                "comment": "What a great comparison. Let me show you this. VB does have option strict.\n\nI don't know if it could be one of the worst languages ever. It's oo. It has try/catch which should have gotten rid of the dreaded gotos. It could be worse.\n\nThe language itself has been around since the 60s. I also think you may be equating the limited version of vba to the actual vb.\n\nI don't think it much matters, though, since most people are moving away from it to other languages, so I'm not sure you'll have to deal with it much longer. I haven't seen anything vb for a while, just vba in Excel, like you mentioned. If I never see another goto in my life, I'll be fine.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "Granted. This was certainly true of VB. or Basic in general. But that's not always a bad thing.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I'd argue Java libs are of a higher average quality, though. Even the non-commercial ones. Because Java is used for software engineering/industrial software creation mostly, while Python is also used in adjacent fields like data science, scripting, etc.",
            "points": "0 points",
            "children": [
              {
                "comment": "Maybe. I'm not sure that's true, having worked with both. Non-commercial open source is quite often as good as, if not better, than commercial stuff.",
                "points": "0 points",
                "children": [
                  {
                    "comment": "",
                    "points": "",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "But it's not. It's JavaScript",
        "points": "10 points",
        "children": [
          {
            "comment": "Doubt it's even close tbh",
            "points": "5 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I read this and my first thought was no fucking chance lol. Not even going to dignify this by looking it up.",
            "points": "0 points",
            "children": [
              {
                "comment": "My statement or the original statement?",
                "points": "1 point",
                "children": [
                  {
                    "comment": "Original statement, there‚Äôs no way python is more popular than JavaScript",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "It is Javascript.\n\nI have never met anyone who is a full time Python programmer. In the last 5 years I met people who still use VB6 profesionally, use Free Pascal full time, use D, Haskell, etc. but never Python. I'm not sure why. You would think I would meet someone who use Django, nope.\n\nI have met those who \"use\" it, either writing little bits of Python or requires them to install it. That's it. Javascript however, man, it is all over the place.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Answer: It‚Äôs really easy to learn and it can do alot of things.",
        "points": "21 points",
        "children": [
          {
            "comment": "Me as a total noob learning python: üåû\n\nMe as a Python developer with 3 years of experience learning Java: ü§°üëøü§°üëø\n\nIt‚Äôs a joke. But only a little bit.\n\nAnd at this point there is an (over) abundance of Python educational material.",
            "points": "7 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I dunno, I guess it just snakes its way into people‚Äôs hearts",
        "points": "3 points",
        "children": [
          {
            "comment": "ü§¶‚Äç‚ôÇÔ∏è",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I see what you--ah #$%@ it.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "modern python is fantastic. i remember being a freshman (wow 7 years ago) thinking what the fk is this mess of a javascript-bash homuncule language, modern tooling with type annotations, type hinting, close C interoperability, wide adoption, sensible package management, reasonable performance‚Ä¶ it‚Äôs a fly wheel at this point, the good only keeps getting better and the what remains of the bad stuff has been accepted as a quirk of the language‚Ä¶ what i don‚Äôt get is why anyone adopted python originally‚Ä¶ oh yeah, cause nothing says ‚Äúholy shit, lunch time already?‚Äù like finding out that your missing a bash script required for part of your build pipeline that you didn‚Äôt know existed in to being with",
        "points": "4 points",
        "children": [
          {
            "comment": "",
            "points": "",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "The gap between Python and the rest has never been that large\n\nI think it's common knowledge that Python remains popular, and will continue to for years to come. Interesting that Go was added to the top ten this year though.\n\nWorth highlighting that Stack Overflow's dev survey - referenced here - gives a bit better context on the popularity of languages in a professional context.",
        "points": "37 points",
        "children": [
          {
            "comment": "Interpreted languages are super easy to learn, relatively easy to debug, and the code is highly portable.\n\nMost people forget that many times in tech you come across a problem where you have x thing to accomplish where performance doesn't matter all. Files need to be inspected for changes and moved from x to y once per day, some infra tools need a command line interface, etc., etc. Why not use the easiest option?\n\nAdd in the utterly massive number of python packages and, well...",
            "points": "58 points",
            "children": [
              {
                "comment": "Programming performance is a little bit like relativity. It only really comes into play at scale. Like when something gets really big or really fast.",
                "points": "29 points",
                "children": [
                  {
                    "comment": "Or really constrained. As soon as you start dealing with mobile devices, (semi) embedded, or low-end hardware performance can be, and usually is, very important.",
                    "points": "7 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "That's a great metaphor and I'll steal it.",
                    "points": "2 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "And even then Python offers ways for you to re-tool the parts of your product that really matter since python can integrate with any C, C++, or Rust DLL.\n\nSOP in a lot of bigger companies like Google is to write your first version in Python, profile the shit out of it, and then re-write your time-sinks in C (and now Rust) for efficiency. This allows you to essentially go into the re-write with all of your difficult logical problems already solved. So all you have to do is look for places to increase efficiency.\n\nInstead of having to solve 3-4 problems at once, you only have to solve one.",
                    "points": "2 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "Still it's better to use the right algorithm in a slower interpreted language than the wrong algorithm in a fast compiled one.\n\nIt's easy to end up doing something that work fine on noddy dev data but suddenly takes 4 hours on a customer data set, have seen that many times. Making it ten times fast is still not enough. E.g. nested looping two large lists for finding correlations is iirc O n2",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "people are so hung up on single-box performance and it doesn't make any sense to me, you have to build for horizontal scaling for anything with significant money involved and compute is way cheaper than developer time",
                "points": "0 points",
                "children": [
                  {
                    "comment": "With horizontal scaling single box performance still matters. An algorithm that runs in half the time costs half as much when you‚Äôre getting charged per cpu‚Ä¢second. Or for fixed instances if you handle requests in half the time you‚Äôve doubled your load capacity.",
                    "points": "1 point",
                    "children": [
                      {
                        "comment": "it really doesn't because development, data ingress/egress costs, database admin, etc etc etc are going to be 99% of your cost. unless your business model has an unbounded need for processing directly limiting revenue the performance of a given language is totally irrelevant at the business level. it's a lever that is very salient to developers but it's not material for the vast majority of businesses until they're at huge scale. Github is still running some amount of Ruby even with the resources of Microsoft at hand, that should be the last word on how relevant language performance is to a business",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "For me, the answer is simple: I feel more productive in python. I find it easy to read, easy to reason about, and easy to write.\n\nThis is not to say someone can't write a plate of spaghetti in python--that's possible in any language. But generally speaking, I spend less time wrestling with the language, and more time getting actual work done.",
        "points": "15 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Python is the new BASIC. Except it's a reasonably well designed language. It has a big useful standard library, and a glut of third party libraries to do just about anything. Where speed is an issue, many libraries have successfully worked around Python's weak performance by moving functionality into C.\n\nThe BASIC comparison comes from Python being a great language for teaching/learning. The simple syntax does a decent job of getting out of a new programmer's way. The meaningful whitespace trains new developers to indent properly. And he language itself can be used to teach numerous programming styles where most languages are more opinionated; Procedural, OOP, and functional are all perfectly reasonable, even where many languages make switching between them difficult.\n\nIt's the perfect lowest common denominator of programming languages, and while that's often used as an insult, here it's a tremendous boon.",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I think Python is popular because it focuses on usability rather than on efficiency. When I first came to Python from C++ I was shocked by the nonchalance with which Python programmers create arrays, sets, and dicts just to improve readability. No old-school C++ programmer would ever do that.\n\nNow that I've been corrupted by Python I don't want to go back to early optimize everything I write. When Python is not enough, I just reimplement the slowest parts in Rust.",
        "points": "2 points",
        "children": [
          {
            "comment": "Yup",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Its just easiest language to learn so it has the widest range of people knowing and i bet a nice percentage of people that like it know only it (not like 50% but still a nice portion)\n\nAnd I agree it's nicer on the eyes",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "My $0.02 is that it‚Äôs the new Visual Basic on steroids. Easy to learn, friendly syntax, cross platform, and anything computationally heavy is a package written in another language that is easily accessed.\n\nI don‚Äôt use the VB comparison to slight it, suppose it just depends on your views on VB üòú",
        "points": "6 points",
        "children": [
          {
            "comment": "VB is/was a blight. As someone who has worked in VB and now works in python the difference is so night and day it's funny.\n\nVB sucks.",
            "points": "5 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "VB was a tasty lump of cat puke. Do not compare Python with it.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Because basically all ML development uses python toolchains. How is this mysterious?",
        "points": "6 points",
        "children": [
          {
            "comment": "",
            "points": "",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Lowest common denominator.\n\nI expect to get downvoted, but it's true. The language simply does not have the fundamentals needed to write good software. Type checking is awful. There are no private members for classes. The PEP is full of community-enforced style requirements that seek to help alleviate these issues rather than just improve the language. And anyone who brings up these issues is downvoted and talked down to and essentially told to \"git gud\", when the reality is that Python is most popular among developers who wouldn't know what to do with advanced features even if the language had it.\n\nI've repeatedly found in my career that there is very real value in building rigid systems that are quick to throw errors when you deviate from what's expected. Where you have to declare your intentions up front, and then follow through. Yes, sometimes these languages are \"slower\" to develop, since you have to have a very good understanding of what you will be doing before you do it, and yes, sometimes it takes longer to make changes in these systems. But it also results in a better product. Besides, I've found that any (development time) \"speed\" you think you're getting through an easy-to-write language like javascript or python is going to be lost on the tail end as you put an increasing amount of effort into tracking down and fixing bugs, or trying to figure out why your API call is failing and the only error message you're getting is \"no data\".\n\nAlso, it's very explicitly not the most popular language. Don't believe everything you read online.",
        "points": "11 points",
        "children": [
          {
            "comment": "I love Java too :)",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "\"I have a problem!\"\n\"Use Python!\"\n\"Now I have two problems!\"\n\nWhere I work, they throw Python around everywhere, and now it's a mess of badly designed Python code when other languages would have been more suitable and maintainable.",
        "points": "5 points",
        "children": [
          {
            "comment": "Where I work, they throw Python around everywhere, and now it's a mess of badly designed Python code when other languages would have been more suitable and maintainable.\n\nSounds more like\n\n\"I have 514 Problems\"\n\"Use Python for every one of those!\"\n\"Now I have 29 Problems, 18 of which are Python\"",
            "points": "6 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "every language that is widely used will have this problem, tons of people know just enough to get by so they will make a bit of a mess but the upside is that someone else on the team probably knows how to clean it up and you can't say that about whatever language would be perfectly suited for any given task",
            "points": "0 points",
            "children": [
              {
                "comment": "every language that is widely used will have this problem\n\n\"There are two types of programming language: the ones that everybody complains about, and the ones that nobody uses.\" - somebody famous probably",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "because it's fucking easy, saved you a click",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Its got a cool name. That's the real answer.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Why does Python have widespread appeal? High level, dynamic typing, strong libs for web services, data science, and ML. Tons of learning materials. It's not a mystery. I really dislike it but it's a very solid choice if you're only going to learn one language",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "this shit is irrelevant, of course using programming language mostly because the community and library\n\nI mean python got it so popular because numpy scipy pandas and such\n\nand none on par with it even in R",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "simplest write code once language for non-software engineers",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "My guess is Python is getting a huge bump with the recent interest in all things AI and ML.\n\nPython is almost the lingua franca of that sort of stuff at this point.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Because it is simple and effective.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Python is slow and packages suck",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I find that developers whom talk a lot of shit about python, do just that, a lot more talking than they do developing. Python produces tremendous value incredibly quickly and in a memory safe way.\n\nIt's most real glaring weakness is its dependency management. If you're worth your salt as a programmer, you should only be really using PSF packages and rolling your own anyways because python makes it so easy to produce code quickly.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Am I the only person to hate python?\n\nFor one, it's not actually an easy language. It has a ton of features, a lot of which don't really work great together. It also has a lot of annoying behaviour, where some methods mutate variables and perform IO, while returning None, while others also do side effects but do return and finally methods that don't do side effects and return new values. Other languages do the same like Go, Java, etc, but I think python is probably the worst because it's not typed.\n\nThe type system in python is bad. It's not as bad as javascript, because at least conversions are more explicit but it's still a nightmare. I know you can use typing but that doesn't do much except give hints, which are sometimes irrelevant. Typescript does more then types python and it still can't fix javascript. The object oriented stuff is weird. Since you don't have types, interfaces become irrelevant but that's kind of the biggest appeal for oop. Not having algebraic types sucks, there are duck tape solutions but they just don't feel that good to use.\n\nPython is a bad scripting language. The language is huge, you can't really embed it inside another app. The way it handles file and database IO is questionable. The way it handles permissions is also questionable. I would rather use lua.\n\nManaging dependancies is impossible. If you're starting a big long term project, using virtually environments is not enough. Those are for bigger scripts you might have. You have to use docker instead in my opinion. In other languages I've never felt like I \"need\" to use docker, especially if I don't have a database server or some program dependancy. With python, getting your environment corrupted is just part of the experience.\n\nPython is slow. Being interpreted is a disadvantage for building apps. Say I want to build a server in python. There's a rule I like to follow where if making a database call is more expensive then waiting for the database, there's something seriously wrong. Poor performance can lead to bad user interaction and higher expenses. Also, it's nice to be able to give out a binary file sometime, instead of scripts.\n\nI can see how python is good for data analysis. Using it with sqlite and you've just replaced Excel. Not bad! Anything else and you're doing something weird.",
        "points": "1 point",
        "children": [
          {
            "comment": "does more then types\n\nDid you mean to say \"more than\"?\nExplanation: If you didn't mean 'more than' you might have forgotten a comma.\nStatistics\nI'm a bot that corrects grammar/spelling mistakes. PM me if I'm wrong or if you have any suggestions.\nGithub\nReply STOP to this comment to stop receiving corrections.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Cause idiots like me can understand it",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "It‚Äôs pretty hard to argue the case against python. It‚Äôs easy and damn near universal.",
        "points": "6 points",
        "children": [
          {
            "comment": "it‚Äôs pretty easy to argue against all dynamically typed languages",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "My only argument against Python is that every virtue it has is done better in Ruby. I have no idea why Python is still the go-to recommendation for people who are learning to code, except that the people who are recommending it are people who also learned on Python and it just kind of self-perpetuates.\n\nThat being said, Python is certainly a decent starting point for people and there's a lot of support for it.",
            "points": "-1 points",
            "children": [
              {
                "comment": "I learned to code in c++ 20 years ago. Eventually I became and network engineer and it was the easiest, most universal language available for running against networking gear at the time. That probably helped it",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "the 'one right way to do everything' is a design choice that encourages a language to spread, 'literally infinite ways to do anything' creates obstacles for learning. Ruby having multiple aliases like fold/reduce in its std lib just to accommodate people who might have seen those fp names in other languages is one small example, it's jarring when you run into that as a newb",
                "points": "0 points",
                "children": [
                  {
                    "comment": "I‚Äôve never seen ‚Äúfold‚Äù in Ruby and can‚Äôt find it anywhere in the docs, just ‚Äúreduce.‚Äù\n\nHonestly I don‚Äôt remember aliases ever being difficult to grasp when I was learning the language‚Äîyou tend to very quickly pick a way you like doing something, and that‚Äôs that. But that‚Äôs just my experience.",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "i looked again, the alias is \"inject\", and of course aliases aren't particularly difficult in themselves but I'm using it as an example of the ruby approach that adds complexity in support of arbitrary matters of taste. When Ruby and Python were competing for mindshare all the talk about ruby was about showcasing the language's flexibility with stuff like monkeypatching and overriding operators and the question I kept hearing from learners was stuff like \"ok... but what's the recommended way to do this?\".\n\nRuby's design values aren't optimized for easy and fast adoption, and now it's all but irrelevant as a consequence",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "",
                "points": "",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Python is widespread because...\n\nIn the 1990s the number of programmers the world needs exploded from \"just Bob by himself\" to \"billions of worthless web developers\". You can't pull good experienced developers out of thin air. The world had to use bad inexperienced developers. It was a disaster.\n\nThe solution was to design new \"comfy safe lounge chair, with extremely bad performance\" scripting languages specifically for all the bad inexperienced developers; then make everyone pay orders of magnitude more for state-of-the-art hardware to cope with how slow it is while the climate changed due to the inefficiency.\n\nMost of these new languages where horrendously awful (e.g. Perl, which was developed by an oyster coating an irritant in secretions). Python rose to the top mostly because the syntax wasn't as bad as \"horrendously awful\", and because lots of people wrote native libraries written in efficient languages to make the performance of \"gluing together things real programmers wrote\" suck less, and because it started being taught by universities (who still refuse to admit that their curriculums' control the industry more than industry controls their curriculums).",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "This entire article could have been a single table",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Because I can use it to turn out some infrastructure automation in a couple of days, and produce a ReST API in under a week.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Its has appeal because it's taught to students.\n\nThe End.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Easy copypasta",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Great tools that support it, like jupyter notebook. Amazing debugger. And great integration with ide. No one else has that!",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Tooling sucks",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Not compiled, weak typing, plug and play code libraries with pip\n\nUniversities love it, and have really changed programming from programming into connect the Python code fragments together that we give you\n\nEdit: I remember thinking during an assembly language course, why write assembly if every function call is a C API?\n\nPython goes the other way, why write in performant language if all you do is call various C/C++ libraries and glue together the outputs",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "AI and Machine learning that's why. Somebody ported the C libraries to python first and all the examples and documents were written in python afterwards.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Free IDE. Support libraries from enormous worldwide communities and most academic libraries for scientific analysis are made in Python. Easy syntax. No compiling into complex packaging. No overhead in methods with unnecessary syntax. Extreme cross platform usability. Run it from anywhere. No need to install thousands of resources just to run some code. No registering needed.\n\nNeed something done? Write it in Python and execute it anywhere. Done.\n\nCoding was never about big companies earning thousands of dollars from you in licenses and software. It was always about the ease of use and accessibility.\n\nI do most of my Python coding from my Android phone when I have 5 minutes to spend at the airport before my flight while drinking a nice hot cup of cappuccino.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "TIOBE represents the number of search results for any given language.\n\nThat means the languages with the most articles or tutorials wins.\n\nThat means that languages popular with beginners are highly overrepresented.\n\nNobody in industry really thinks Python is most popular language, it clearly isn't.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Because it fits the bill for lot of tasks that need to get done. For example when I need to do some data manipulation or generation that only needs to work once ever, would I start a project in any other language? I would rather not. But whipping out a jupyter notebook for it is perfect for such tasks. In many ways python works great as an excel++ and that gives it a ton of everyday utility.\n\nOf course it does have it's downsides too and many of them. Python kind of sucks for anything that needs to be distributable. It's very meh at GUIs. If you have to do a lot of computation in actual python rather than offloading it all to dependencies, it's not particularly performant. Less said about threading the better...",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "answer: it's easy",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "My take is that the majority of devs are fine with writing below decent garbage as long as \"it outputs the right thing\", thus not wanting to put in more effort than the minimum.\n\nI literally had to explain how fetching the data with SQLAlchemy, filtering it IN PYTHON, then RETURNING IT as a list argument for further processing was not by any means acceptable. The response time for a single query REST API endpoint was 5+ seconds. After that I not only grew to hate the community but the language too.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Python is the language of choice of people who need to write code, but don't know how to code or want to learn beyond their specific requirements. Most notably mathematicians and scientists m\n\nSome of this is because of features it has, but a lot of it is the pure inertia of the belief that it's the right tool for this.\n\nIt's not a terrible language, but if you need language features that don't fall under the umbrella of ease of access for highly educated non developers it's probably not a great choice.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "To me it‚Äôs an aspect of the way the world as a whole has moved backwards away from civilization towards ‚ÄúIdiocracy.‚Äù\n\nPython was not a very good language when it was created. There were more capable, more self-documenting, more performant, less error-prone, etc. languages. On any distinguishing characteristic there were better ideas for how to do a programming language than Python. And numerous examples of such languages: various BASICS, various LISPs, etc.\n\nSince then, numerous languages have been released that seek to provide a better solution to the problems at hand than Python: C#, Rust, Julia. All-in-all, these languages are typically described as ‚Äútoo‚Äù sophisticated: ‚ÄúYou talk like a fg and your shit‚Äôs r‚Äù to use the Idiocracy quote. The idea that someone could more reasonably seek out a language that helps them write better code than seeking out the worst common denominator is seen as effete pretense.\n\nAnd as we see a decline in society‚Äôs tolerance of any principle, there is a decline in the support for the idea that languages should be performant, self documenting, protect you from making mistakes, etc. The idea is that the world is chaos and by presuming to mess with that, we are overstepping our jurisdiction as humans. It‚Äôs the same principle as antivax, anti-regulation, etc. By believing that progress is possible, by working toward progress, you are somehow suspicious or nefarious.\n\nOf course the logical extension of that is the premise that ‚ÄúAI‚Äù (which doesn‚Äôt really exist) can simply write your programs for you. And then it doesn‚Äôt matter what language you use, and any mistakes in the program are not decipherable, since you don‚Äôt know how to program. And the idea that program could be constructed a priori to always produce the correct result is inconceivable to such people, and almost sinful.\n\nOf course this is also an aspect of the Agile/Scrum Taylorisation of software development as a profession: degrading the role of a developer into a cog, a button-pusher, whatever. By denying the premise that there is some creative or mental work happening on the part of the developer, he is turned into a simple day (or day-and-night) laborer. ‚ÄúChatGPT/Copilot/etc could do this for you,‚Äù so no need to think, no need to know.\n\nIf your software makes mistakes, that is unavoidable in an anti-progress mindset, just like the barbarians who now run Boeing have successfully brought us back into a world where aviation safety can‚Äôt be taken for granted by the public. But who could have believed aviation could be safe? It is not in the human being‚Äôs purview to decide questions of death and life. Just so, when the inevitable happens and a bug mindlessly copied from ChatGPT kills someone, we will shrug and say, at least the code was Pythonic!",
        "points": "-11 points",
        "children": [
          {
            "comment": "Did you have this prepared beforehand?",
            "points": "5 points",
            "children": [
              {
                "comment": "Let‚Äôs just say a few things have been eating at me.",
                "points": "0 points",
                "children": [
                  {
                    "comment": "Well, I agree with a lot of it, I think the formatting was funny to me, which is probably why you were getting down voted.\n\nIt kinda has that \"sir, this is a Wendy's\" vibe\n\nAll the best!",
                    "points": "2 points",
                    "children": [
                      {
                        "comment": "",
                        "points": "",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "take one dev who knows rust and julia and another of equal skill who knows javascript and python and see whose startup runs out of money before it ships, i know where I'm placing my bets",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "",
        "points": "",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bisnid",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://github.com/jointhealliance/start-here",
    "title": "Open source Alliance : Accelerating Human Progress Through AI",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1bishoh",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://github.com/hathibelagal-dev/arpnc",
    "title": "I created a reverse polish notation programming language after falling in love with old HP calculators",
    "points": null,
    "comments": [
      {
        "comment": "https://forth-standard.org/",
        "points": "5 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "It's called PostScript. Been around a very long time.",
        "points": "4 points",
        "children": [
          {
            "comment": "Forth even longer.",
            "points": "8 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I was deeply in love with RPN in high school, loving my HP calculators, feeling so smug because I felt I had an edge over my school mates who were using... gasp, parentheses.\n\nBut here is the dirty secret about this part:\n\nwhile still requiring fewer keystrokes compared to the infix notation.\n\nThe reason why RPN calculators require fewer keystrokes is because they are asking YOU to do extra work.\n\nSure, you don't need parentheses, but that's because the calculator is forcing you to parse that complex nested expression, find out the innermost one, push that one on the stack, and then walk your way out, little by little.\n\nThere is no free lunch. Either you type fewer keystrokes and you think more, or you type more keystrokes, but you think less.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "https://linux.die.net/man/1/dc",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I'd always look up who I'm interviewing with before I show up. If they were in the industry for a bit, I'd bring my old RPN HP and use that for interview questions (non-software engineering) and we'd always end up talking about how great it was.\n\nbut on my first day of work I'd always be using a TI-89 for daily tasks.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "... something something...lex & yacc...",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bir8mq",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://youtu.be/M6lRydbukyk",
    "title": "Best development methodology",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1biqwdo",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://github.com/Dobiasd/articles/blob/master/internals_of_the_async_await_pattern_from_first_principles.md",
    "title": "Internals of the async/await pattern from first principles",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1bipces",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.jonashietala.se/blog/2024/03/19/lets_create_a_tree-sitter_grammar/",
    "title": "Let's create a Tree-sitter grammar",
    "points": null,
    "comments": [
      {
        "comment": "Amazing! I've been looking forward to a tree-sitter grammar for djot.\n\nI had written some basic scripts in lua as well as typescript to map the cursor position in a djot document to section metadata ---- from there onwards to call relevant info from, or cause 'side effects' in, the world outside the text editor.\n\nHowever the setup always ended up getting too convoluted with typescript (socket connection to a server, etc. etc.); and although both vim & neovim make it easy to work with lua, I really don't enjoy writing in that language ---- and recently I've migrated to emacs anyway. I implemented similar scripts using org-element; but org-mode syntax, in turn, is a little too busy for my taste; and 'hiding' the markup requires further error prone scripting.\n\n... so a tree-sitter grammar for djot might finally allow me to do what I want to do in emacs (which has had tree-sitter capability for a while now; and as of v. 29, it's built-in.)\n\nReally looking forward to working with this.",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bip8r9",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://webkit.org/blog/15162/introducing-natural-input-for-webxr-in-apple-vision-pro/",
    "title": "Introducing Natural Input for WebXR in Apple Vision Pro",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1bip3hv",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.phoronix.com/news/OpenJDK-Java-22-Released",
    "title": "OpenJDK Java 22 Rolls Into GA With New Features",
    "points": null,
    "comments": [
      {
        "comment": "Noob here, running Pop_OS. I've been curious to try Java and was waiting for this release to do so. Is it best practice (on Linux at least) to download the OpenJDK from the central repository? If so, how long does it usually take for Debian/Ubuntu/Pop to add it?",
        "points": "1 point",
        "children": [
          {
            "comment": "If you are using IntelliJ IDE, it can download the JDK, but I don't know if it provides 22 yet. If not, maybe you can try installing it via SDKMan.",
            "points": "2 points",
            "children": [
              {
                "comment": "I'm running VSCodium. I don't think I have any specific Java tooling set up yet other than a couple of related extensions.",
                "points": "1 point",
                "children": [
                  {
                    "comment": "Then try installing sdkman, it also allows you to install other useful things like maven, gradle, kotlin etc.",
                    "points": "1 point",
                    "children": [
                      {
                        "comment": "And if you don't want to install it, you can dowload the build from https://jdk.java.net/22/",
                        "points": "2 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Gradle toolchains is the easiest way to manage JVM versions for your actual projects. It's separate from the system Java that gradle runs under.",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "[deleted]",
            "points": "1 point",
            "children": [
              {
                "comment": "Any particular reason? Or is it just because the Arch repositories are updated the fastest?",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1biop4a",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://github.com/TheElegantCoding/astro_template_webpage",
    "title": "I made an astro template for web dev",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1biokf4",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://youtu.be/tfBKRxbCsao&list=UULPGsUtKhXsRrMvYAWm8q0bCg",
    "title": "NiceGUI For Beginners: Build An UI to Python App in 5 Minutes",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1bioj03",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://marianoguerra.org/posts/playing-with-code-programming-adjacent-games/",
    "title": "Playing with Code: Programming-Adjacent Games",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1bioer6",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://buttondown.email/hillelwayne/archive/what-if-the-spec-doesnt-match-the-code/",
    "title": "What if the spec doesn't match the code?",
    "points": null,
    "comments": [
      {
        "comment": "Then the code is wrong. (Ok, the spec could be wrong, but that should be adjudicated prior to implementation by asking questions and then revising the spec.)",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Then the code gets changed.\n\nIf you want the software to work differently, update the spec first.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1binnvg",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://locust.io/",
    "title": "Experience With Locust? What Programs Do You Use For Load Tests?",
    "points": null,
    "comments": [
      {
        "comment": "I used Locust about 4 years ago when I inherited an e-commerce app with some very serious performance issues.\n\nI found it easy to get up and running, and was helpful for checking that the changes we were making did actually improve the performance.",
        "points": "1 point",
        "children": [
          {
            "comment": "Thank you for the info. Did you used it in an autmated setup? I see they have a headlessmode where you can run the tests via a CLI.",
            "points": "0 points",
            "children": [
              {
                "comment": "I don't think we ever did. I think it was just manually run while devs were working on specific areas. But based on the manual part, I'm sure the CI/CD part is great.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I use a terraform deployment based on this repo: https://github.com/neilli-sable/locust_fargate",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Hey everyone,\n\nwhat is your expirience with Locust?\nPro's and Con's. What services do you utilize for Load Tests?\nWe want to use them in a automated environment like a pipeline.\n\nCheers Mr_LA",
        "points": "-1 points",
        "children": [
          {
            "comment": "I've used it years ago, it uses async requests so you can simulate lots of users on a single node. But at the time it did so by monkey patching the requests library via gevent.\n\nThese days there is are native async http libraries like aiohttp. Anyway my guess is locust still does the monkey patch method, but I'd have to check it.\n\nIt is possible to cluster Locust nodes, but I didn't go there myself.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bin3tz",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://medium.com/renaissance-learning-r-d/process-is-a-cost-focus-on-why-823bc7fca25b",
    "title": "Process is a Cost, Focus on Why",
    "points": null,
    "comments": [
      {
        "comment": "All too often, I see managers react to relatively minor hiccups by suggesting more process that will place a tax on all work in the future. Ideally, we would be able to calculate the relative cost of just dealing with a problem as-needed against the cost of implementing a process to reliably avoid the problem.",
        "points": "5 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bimbcl",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://github.com/ynqa/jnv",
    "title": "jnv: interactive JSON filter using jq",
    "points": null,
    "comments": [
      {
        "comment": "Looks neat, but why do I have to install through your preferred programming language's package management tool?\n\nRust is definitely the one true path to god and all that jazz, I'm sure, but that doesn't make cargo a reasonable way to distribute tools to a diverse set of users.",
        "points": "5 points",
        "children": [
          {
            "comment": "might be targeting mac only, they only have mac binaries published too\n\nin case somebody is looking for other options: https://github.com/fiatjaf/awesome-jq",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Dang this looks useful, my first question was \"can i use this with k get and the gif cleared that right up",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bim3vx",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://c3.handmade.network/blog/p/8876-a_new_site_and_v0.5.5",
    "title": "The C3 programming language reaches 0.5.5 + has a new site",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1bim2pd",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://aaronstannard.com/dotnet-eventing-backslide/",
    "title": ".NET Developers Begging for Ecosystem Destruction",
    "points": null,
    "comments": [
      {
        "comment": "kek\n\nAdding an extra messaging library to the eco system is actually removing all other messaging libraries from the eco system. Trust me guys.\n\nJust look at DI containers! Theyre all gone! Dead! Cant use em anymore.\n\nAll the logging libraries, DEAD I TELL YOU.",
        "points": "16 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "fake drama by ppl who like drama, commenting about drama 95% of .net developers aren't even involved with",
        "points": "32 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "who cares. you can use the built in implementation or a library. your choice. People still use newtonsoftjson instead of the built in one. People still use custom DI containers instead of the built in one.",
        "points": "15 points",
        "children": [
          {
            "comment": "But I like Newton Soft's implementation. :(",
            "points": "-1 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Very few communities have a Daddy Microsoft with an army of professional engineers that are building such a broad range of general purpose application libraries.\n\nTake Amazon, for example: yes, they have a lot of contributions to OSS, but most of their contributes are for their libraries related to their own products. Relatively few of their OSS projects -- compared to Microsoft -- are general purpose application libraries that have nothing to do with AWS.\n\nIt's both a boon and a bane. .NET projects tend to have very low external, third party dependencies and I'd say relatively low incidence of long-standing security issues because CVEs are continuously monitored and patched in a timely manner in first party libs and SDKs. This is great if you work in an enterprise environment where that matters. On the other hand, it also means that unless it's aligned with Microsoft's vision, it may take a long time to see features and capabilities rolled out compared to say Node where the huge community means that there's tremendous variety for everything and anything.\n\nBut that comes with its own tradeoffs. Overall, I'd say \"Por que no los dos?\" I regularly use EF Core alongside of Dapper because both have their sweet spot. Messaging I can see being a bit more exclusive, but it feels central enough to modern compute patterns that a first party offering doesn't feel wrong.",
        "points": "17 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I am a (professional) .NET developer since framework 1.1 and i gained a lot by all the tools MS put in my lap for free. That being said i absolutely do not agree with some of their choices.\n\nSome examples any my main arguments: - the entire 'builder' concept (i.e. HostBuilder) You need to google your options, not broadly supported by libraries, and you can't mix it. - asp.net DI Not transparent. Creat a method (configure) in your startup.cs and it gets magicly called. You can add parameters (if you know which) that magicly gets created. Etc. - entity framework How to do inefficient queries and keep programmers ignorant of the best language of the past 40 years (yes sql) - asp.net Mainly cause you have to have a special project instead of being able to simply add we service functionality by simply including a package. This last one annoys the hell out of me.\n\nWhy can i not create a normal console app and add asp.net dependency and say: AspServer server = new(443, 'path/to/cert.crt'); server.UseStartup(x); await server.RunAsync(cancelationToken);",
        "points": "-2 points",
        "children": [
          {
            "comment": "I mostly agree with you, but you totally can create a normal console app and add asp.net packages and manual code.\n\nMaybe you're thinking about legacy net framework 4?",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "As to your last question, you totally can. Haven't touched this since before .net 6 I take it?",
            "points": "3 points",
            "children": [
              {
                "comment": "We always work latest, so 8 now, but you have a link?",
                "points": "0 points",
                "children": [
                  {
                    "comment": "Just look at modern asp.net core 8 samples using minimal entry points.",
                    "points": "2 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Wauw downvotes.. Really encourages someone to start a decent discussion... If anyone doesn't agree.. Perhaps try counterarguments.. Or just be happy not agreeing.. It's just my opinion.",
            "points": "-4 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "One of the concerns I have with this event/messaging epic, is that it will introduce a bunch of lowest common denominator abstractions that become pervasive, forcing everyone to \"conform\" to them.\n\nIf the scope is just a nice set of client APIs to make integrating with the Azure stuff easier, that's one thing, but the title and body of the issue, makes the scope seem MUCH broader than that.\n\nI know a lot of people working with .NET like the Microsoft solution to all problems mindset, but it really isn't good for the long term health of the .NET OSS ecosystem. Microsoft literally can't do it all. So when they take over an area well serviced by OSS, it needs to be weighed against the loss of contributors and not working on areas under-serviced by OSS.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Okay, someone educate me on this one. I read a little bit through the thread and I totally don't get the drama.\n\nAs far as I understand it, MS is building a general purpose API for WebJobs. And it will have some overlapping areas (basic message handling) with existing message broker clients. But why would it replace them? Each message broker and their respective clients have some peculiarities which can't be re-produced by MS.\n\nSure, for a quick PoC you would probably use MS implementation to get messages quickly in and out. But for a real product, where you have to take advantage of the full feature-set of the message broker, you would still use the message brokers client.\n\nJust alone the forced parent POCO would deter most projects. I know it wouldn't be feasible in the projects I am working on. We often send binary data, anonymous classes or just primitive datatypes through the queues. All of which couldn't use that POCO.\n\nCall me an optimistic, but I don't see how that disrupts OSS.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bikk2o",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.infoworld.com/article/3714401/c-plus-plus-creator-rebuts-white-house-warning.html",
    "title": "C++ creator rebuts White House warning",
    "points": null,
    "comments": [
      {
        "comment": "Fair enough, but it's about more than the language itself. It's the ecosystem, and C++ has a ton of legacy dragging behind it. Rust's youth is its biggest weakness and (in this case) it's biggest strength. There are no legacy libraries to update to modern standards.\n\nFTA:\n\nOf the billions of lines of C++, few completely follow modern guidelines, and peoples‚Äô notions of which aspects of safety are important differ.\n\nBackwards compatibility means backwards compatibility with old notions of safety.",
        "points": "284 points",
        "children": [
          {
            "comment": "Backwards compatibility also causes compliancy. Upgrades cost money and if it aint broke dont fix it. Everything has this issue, but does C++ have good ways to remedy this?\n\nIt‚Äôs not like a modern JIT language where you can update the runtime and all is well.",
            "points": "48 points",
            "children": [
              {
                "comment": "Well... Upgrading the runtime seldom does something for problems of code in JIT languages (see that log4j issue).",
                "points": "42 points",
                "children": [
                  {
                    "comment": "We should focus in memory leaks as memory safety was a topic of a bulletin. Unless you use unsafe in java, it's probably gonna be jvm issue once memory leak happens.",
                    "points": "-14 points",
                    "children": [
                      {
                        "comment": "Sorry but I think memory leaks and memory safety are completely different things.",
                        "points": "17 points",
                        "children": [
                          {
                            "comment": "How would you describe a memory leak? What's your definition?",
                            "points": "0 points",
                            "children": [
                              {
                                "comment": "Memory leak is simply when you forget to properly free some memory. It is not itself a big safety issue (unless the memory contains sensitive information). It may or may not be a huge problem depending on the size of your application.\n\nSafety is when you improperly access memory.",
                                "points": "0 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          },
                          {
                            "comment": "Certainly are, though I'd argue leaks are a proverbial canary in the coal mine of memory safety.",
                            "points": "-10 points",
                            "children": [
                              {
                                "comment": "I would argue they are mostly orthogonal. I can write a perfectly memory safe memory leak in C++ via something like a cyclical reference of shared_ptrs. So, in fact a mechanism that is designed to help improve memory safety can lead to leaks.",
                                "points": "9 points",
                                "children": [
                                  {
                                    "comment": "Case in point, Rust‚Äôs Box::leak() is a 100% safe mechanism to leak memory built right into the standard library.",
                                    "points": "7 points",
                                    "children": [],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "Memory safety means security against buffer overflows. All other things that might be called \"memory safety\" are so minor they aren't worth mentioning.",
                        "points": "8 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "It's not so much about leaks, but... Attention, memory leaks in Java and the likes happen and the JVM can't do anything about them, as they are \"logical\", application-made.",
                        "points": "0 points",
                        "children": [
                          {
                            "comment": "How can you lekarza memory \"logically\"? Not taking about unsafe package usage. Even if you forgot something and make a collecting that keep growing until oom, it is not a memory leak. Everything is written in its proper memory segments and jvm keeps track of total memory used, it cannot exceeding xmx",
                            "points": "0 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "The main thing being utf8 as the base encoding in Rust. C++ does strings every which way, which makes it more complicated and error prone. I remember trying to convert different encodings because one library would want wchar strings, and it could be big endian or little endian.\n\nOne job I had where the company sold SDKs, and we had ASCII libs/dlls, and Unicode libs/dlls. On top of that we had x86 and x64 versions. That was literally DLL hell for me. Also we had C and C++ versions. Having to support all that was time consuming.\n\nRust is the way to go. It's easier to share your work due to cargo so we shall see exponential increase in the librariess (crates) available for Rust.",
            "points": "21 points",
            "children": [
              {
                "comment": "You're dealing really with Windows and library legacy problems, not necessary C++ problems.",
                "points": "12 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "In practice, much of that legacy still comes along with Rust if you need to link against some common library, like libpng. Rust still has a way to go before there are suitable alternatives or rewrites of everything you may need.",
            "points": "7 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I mean, c++ is full of std's, can't blame them for calling it unsafe",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Wouldn‚Äôt it make more sense to make up a set of standard practices / requirements on how to write safe C++ code rather than banning the language altogether?\n\nAs you said, it‚Äôs mostly a problem with legacy stuff, and that legacy stuff will not be fixed if you tell everyone to migrate to another language. The whole ‚Äúpurpose‚Äù of legacy is that it‚Äôs old but functional, so it doesn‚Äôt have to be changed.\n\nIf I were to guess, rewriting those legacy components into Rust is significantly more effort than adopting modern C++ best practices.",
            "points": "-3 points",
            "children": [
              {
                "comment": "Wouldn‚Äôt it make more sense to make up a set of standard practices / requirements\n\nMany attempts at this exist, e.g. AUTOSAR and MISRA coding guidelines and relevant tooling (Coverity has static analysis checks for these guidelines).\n\nHaving worked with those for several years now, it's just a miserable experience and even they don't guarantee very good safety or security.\n\nI can't even be certain if it's faster than rewriting with more modern tools and languages, it takes a lot of effort to migrate legacy codebases to meet safety standards and it's almost equally likely to introduce new bugs into old codebases than fix hidden ones.",
                "points": "43 points",
                "children": [
                  {
                    "comment": "Many attempts at this exist, e.g. AUTOSAR and MISRA coding guidelines and relevant tooling (Coverity has static analysis checks for these guidelines).\n\nAfaik MISRA C has actual studies showing that it is so bad it is actively making things worse. The committee behind it is basically pulling rules out of its ass whenever its members want to sell a tooling upgrade.\n\nYou would be better of following rules proposed by the languages creator and other aknowledged c++ experts like the c++ core guidelines.",
                    "points": "7 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Nobody is talking about a ban. The White House report is advisory, not law.\n\nC++ is by nature, much more error-prone to memory issues than other languages. Trying to mitigate that with policies may help some, but never underestimate the power of human error.\n\nThe White House report didn't come out of a vacuum either. Both Microsoft and Google were involved and their own analysis is that 25% of all patches they have to do on C++ code is memory issues.",
                "points": "54 points",
                "children": [
                  {
                    "comment": "Yes because people didn't write C++ correctly to begin with. These memory issues are not magical snowflakes that came from new untrodden virgin lands of enchantment. They were written by people who didn't know what they were doing and reviewed by people who were more concerned with their own IC/features than actually doing a code review.\n\nI've seen company after company with their 1000+ line PRs that are riddled with bugs, memory issues, and then programmers who ought to know better just complaining about a language until the next new thing comes along that they can also fuck up.\n\nCause it CLEARLY CANNOT BE ME it's languages fault! Listen I can't use a saw do you know how many times I cut myself, that's why I use a dremmel now! Oh no the dremmel flung debris into my eyes but I'm not going to wear goggles that's stupid, LOOK A TABLE SAW THAT RETRACTS WHEN SAUSAGES ARE THROWN INTO IT LETS GO OVER THERE!",
                    "points": "-36 points",
                    "children": [
                      {
                        "comment": "Sure bud. Let‚Äôs snap our fingers and change the average C/C++ developer to be better. Everyone will suddenly be as good as you. Also when you introduce bugs, we can wave it off because you‚Äôre a diligent person. You‚Äôre excused.",
                        "points": "24 points",
                        "children": [
                          {
                            "comment": "Those things aren't magically fixed by going to some other language, is my point. Hell, even Java isn't safe from the \"The garbage collector sucks I should just be able to use all the memory it's cheap anyway, and at the same time why is this file pointer hanging around?! Just expand the memory allocation!\" people. People will always find reasons that their shitty programming practices and processes are the languages fault, or the companies, or whatever.\n\nPeople aren't perfect that's why we have documentation, references, reviews, tests, and processes in place to help. The REAL issue is that people don't heed these things, they think they know better, they think they don't need their checklists, they think they're above it, and shit hits the fan, with EVERY LANGUAGE.\n\nI worked at a company that lost 4 million dollars over 3 days because of an integer sizing error from 32-bit to 64-bit when passing around IDs. Guess what? It was a memory safe language that had insufficient tests and insufficient reviewing.",
                            "points": "-17 points",
                            "children": [
                              {
                                "comment": "Java isn't safe from the \"The garbage collector sucks I should just be able to use all the memory it's cheap anyway, and at the same time why is this file pointer hanging around?! Just expand the memory allocation!\" people.\n\nThose people are creating performance problems, not security problems. You don't seem to understand what the White House was saying.",
                                "points": "12 points",
                                "children": [],
                                "isDeleted": false
                              },
                              {
                                "comment": "The argument isn‚Äôt that changing languages solves all bugs or human errors. It‚Äôs that certain languages offer better protection against common bugs that even experienced and very smart developers make. Memory faults are a major class of bugs that can be mitigated by GCs (unsafe exceptions are exactly that: exceptions because they are used incredibly rarely in GC languages). It‚Äôs ridiculous not to provide protection against a major class of problems just because other classes of problems are also not solved or mitigated.¬†\n\nI suggest you join a top tier company writing code in C or C++ and report back to us on whether or not they still hit silly memory fault bugs despite their superior tech stack, testing, processes, and developers. Little spoiler: you‚Äôre still going to see these type of bugs.",
                                "points": "11 points",
                                "children": [],
                                "isDeleted": false
                              },
                              {
                                "comment": "this is an extremely defeatist argument. \"we can't fix every possible human error, so why improve anything?\"",
                                "points": "4 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "The data suggests that even skilled programers make memory mistakes with C++.\n\nI get that ego-masturbation is a big thing with programmers so even if you're so advanced that it is a natural impossibility for you to ever introduce a memory bug in your C++ coding, that still doesn't dismiss the need to consider safety over performance in many applications.",
                        "points": "32 points",
                        "children": [
                          {
                            "comment": "Whoa whoa whoa, what about android_queen's elite, mistake-free team that everyone is upvoting?",
                            "points": "0 points",
                            "children": [],
                            "isDeleted": false
                          },
                          {
                            "comment": "YES,\n\nIf we're writing government programs, perhaps that should be our priority. MAYBE.",
                            "points": "-17 points",
                            "children": [
                              {
                                "comment": "Yup. Nobody will try to exploit memory issues in your code unless you're specifically the US government. Just ask anybody.",
                                "points": "16 points",
                                "children": [],
                                "isDeleted": false
                              },
                              {
                                "comment": "I don't think you've spent enough time thinking this opinion through.",
                                "points": "11 points",
                                "children": [
                                  {
                                    "comment": "I don't think you've properly read what the opinion is actually about.",
                                    "points": "-13 points",
                                    "children": [],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "You're actually using auto stops on table saws as an example of excessive safety standards? \"Maybe this powerful buzzsaw that people are going to spend hours almost touching with their hands should stop if people accidentally touch it with their hands\" is an example of silly overprotectiveness in your mind?\n\nIf so, that really does clarify how you feel about safety. If not, why on earth are you bringing it up?",
                        "points": "4 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "The bulletin doesn't say that these issues are magical snowflakes. So who knows where that idea is coming from. The issue is thar c++ is very very permissive about letting you access memory, even when that memory hasn't been allocated to the process. Compiler just builds you an unsafe program. Everybody makes mistakes, and it's difficult to tell that you've made a mistake when your program compiles and runs with no warnings or errors.\n\nThe advantage of a language like rust is that there are prescribed correct ways to handle memory, and if these procedures are violated, the program will not compile. That alone is a very big difference from C++. It's hard for me to imagine cmake behaving in a similar way.",
                        "points": "7 points",
                        "children": [
                          {
                            "comment": "C++ has some of the most robust testing frameworks around. If you're waiting for a compiler or linter to tell you there is an error, I've got news for you, ain't no language out there going to save you.",
                            "points": "-6 points",
                            "children": [
                              {
                                "comment": "If you're waiting for a compiler or linter to tell you there is an error, I've got news for you, ain't no language out there going to save you.\n\nThis is such a bizarre and tone deaf way to respond to me after I highlight that the compiler in Rust is extremely good at catching errors. Im not saying it will write a program for you, but you must not have engaged in the topic very deeply ?\n\nI didn't even say the compiler should be relied on to catch all errors. I said the Rust compiler is very good at preventing you from doing things that are explicitly unsafe, which C++ allows you to do without comment.\n\nI understand there are code analyzer tools. What you don't understand is that not everybody will leverage these tools no matter what you say, and a huge plurality of vulnerabilities come from this family of languages.",
                                "points": "11 points",
                                "children": [
                                  {
                                    "comment": "And memory isn't the only point of my original post.",
                                    "points": "1 point",
                                    "children": [
                                      {
                                        "comment": "Your OP is essentially about how people aren't using the language correctly, and equating it to using a dremmel. You essentially say there are issues with memory only because inadequate, lazy developer aren't leveraging a suite of 3rd party tools to analyze their code. IE, if people were all competent and used testing tools, these memory problems would not exist.\n\nWhat you don't understand is, we all understand that. We all understand that if every professional adhered strictly to best practice, there would be a very small number of vulnerabilities. Again, this is not a hard train of logic to follow.\n\nWhat you don't understand is that it's crazy to build the architecture of a system around the idea that everybody who ever maintains it will never make a mistake. And no matter what you say or think, debugging tools are not a requirement to building a program, so many people DO forgo them.\n\nFrom my perspective, all of these things are just aspects of objective reality, and go a long why to explaining why languages like Rust go out of their way to put up guardrails at compile time. It's literally not about you, or what you think. It's about the issues that do exist in the C ecosystem, and how real solutions to those problems exist outside the ecosystem.\n\nI understand feeling hobbled by Rust. I am also a C++ dev. It just is what it is.",
                                        "points": "10 points",
                                        "children": [
                                          {
                                            "comment": "Your OP is essentially about how people aren't using the language correctly, and equating it to using a dremmel. You essentially say there are issues with memory only because inadequate, lazy developer aren't leveraging a suite of 3rd party tools to analyze their code. IE, if people were all competent and used testing tools, these memory problems would not exist.\n\nI'm saying ALL languages have problems, and ways to find those problems, but if people are unwilling to do so (wearing goggles with their dremel tool), and instead chase the next shiny thing, they're not actually improving, they're just kicking their unknowing can down the road till the next language has issues that they can shit on and code in that language becomes legacy garbage because they wrote the legacy garbage.\n\nA precompiler with checked exceptions and errors IS A DEBUGGING TOOL. What is that logic even?! Static analysis is a form of debugging and debugging tools. Rust just MAKES you use them. These tools exist in other languages as well, you just have to actively use them (I know super painful, uhhg)\n\nNo! No one expects anyone not to make mistakes, if you think there is some language out there that's is going to magically catch all your mistakes without you having to run tests, go through reviews, use debugging tools, etc. Then you're due for a fatal error soon.",
                                            "points": "-3 points",
                                            "children": [
                                              {
                                                "comment": "",
                                                "points": "",
                                                "children": [],
                                                "isDeleted": false
                                              }
                                            ],
                                            "isDeleted": false
                                          }
                                        ],
                                        "isDeleted": false
                                      },
                                      {
                                        "comment": "This white house advisory is solely about memory though, and memory errors are a substantial cause of failures in production systems and security vulnerabilities, and these errors almost entirely disappear if you choose certain languages that make these types of errors very difficult to make.",
                                        "points": "4 points",
                                        "children": [],
                                        "isDeleted": false
                                      }
                                    ],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "Google and Microsoft have a large part of the best C++ developers in the world on their payroll. Yet their C++ code is full of security issues. Outside of these big corporations the situation is much worse.\n\nIt's going to take more than Stroustrup's and your rant to solve C++ problems.",
                        "points": "1 point",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Of the billions of lines of C++, few completely follow modern guidelines,\n\nHow do they know? There is no way to verify if codebase uses modern CPP properly and enforce it at compile time.\nThose number are what people THINK they do, and is exactly the issue",
            "points": "-9 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "The real issue is the language complexity, a trait that both C++ and Rust share. There's a reason that Visual Basic in times past and variations of JavaScript today still are one of the most used languages. Everybody wants to create the one language to rule them all, but in reality what is most needed is a slightly better and slightly less complex version of 'C'.",
            "points": "-8 points",
            "children": [
              {
                "comment": "The difference though is that Rust's complexity is productive complexity, C++'s complexity is non-productive complexity. I will have to spend some time working out the relationships of my data in Rust, which requires some time and effort. But, once that's done, the compiler will forever more enforce those relationships for me.\n\nAnd most of the time I don't have to do that much thinking, to be honest. Most relationships are pretty obvious and straightforward, or only slightly tricky.",
                "points": "2 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Duplicate of https://www.reddit.com/r/programming/comments/1bhvwyd/c_creator_rebuts_white_house_warning/ ;)",
        "points": "41 points",
        "children": [
          {
            "comment": "Duplicate tickets about the same issue just improve the realism of the sub",
            "points": "19 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I'm not saying he is wrong and I rather like modern C++. But you have to admit that the C++ community kept saying its the programmer not the language. It can be a pretty arrogant crowd.",
        "points": "30 points",
        "children": [
          {
            "comment": "Same as the c people, they always blame the programmer.",
            "points": "11 points",
            "children": [
              {
                "comment": "Same as the c people, they always blame the programmer.\n\nBe careful what you wish for.",
                "points": "-1 points",
                "children": [
                  {
                    "comment": "WTF are talking about? I'm pointing out a fact.",
                    "points": "2 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Can someone write \"-wunsafe\" already?\n\nJust check for raw pointers, C stings, and arrays without bounds checking.",
            "points": "-3 points",
            "children": [
              {
                "comment": "This is unfortunately not enough :(",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I appreciate C++, and have a fair amount of experience of writing it both before and after C++11, but somehow these \"git gud\" arguments when discussing language safety don't impress me. If the language is safe if (and only if) you avoid all pitfalls, and refrain from using multiple core language features, then the language is not safe. If I put a bear trap in my living room, it's not safe just because I consider it common sense that you shouldn't step in bear traps.\n\nThere are plenty of use cases where it's acceptable to sacrifice safety to gain other benefits (performance, backwards compatibility, etc), but let's not pretend C++ is safe because it has good reasons to abandon safety.",
        "points": "93 points",
        "children": [
          {
            "comment": "That's a huge part of the problem. Any time this comes up in the C++ section, it's full of people basically saying you ain't man enough for my language, go write Javascript. Or, a lot of it is just mostly innocent, like they just can't understand why any of this would be a problem, just don't do bad things. And an lot of it is I know I don't make mistakes, if you do that's your problem.",
            "points": "33 points",
            "children": [
              {
                "comment": "\"Look, the language is perfectly safe. Yes, there are tons of poorly designed legacy features, but experienced developers know not to use them. Yes, the standard library is clunky and anemic, but the ecosystem is very robust and has better replacements. Yes, the language will let you confuse your types and mutate the wrong thing and write egregious bugs with no warnings, but if you just don't do that and use this third-party build tool and write six hundred unit tests everything will be fine.\"\n\nIs this a C++ developer, or JavaScript developer?",
                "points": "28 points",
                "children": [
                  {
                    "comment": "Depends on what you mean by \"safe\". Is your safe the exception/logic bug safe or the arbitrary code execution safe?",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Genuinely confused in general by programmers being at all against the idea of preventing human error & simplifying/removing predictable processes from the equation, like that's half the point of programming to begin with",
            "points": "11 points",
            "children": [
              {
                "comment": "Leaky abstractions",
                "points": "-1 points",
                "children": [
                  {
                    "comment": "What about them?",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I think a landmine is a better analogy here. A bear trap, after all, only hurts the person stepping on it, while a landmine will hurt the onstepper, anyone else in the room and the room itself. Just like C++!",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I'd be salty too if my life's work and it's compounding mistakes were called a national security risk by the government.",
        "points": "33 points",
        "children": [
          {
            "comment": "I'll stick with some ancient wisdom:\n\n\"Be careful with authorities, for they do not befriend a person except for their own sake. They appear as friends when they benefit from it, but they do not stand by a person in his time of need.\"\n\nI'm biased though as my magnum opus is C++ related.",
            "points": "4 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I mean, Rust has RAII for example, and a lot of other ideas from C++. Why can't he embrace that some of his/theirs good ideas live on in other languages? He's like the French still insisting they have a world language. English is full of french expressions, just embrace it",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I see they quoted him from the email response, but do they post the whole thing anywhere?",
        "points": "16 points",
        "children": [
          {
            "comment": "InfoWorld made the inquiry, so they are direct quotes.\nAnd then there is 2023 cppnow that you can find on YouTube.",
            "points": "3 points",
            "children": [
              {
                "comment": "Sure I agree they're direct quotes but I'd love to read the whole response if possible",
                "points": "3 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Of course he would, it's his cash cow.",
        "points": "6 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "One ironic thing is that the only virtue of C++ that I used was pointers in creating highly optimized data structures. These were dangerous and required rigorous attention to detail and massive testing to absolutely make sure they were correct.\n\nOften graph theory was all over these and there was little chance a non mathematically inclined junior programmer would do anything but break them.\n\nI now use rust and just don't do this crap.",
        "points": "31 points",
        "children": [
          {
            "comment": "I thought the point of Rust was that you could still do the same things and prove they were correct. Otherwise why use it instead of a garbage-collected language?",
            "points": "5 points",
            "children": [
              {
                "comment": "do the same things and prove they were correct\n\nSort of. There is no doubt about memory safety. But there are so many little things where it holds your hand while crossing the street. This pisses off some people, but it entirely eliminates getting hit by cars.\n\nThere are whole essays as to why garbage collected languages are problematic, especially for people doing things where you want a high performance or mission critical language.\n\nAnything you can do in rust, you can also do in C++, C, or even assembly. The question is, will it make you do it, or at least make it easy.\n\nFor example. Let's say you have a function GetUser(user_key). What is your return type? Probably a user object. What about if there is no user with that key? Maybe you return a nullptr. Not too complex. But if you want an error, is it a nullptr, or an exception?\n\nNow, let's say you want a user count? GetUserCount. Does it return an int? What about it failing? Do you return 0? Or a -1? -1 is common, but what if you want an unsigned int?\n\nWhat about a factory? Let's say you have GetSportParticipant(user_key). You might want to return a Player, Coach, Parent, Referee, Audience, Etc Object. Again, I can think of 5 different ways to do this in various languages. But this is the sort of thing which is fraught with either complexity, or peril. You are going to be casting things. Better get that right at runtime. Rust makes this compile time certified to be correct.\n\nAll of these have solutions in languages like C++. But, Rust has some really clean safe solutions which are just going to keep you out of trouble.\n\nWhere people have trouble with rust is when they try to impose C++ patterns on rust, and then end up fighting with rust. You have to do it the rust way or you are going to be miserable.",
                "points": "4 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "I believe that your parent is referring to the fact that someone else has probably already created those data structures, and using someone else's implementation is trivial. So there's no need to re-do the work yourself.",
                "points": "8 points",
                "children": [
                  {
                    "comment": "i see this all the time and i dont get how using someone elses impl is hard.\nif theres cmake, yay!\nif theres no build system, yay!\nif theres some other, external is here to help!\nI..dont think I have implemented many difficult DS myself, [except for learning.]",
                    "points": "1 point",
                    "children": [
                      {
                        "comment": "Even that decision tree is more difficult and more work than \"cargo add petgraph\".",
                        "points": "4 points",
                        "children": [
                          {
                            "comment": "sure but it also allows you access to some of the best libraries on earth.\n[or you can always add it via xmake, which is just as simple as that cargo line]",
                            "points": "-1 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Rust will prohibit you from using this architecture and force you to use some maybe convoluted / maybe nice approach using integer indices, hashtables, and (probably) huge tagged unions and/or boxed trait impls instead.\n\nTechnically you *can* write this kind of code in rust ‚Äì albeit unsafely and very non-idiomatically ‚Äì by wrapping everything in unsafe. Which lets you use raw pointers. And afaik that's pretty much all the unsafe keyword actually does.\n\nA GC language would yes be substantially easier and less verbose. And could be safe w/ the concept of optionals, and forcing all usages of pointers / optional references to properly and explicitly handle those with unwrap and/or branches, as in eg. scala / swift.\n\nAs a sidenote it's actually worth noting that there are many Haskell patterns that are either impossible or... well, just really really painful to do in Rust. Because despite both being ML languages Haskell, the LISPs, and pure functional programming in general is actually quite dependent on GC as a foundational enabling concept (ie. to not worry about memory management and stuff like closure lifetimes and ownership, et al)\n\nAnyways the point of Rust is that it's a fairly safe ‚Äì and to a certain point provably (sort of) safe ‚Äì systems language. You should be using rust where it is NOT appropriate to be using a managed GC applications language ‚Äì for whatever reason ‚Äì and may absolutely be making life harder for yourself in other areas where a higher level applications language might honestly be a better fit.\n\nThat said rust understandably gets quite a bit of hype and good will from folks who are basically using a language with good static typing ‚Äì and ML features ‚Äì for the first time. Aka JS, Go, Java, .NET, and Python programmers. And/or people who are happy to not be using / writing c++.\n\nThough it's probably well worth noting that modern c++ has nearly all the same strengths that rust has ‚Äì namely safety and low-overhead automatic memory management ‚Äì when used properly on a fresh codebase with static analyzers (or heck even just the bare compiler) et al. Just sans a borrow checker and with the caveat that C strings will get you intro trouble, along with half a dozen other pitfalls, and there's half a dozen things you could do in c++ land that could blow your leg off, or in general make your experience as a (somewhat inexperienced) developer fairly miserable.\n\nWell worth noting that rust is not the safest language around ‚Äì haskell for instance would pretty easily take that cake. Albeit with the caveat that haskell may take significantly more work to adjust to than even rust's super restrictive allowed subset of imperative programming. And that Haskell's performance is... um... fairly unpredictable and finicky, to say the least. But far more thread safe / thread friendly and even more trivially parallelizable than Rust ‚Äì again, GC and lazy pure evaluation all have their upsides, and Rust is actually missing a lot of features that make Haskell great. (and slow, and not remotely applicable for kernel, browser, game, or embedded development, lol)",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "[deleted]",
            "points": "3 points",
            "children": [
              {
                "comment": "At first I would agree. But once I stopped doing C++ with rust and did rust with rust, my life became way better. You can't impose C++ patterns on rust. If your head is full of funky linked lists and pointer magic, you are going to have a bad day. It's not that you can't have pointers, it is that you have to really grok what rust is about to do with what memory and where. Al the pointers are still doing pointer things, it is that you can't then do stupid things with them. Thus, you need to work with rust, not against it.\n\nI have written yards and yards of rust and not a single use of unsafe. For example, I can write quite a bit of rust before it yells at me. Often it is something stupid like putting a semicolon at the end of those implicit return things.\n\nThis is why when people do various benchmarks (not just rust evangelists, but people solving various problems) that rust ends up being as fast, or faster than C and C++.\n\nThe people I know who love rust went through a phase where they were endlessly cursing the borrow checker and other things. But, then they stopped and found bliss.",
                "points": "3 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "If that‚Äôs the only ‚Äúvirtue‚Äù that you found on C++ then you haven‚Äôt even scratched the surface of the capabilities of the language. Pointers are literally the first thing that are taught to anyone who is introduced to system programming and no, they are not ‚Äúdangerous‚Äù and they do not require ‚Äúmassive testing‚Äù, you just have to understand how a damn computer works before using them.\n\nC++ puts a lot of trust on the programmer, if you don‚Äôt want to hold this responsibility you can choose other languages.",
            "points": "-21 points",
            "children": [
              {
                "comment": "Call me silly, but I'd rather not have to trust that the person knows C++ as well as he thinks he does if my security, safety, money, etc... are possibly on the line or might be compromised. This isn't about how manly we are, it's about our responsibilities to the people who use the software we write.",
                "points": "7 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "C++ puts a lot of trust on the programmer\n\nIf you are a very good programmer, this is not much of a problem. 50% of programmers are below average.\n\nI would argue rust requires very good programmers, not to avoid disaster, but to be smart enough to wrap their heads around it.\n\nAlso, after 30 years of using C++ I know its virtues, but that is one which I used well vs other languages.",
                "points": "2 points",
                "children": [
                  {
                    "comment": "It's a very powerful language that requires attention to details. You need to RTFM in order to manage UBs appropriately. But, at the current time there is NO other stable, performant, versatile language like C++. In no other language you can do template meta-programming, real OOP and functional(-ish) programming all in the same codebase. C++ fills a hole no other language does right now. Maybe in the future Rust will take C++'s place but for now, it's too immature.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Strustrup's worst nightmare is C++ falling into disuse.\n\nThis is also one of my wet dreams. The language is unfixable, it needs to be phased out.",
        "points": "79 points",
        "children": [
          {
            "comment": "This wont happen for decades. Too many critical C++ codebases in use that would take nightmarish years to rewrite in a memory-safe language.",
            "points": "53 points",
            "children": [
              {
                "comment": "As long as there are no new projects in some language we can call it dead.\n\nIt doesn't mean it disappears, but it will not attract new development.\n\nI don't know if that will happen with C++ but I personally finally see new command line tools and those are written in rust. So I like rust, even though I know most of those tools don't use best practices.",
                "points": "5 points",
                "children": [
                  {
                    "comment": "COBOL has entered the chat.",
                    "points": "16 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "There are new projects in C++ all the time.\n\nI'm personally still trying to get people, especially in embedded, to move from C to C++.",
                    "points": "3 points",
                    "children": [
                      {
                        "comment": "Yes, that's why the thread was about how C++ needs to die, not about how it's already dead.",
                        "points": "-2 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "I suspect within 5-10 years, rewriting¬†a code base from C++ into C# will be a trivial application of AI, and all that will be required from humans is to write the tests.",
                "points": "-66 points",
                "children": [
                  {
                    "comment": "Lmao.",
                    "points": "36 points",
                    "children": [
                      {
                        "comment": "Wouldn't be too hard on very simple codebases assuming that you just mark everything as unsafe... then you can just use pointers and such.\n\nSort of defeats the purpose, though... and no idea how you'd transcode multiple inheritance, template fun, header include fun, macro fun, etc....",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "C++ and C# solve completely different problems. You literally cannot translate C programs directly into C# programs without abandoning all of the things that make C# safe. Like.. a runtime.",
                    "points": "12 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "!remindme 10 years",
                    "points": "10 points",
                    "children": [
                      {
                        "comment": "I will be messaging you in 10 years on 2034-03-19 17:40:35 UTC to remind you of this link\n\n2 OTHERS CLICKED THIS LINK to send a PM to also be reminded and to reduce spam.\n\nParent commenter can delete this message to hide from others.\n\nInfo\tCustom\tYour Reminders\tFeedback",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "I look forward to hearing from you! Haha",
                        "points": "0 points",
                        "children": [
                          {
                            "comment": "‚ù§Ô∏èü•∞",
                            "points": "0 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "https://www.stroustrup.com/P0977-remember-the-vasa.pdf\n\nSounds like a realist to me. I'd recommend you watch his talks, but it's clear you've got your mind made up, so let us not bother.\nAlthough I'm skeptical he and the rest of the committee will be able to pull off the saving of C++, I admire his effort, because it hasn't been done. Back when C faced this dilemma in the 90's, people gave up on it, which is why C89 is still relevant, and C99 support isn't a given everywhere.\nBut C++ has always been sort of complex, so they can navigate through the complexity budget and at least try. Once they figure out a way to deprecate stuff fast enough, as JF Bastien put it, they might be able to save it.",
            "points": "0 points",
            "children": [
              {
                "comment": "it's clear you've got your mind made up\n\nWorking with the language for 15 years tends to do that.\n\nOnce they figure out a way to deprecate stuff fast enough\n\nI mean, I guess they did deprecate some stuff, but that's so little they might as well not have deprecated anything. I'm not even sure they should: not breaking existing code is a huge selling point, which explains why they're in such a bind.\n\nThe only hope out of this quagmire is a clean source-level break, that same break Stroustrup absolutely refused to do when he created C++ in the first place. But in a way, this break is coming whether they want it or not: we have Zig, Rust, Odin, Jonathan Blow's JAI (yeah, unreleased yet), and more competing in this space. Some of them are bound to eat C++'s lunch somewhere down the road.",
                "points": "5 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "The language is unfixable\n\nC++20 and, especially C++23, proves you wrong. C++ has come a long way since 1998.",
            "points": "-8 points",
            "children": [
              {
                "comment": "That's improvement, not a fix. C++ still requires far more care and unproductive commitment of time to avoid doing wrong things compared to Rust.",
                "points": "15 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "I'm up to date with C++ 14, and last time I used the language was‚Ä¶ yesterday. on C++20. I didn't see major improvement since C++11/14 to be honest.",
                "points": "5 points",
                "children": [
                  {
                    "comment": "Then you didn‚Äôt paid enough attention.",
                    "points": "-2 points",
                    "children": [
                      {
                        "comment": "If it was so obvious you could point out what‚Äôs so great, then. Cite 3 examples or it doesn‚Äôt count.",
                        "points": "4 points",
                        "children": [
                          {
                            "comment": "functional error management(std::optional compared to the old-style exceptions);\n\nmonadic operations;\n\nstd::print(compared to std::iostream);\n\nstatic template constraints(concepts);\n\nreflection;\n\nmodules(instead of old #include statements).\n\nAnd there's much, much more. Trust me, newer standards have transformed the language.",
                            "points": "0 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Except the newer C++ features and indeed any overuse of templates is ass to write, read and debug, and most programmers rightfully dread it and continue to use \"C with classes\" style as back in the day (and for new stuff just start with Rust).",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Eh, D fixed it 12 years ago (and albeit added other problems), and modern c++ is gradually getting to that point.\n\nThough yeah sure this in itself is a moot point because c++ is still widely used because of legacy codebases, and those legacy codebases are not going to be rewritten onto the latest version of c++-whatever.",
            "points": "0 points",
            "children": [
              {
                "comment": "Eh, D fixed it 12 years ago\n\nIt fixed C++ by phasing it out I guess?\n\nc++ is still widely used because of legacy codebases\n\nSo is COBOL, to this day. Yet (almost) no one starts new projects in COBOL. I'll be happy if it's where C++ ends up going.",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "(and albeit added other problems)\n\nQuite sure that is an understatement of epic proportions. Multiple conflicting standard libraries, breaking version changes, a promised but never achieved ability to use the language without having to rely on its GC (they released a crippled \"as better c\" mode instead), ... .",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I don't think you understand why Stroustrup created C++.\n\nThis old interview will clarify.",
            "points": "-7 points",
            "children": [
              {
                "comment": "I can't tell if you realize, as it says, that that's satire or not.",
                "points": "6 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Stroustrup isn't the only one that thinks C++'s future is bright\n\nIteration Revisited: A Safer Iteration Model for Cpp - Tristan Brindle - CppCon 2023\n\nThere are others doing similar work. I'm building an on-line C++ code generator. To the best of my knowledge other more \"modern\" languages don't have on-line code generation.",
            "points": "-13 points",
            "children": [
              {
                "comment": "How does an \"on-line\" code generator differ from conventional build time code generation?",
                "points": "4 points",
                "children": [
                  {
                    "comment": "In the past some have mentioned that Rust supports having multiple versions of the Rust compiler installed on a single machine. On-line code generation makes it easy to do that. Compiler Explorer is a form of on-line code generation. Using it to target multiple compilers and versions is easy. My approach has been to minimize the amount of code that users have to download/build/maintain.\n\nThere's are also the timeless nature of services. If you want tools that outlast your project, go with services.",
                    "points": "-1 points",
                    "children": [
                      {
                        "comment": "I think I'm missing what that has to do with the future of C++ or why it even matters to be honest. Most all compiled languages I'm familiar with support having many different versions of them installed all at the same time.",
                        "points": "1 point",
                        "children": [
                          {
                            "comment": "Perhaps you would agree that both code generation and services are individually important. What I'm doing is bringing them together. It's nearly impossible to overestimate the importance of a marriage. My goal is to provide service leadership to the C++ community.",
                            "points": "0 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "How do you write viruses that exploit memory vulnerabilities without C++? Does Rust let you do buffer overflows?",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "So im fine, since im following RAII strictly? I love RAII, i think its beautiful.",
        "points": "5 points",
        "children": [
          {
            "comment": "If you are unsure, then no you‚Äôre fucking it up and are going to have memory bugs. Most likely, you‚Äôre still saving raw pointers/references somewhere since that‚Äôs really easy to do, even with RAII.\n\nAnother one is that unless you‚Äôre checking bounds for an array, your code is probably wrong. The bounds check can be the loop condition (i.e. classic array iteration), but it needs to be somewhere.\n\nFinally, C++ also really likes to do large stack allocations. This is unsafe because it greatly increases the likelihood of unexpected stack overflows causing your whole process to crash.",
            "points": "3 points",
            "children": [
              {
                "comment": "Another one is that unless you‚Äôre checking bounds for an array, your code is probably wrong.\n\nWell, duh?\n\nC++ also really likes to do large stack allocation\n\nNo more than C...\n\nThe default allocators all use heap memory, and many objects will be in heap memory unless you instantiate them locally.... Certain collections on the stack will likely have some extra space for things like SSO, but it's generally very obvious how something will be allocated.\n\nYou can certainly do some awful things with _alloca, _malloca, or inline assembly (some compiler probably lets you manipulate the stack pointer with an intrinsic as well), but those aren't standard.\n\nI don't even recall the last time that I was unsure what would be on the stack or not...\n\nI also don't recall the last time that I had a stack overflow in a 64-bit process. 47-bits of user address space is a big space. With lots of threads/fibers, you obviously have less/fragment it, but even then, you usually have to be doing recursion to overflow.\n\n32-bit or 8-bit is another story, though I still don't remember the last time I saw a legitimate stack overflow bug there.",
                "points": "0 points",
                "children": [
                  {
                    "comment": "The total memory space size doesn‚Äôt matter at all with regard to stack overflow and reflects a CS 1000 level understanding of memory layout. Actual thread stack sizes are a couple MB and it is very easy to stack overflow when doing array allocations on the stack and/or using recursion. 64-bit doesn‚Äôt matter in the slightest for stack overflows (at least for C/C++).\n\nYou can increase stack size beyond this, but most of the time it needs to be a fixed size and you don‚Äôt want it too large since that just ends up wasting memory.",
                    "points": "-4 points",
                    "children": [
                      {
                        "comment": "reflects a CS 1000 level understanding of memory layout.\n\nI won't bother telling you what your lack of knowledge and your attitude reflect. Since you decided to start off with an attack on my competence, I'll take a tone in kind.\n\nActual thread stack sizes are a couple MB and it is very easy to stack overflow when doing array allocations on the stack and/or using recursion. 64-bit doesn‚Äôt matter in the slightest for stack overflows (at least for C/C++).\n\nThe CPU itself has no such restriction on the stack pointer, so long as it's a canonical address and the VMM can access it within the current context.\n\nPlenty of people work bare-metal or near-bare-metal where guard pages and such aren't present... and C++ is absolutely used there. 64-bit bare-metal is fun.\n\nI literally write emulators - address space matters a lot to me, including for detecting stack overflows, and how to allocate thread stack ranges (whatever VMM system the emulator is using).\n\nI also write AVR and ARM firmwares, and have done game development on older consoles. Guess what: your assumptions don't always hold. Not everyone is just writing basic Win32/Win64/Linux applications.\n\nit is very easy to stack overflow when doing array allocations on the stack and/or using recursion.\n\nYou cannot perform dynamic array allocations on the stack without relying on implementation-defined behavior (e.g. alloca), and static-sized array allocations will almost always incur a compiler warning if they're large enough.\n\nEd: I suppose you could using some bizarre combination of recursion and lambdas to build up what is effectively a chain buffer, or a combination of recursion, a lambda, and setjmp/longjmp and then using the stack frames as a large dynamic buffer and bypassing ret by using longjmp, but... if you're doing that, that's on you.\n\nI also don't believe that people are regularly placing massive static arrays on the stack, unless they are ignoring warnings... in which case that's on them. Given that your tone and word choices suggest that you've often run into this, I believe that it is safe to assume that you're in this category.\n\nPast that, OS-defined limitations on the size of the stack are hardly the fault of C++, especially given that the standard doesn't mention heaps or stacks (aside from std::stack and std::make_heap) nor does it mandate their usage.\n\nI also explicitly mentioned recursion. Even Rust allows recursion, so I'm not sure how that's C++-specific. Literally the first hit on Google is someone asking about a stack overflow in Rust on... Stack Overflow.",
                        "points": "6 points",
                        "children": [
                          {
                            "comment": "Wow you made him look like an... standard C++ user vs rust user difference in competence",
                            "points": "0 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I do prefer the acronym SBRM or SRM, though: Scope-based Resource Management.\n\nMan, I wish that C# structs could have destructors.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Anyone who thinks there is a magical language decision you can make that will overcome sloppy development practices and total lack of maintenance is an idiot.\n\nLast C# shop I worked at didn't use any version control did not even have test environments just dev's desktop and prod, when the senior dev left (after working there 10 years) he handed over a handful of usb drives (aka his code repo) and had run a code fuzzer on at least half of his work.",
        "points": "6 points",
        "children": [
          {
            "comment": "But that's not really the issue. The issue is, if YOU DO want to create high quality code, what tools will assist you the most in doing that, will prevent you as much as possible from making mistakes, and will make it the least likely that teams working on separate bits of code will have issues?",
            "points": "16 points",
            "children": [
              {
                "comment": "The issue is, if YOU DO want to create high quality code, what tools will assist you the most in doing that, will prevent you as much as possible from making mistakes\n\nand my point is that the choice of language isn't the answer to these problems.",
                "points": "-8 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Ok so people shouldn't use C-style pointers anymore. Are you, Bjarne, personally going to go to every single developer who writes code that will be used in government and tell them? Why do C-style pointers even exist in C++? Backwards compatibility my ass. Code from 30 years ago has no business running on modern systems and modern developers shouldn't even be given the option to write unsafe code or at least it should be made as hard as possible. The problem with C++ is that memory-safety is NOT the default. No amount of pointer wrappers is gonna change that.",
        "points": "7 points",
        "children": [
          {
            "comment": "C++ was designed to be a drop in replacement to C. Like typescript is to javascript, you can replace parts of your codebase with it without having to rewrite all of it. Thats why it was adopted and spread quickly in both those cases.\n\nOperating systems code is written in C. If you want to work with the system you have to be able to call its exposed functions which have a C interface.\n\nCorrect me if im wrong but in rust you have to use unsafe blocks to make those calls while C++ lets you either use raw pointers or a smart pointer. And in all those cases you get a segfault if you make mistakes.",
            "points": "15 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I use C-style pointers all the time",
            "points": "30 points",
            "children": [
              {
                "comment": "And that's great and I have no problem with that. My problem was that Bjarne claims C++ is not unsafe because a \"good\" developer can easily write super-safe code in C++. Ok but what about a bad developer? They can even more easily write unsafe code. I'm not even a Rust user but in Rust both bad and good developers write safe code by default. Bjarne says specifically that people shouldn't use C-style pointers anymore while STILL KEEPING THEM IN THE LANGUAGE.",
                "points": "20 points",
                "children": [
                  {
                    "comment": "Even good developers can introduce memory bugs unfortunately. Sometimes you think a piece of code is correct, only to profile it for hours and finally understand the mistake. It's possible that one bug fixes another bug in most cases but not all.\n\nRust is a language that can be extremely annoying to use. I do think that if there were more high level libraries where the rough edges are evened out and there are resources on how to use them, then I think more people would write Rust even for things like web development.",
                    "points": "6 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "You can write unsafe code in Rust as well. Though it is harder to write memory unsafe code in Rust than in C++. Plenty of other unsafe code that still remains for Rust etc.",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "You cannot write unsafe code in safe Rust, unless you make up your own definition of what unsafe means. You can write LOGICALLY INCORRECT code in safe Rust, but that's the case for any language. But you cannot write code that exhibits undefined behavior or memory safety issues in safe Rust. And that's the only guarantees it makes, though those are very big ones.",
                        "points": "6 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "ok but what about a bad developer?\n\nTBH I think we should start pandering less to people with skill issues as an industry and start expecting more from people.\n\nWHILE STILL KEEPING THEM IN THE LANGUAGE\n\nKind of necessary not only for backwards compat, but for compatibility with C code and C libraries",
                    "points": "-15 points",
                    "children": [
                      {
                        "comment": "I completely disagree. Turns out, compilers are better and faster at finding these issues than humans are.\n\nPeople inevitably make mistakes, it‚Äôs just an inherent fact of the development process. If you don‚Äôt see this, then you probably aren‚Äôt experienced enough to have an informed opinion about this problem.\n\nUsing memory safe languages, or languages with modern type systems can make it impossible for entire classes of mistakes to make it into your codebase. Without these tools, guaranteeing that sort of safety is difficult if not impossible. In mission critical applications that have dozens or hundreds of contributors, just ‚Äúbeing careful‚Äù should never be considered good enough.",
                        "points": "4 points",
                        "children": [
                          {
                            "comment": "Turns out, compilers are better and faster at finding these issues that humans are.\n\nThis is not really entirely true. Compilers like GCC have had huge amounts of R&D put into them, but the developer is still probably a lot more competent than its static analyzers.\n\nYou also have compilers like the Rust compiler, but they don‚Äôt ‚Äôfind issues‚Äô for you, they just enforce rules to stop those issues from appearing in the first place.\n\nThen though we come to the issue of practicality vs pedantic correctness. I can use Rust, and I‚Äôve written quite a bit of Rust code, but when I‚Äôm using C or C++ to solve a problem I am able to move an order of magnitude faster than I can in Rust because the compiler doesn‚Äôt stick so many roadblocks in my way, and I know what I‚Äôm doing (simply thanks to experience) so null pointer errors, memory leaks, etc. are exceedingly rare.\n\nIt‚Äôs not so trivial to decide if I should write a piece of code in a language like Rust where I can ‚Äòguarantee‚Äô safety (not entirely true either) but will move slowly, or use a language like C or C++ where I need to rely on my skills as a developer but can move far quicker.",
                            "points": "-7 points",
                            "children": [
                              {
                                "comment": "I can use Rust, and I‚Äôve written quite a bit of Rust code, but when I‚Äôm using C or C++ to solve a problem I am able to move an order of magnitude faster than I can in Rust because the compiler doesn‚Äôt stick so many roadblocks in my way\n\nSounds like a skill issue /s (but not really/s).\n\nThe rust compiler isn't throwing \"roadblocks\" at you, it's calling out mistakes that the C++ compiler doesn't care about.",
                                "points": "2 points",
                                "children": [],
                                "isDeleted": false
                              },
                              {
                                "comment": "so null pointer errors, memory leaks, etc. are exceedingly rare\n\nThere are two problems with this statement.\n\nThe first is that if you ask every C++ dev, 99% of them would probably say the same thing. Clearly at least some of them are overestimating their own ability and those bugs/errors are actually much more common.\n\nThe second is that whilst they may be exceedingly rare, it only takes one to introduce a critical vulnerability. The whole point is that we should be using tools that eliminate these bugs. We can't rely on people being \"good enough\" to avoid making these mistakes, it should be literally impossible for even the most incompetent dev to create these issues.\n\nAt some point in time, you are going to find a bad developer writing critical code, and you want to minimise the number and types of vulnerabilities they are able to introduce.\n\nI say all of this as a C++ dev who loves the language.",
                                "points": "2 points",
                                "children": [
                                  {
                                    "comment": "The first is that if you ask every C++ dev, 99% of them would probably say the same thing.\n\nNot only is that a gross overstatement, but it doesn‚Äôt really matter. Don‚Äôt judge people based on what they say, but let their code speak for itself.\n\nit only takes one to introduce a critical vulnerability.\n\nThat‚Äôs true, but also not always applicable. If you‚Äôre Google writing Google-style software then sure. If you‚Äôre writing software to be used in-house or in a controller environment, the biggest deal is typically the fact someone needs to restart something. If it‚Äôs a CLI tool ‚Äî maybe some code searching tool ‚Äî it literally doesn‚Äôt matter.\n\nAt some point in time you‚Äôre going to find some bad developer writing critical code\n\nA huge portion of the software we use on a daily basis was written by a single person, not by a team. We shouldn‚Äôt forget the fact that an enormous part of the software development space is not commercial enterprise, but just individual recreational programmers.",
                                    "points": "-1 points",
                                    "children": [
                                      {
                                        "comment": "Not only is that a gross overstatement, but it doesn‚Äôt really matter. Don‚Äôt judge people based on what they say, but let their code speak for itself.\n\nIt was deliberate hyperbole haha, so you're not wrong. But I feel like this is the point of what I'm saying. You cannot trust a C or C++ developer if they say they write safe code, you do have to analyze their code for vulnerabilities.\n\nNot only is this horrifically unproductive because you introduce a whole extra layer to development (or a lot of extra time to your code reviews) but it's also very possible, if not likely, that you will not always catch every issue. Which is why it's orders of magnitude safer to use a language that simply eliminates those kinds of errors entirely.\n\nThat‚Äôs true, but also not always applicable. If you‚Äôre Google writing Google-style software then sure. If you‚Äôre writing software to be used in-house or in a controller environment, the biggest deal is typically the fact someone needs to restart something. If it‚Äôs a CLI tool ‚Äî maybe some code searching tool ‚Äî it literally doesn‚Äôt matter.\n\nI don't entirely disagree but I also think it's not that simple. For one, I think it's pretty clear that the White House are not advocating for avoiding C++ for random personal projects, I think it's clearly addressing sensitive systems where data or important processes could get exposed.\n\nBut I also think that it's a little naive to say that it literally doesn't matter for small CLI tools or whatever. You could easily make a CLI tool with a vulnerability that ends up getting used by someone else who has access to sensitive data, and your vulnerability could be what ends up giving the hacker access to that data. Not that that's likely but it certainly is possible. You can't always predict how your software will be used and who will use it.\n\nI don't have much to add to your last paragraph because whilst I do agree I also think many of the points I raised in my last couple paragraphs also apply here too.\n\nThe weakest link is always the human link. And relying on humans rather than compilers or code to remove safety issues is just a ticking time bomb.",
                                        "points": "0 points",
                                        "children": [],
                                        "isDeleted": false
                                      }
                                    ],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              },
                              {
                                "comment": "but when I‚Äôm using C or C++ to solve a problem I am able to move an order of magnitude faster than I can in Rust because the compiler doesn‚Äôt stick so many roadblocks in my way, and I know what I‚Äôm doing\n\nNow your lead/manager/employer comes in and informs you that the software must run on all major desktop platforms and the clients complain that it's slow so you are tasked with making it cross-platform and multi-threaded and also you now have a new team member - a jun or mid-level C++ dev.\n\nGuess where your C++ productivity will be? That's right - in a deep deep hole and you'll regret big times for not choosing Rust.",
                                "points": "-1 points",
                                "children": [
                                  {
                                    "comment": "Not all software is enterprise software. An insanely huge amount of software is not enterprise software where you are either solo or a small team and have no boss.",
                                    "points": "1 point",
                                    "children": [],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "The solution is to use tools that eliminate entire classes of bugs. Computer science has solved lots of problems. It's important to apply that knowledge practically. Using tools and languages that allow for solved problems to exist is asinine.",
                        "points": "3 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "I mean, if we treat it like other engineering in the world maybe. Engineers in other fields are held liable to damages for the bridges/buildings/whatever they create.\n\nImagine if you PERSONALLY were held liable for any security breach that occurred from your code?\n\nNot saying I want that, but until we have something similar to elevate the skill floor, nothing is gonna stop companies from hiring the lowest common denominator to throw at these problems.\n\nCoding is cheap, if you dont care about quality or safety and just want an app built.\n\nBuilding a house is also cheap, if you dont care about quality or safety. You just might not want to stay in it for long :)",
                        "points": "4 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "I'm my experience most devs just don't even think about writing safe code and the ones who do don't seem to do it very well. Whilst it is possible to write safe C++ very little of it is. It should die - plenty of better options.",
                    "points": "-3 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "This is explicitly a bad thing and being proud of it is like being proud of not using a safety harness working at height.",
                "points": "-4 points",
                "children": [
                  {
                    "comment": "It depends on what you're doing. I use raw/non-smart pointers fairly regularly. These almost always to refer to addresses that exist in other PGAS address spaces. Reference counting doesn't scale well.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "Except I‚Äôm not risking my life, or anyone else‚Äôs.",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "Given the reach and impact of automation and code on the modern world, especially things that were never intended to get to the scale they are currently at, I think we can safely call this claim straight-up false.\n\nEven if you aren't working on something sensitive now, you are learning bad habits that can cause trouble down the line if you ever do. Ignoring security and regretting it later is, in many ways, the defining feature of twentieth-century development. Which is kind of a terrible legacy.",
                        "points": "3 points",
                        "children": [
                          {
                            "comment": "you are learning bad habits that can cause trouble down the line\n\nSaid who? I‚Äôve been coding for a bit over a decade now. I have my habits and the way I do things (and I‚Äôm always learning) but most of the decisions I make are thought through and informed. I‚Äôm not magically going to start writing bugs at my job because I know how to code in C and use pointers while making sure to check for NULL (because I read the manpages unlike a Neanderthal).",
                            "points": "-3 points",
                            "children": [
                              {
                                "comment": "Sorry, I didn't realize you were one of the non-bug-creating programmers. I've never met one in person, see, and am certainly not one myself, so I considered it unlikely in general.\n\nSome of the best programmers I know have been victims of self-inflicted memory problems even deep inside very robust memory-managed environments; the problems can be surprisingly subtle, so I thought the actual problem might be difficult, even when great care is taken. My bad.",
                                "points": "2 points",
                                "children": [
                                  {
                                    "comment": "I don‚Äôt mean to suggest I don‚Äôt make bugs. Of course I do, we all do. I also have made memory-related bugs in the past of course. That being said, anyone with a decent amount of experience in software development is unlikely to run into memory leaks or NULL pointer issues more than like, once or twice in a good while, and it‚Äôs typically a trivial bug that can be easily caught by GDB and/or valgrind and then solved.\n\nMost software is not giant monoliths with 600 layers of abstraction with hard to follow control flow",
                                    "points": "-1 points",
                                    "children": [],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Code from 30 years ago has no business running on modern systems\n\nSo you're telling us current operating systems have no business running on modern systems...?",
            "points": "16 points",
            "children": [
              {
                "comment": "If by current you mean operating systems where none of the code has been rewritten in 30 years and the same issues as 30 years ago still plague it then yes it has no business running on modern systems.",
                "points": "2 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Amen - it's like if you said, \"my new car design is perfectly safe - I just included this self-destruct button for the sake of feature completeness.\"",
            "points": "4 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "C style pointers are great. You get polymorphism, no copying, and you dont pass ownership. All without referencing counting quirks. All you gotta do is not delete a pointer that you dont own.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I work on a commercial communications system that was adapted from a commercial product coded in C and had evolved to using C++ for new modules. Should companies stop selling a product because it was coded in an old language?",
            "points": "-1 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Strustrup should shut the fuck up, the fucking idiot created the worst programming language to date, worst of all, he said he got into computer science by accident and doesn't like computers. A man who dislikes computers should not dictate to us how to build our software.",
        "points": "-1 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "C++ gives really strong guarantees, which are about as strong as C. If you don't hit UB, code is completely safe and you can reason about it. If you hit UB, your code is not valid program, therefore not counted toward broken guarantees.",
        "points": "-9 points",
        "children": [
          {
            "comment": "What's ub? Upper bound of memory?",
            "points": "0 points",
            "children": [
              {
                "comment": "undefined behavior. Specifically it's code that the language / compiler can assume will never run, and can optimize accordingly (or more generally, do anything at all if it does run).",
                "points": "1 point",
                "children": [
                  {
                    "comment": "Hmm. Idk if that's correct.\n\nUndefined behaviour is just undefined behaviour.\n\nThe code still may run properly - or it may not - or it may run with unintended outcomes.",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "In modern definition of UB for C (not sure about C++) compiler may assume any behavior for UB (e.g. if something is UB in lang specs, compiler can replace it with anything). The shrewd idea of modern compilers is to replace UB with doing nothing (which is form of UB).\n\nE.G.\n\n*(++foo++)=++foo++\n\n\nis UB, and compiler just ignore this line (and may be all other lines with foo after that). Specs says that behavior is undefined, and compiler authors declare that their flavor or UB is 'no code generated' (e.g. instant return from function).",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "25 years ago my prof handed out a copy of this article on the last day of class.\n\nStroustrup Interview\n\nProf told us Stroustrup had seen it and had commented \"if it were really written by me it would be funnier\". ( oh yes, Stroustrup always one for writing comedy O_o\n\nBut, hearing him defending C++ against the White House?\n\nAlmost as funny as the interview above!",
        "points": "-6 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I rebut C++ creator‚Äôs rebuttal. C++ needs to die yesterday.",
        "points": "-7 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "That WH paper was a joke anyway. It was probably written by non technical people who did a Wikipedia research.",
        "points": "-12 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "i feel like you have to assume government contract corruption is at the heart of this\n\na sly way to undermine your C++ competitor",
        "points": "-7 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "\"move to memory safe languages\" was always copy written by some guilded asshat of nepotistic linage. How fucking tone def would it sound in the surgeon general suggested everyone move to robot assisted, laser scalpels?",
        "points": "-52 points",
        "children": [
          {
            "comment": "I would assume it's a great idea?",
            "points": "36 points",
            "children": [
              {
                "comment": "Seriously. If robot laser surgeons reduce mistakes, we should absolutely use them.",
                "points": "41 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I'm guessing this suggestion was driven by the intelligence agencies because they know exactly how vulnerable things are due to how much shit they've cracked in foreign countries.",
            "points": "13 points",
            "children": [
              {
                "comment": "The Five Eyes were involved, yes, but so was industry.",
                "points": "3 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "You talk funny",
            "points": "13 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "C Nonsense in BASIC, 0:1",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "The surgeon general does actually want everyone to move to robot-assisted laser scalpels.",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I‚Äôd compare it more to a warning ‚Äúhey, we should confirm that we‚Äôre operating on the right patient whenever possible‚Äù.\n\nMeanwhile the neckbeard responses like this one: ‚Äúwhat if the patient is unconscious and we‚Äôre in a war zone where a bomb will drop on us in 5 minutes and the patient will die if we don‚Äôt operate in the next 30 seconds. DID YOU THINK OF THAT MR. SCIENCE!!!!‚Äù\n\nMost surgeries do not happen under such conditions and there is plenty of time to go and double check everything before operating. Likewise, it‚Äôs engineering malpractice to use memory unsafe languages (C++) for most new software.",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bik62v",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://newsletter.systemdesign.one/p/tinder-architecture",
    "title": "How Tinder Scaled to 1.6 Billion Swipes per Day",
    "points": null,
    "comments": [
      {
        "comment": "They store the user information in a key-value database like Amazon DynamoDB\n\nThey send swipes to a data stream like Amazon Kinesis\n\nThey put the disliked profiles by a person into a data storage like Amazon S3\n\nSo... is this article just guessing at how they do it? Is it an ad for AWS?",
        "points": "763 points",
        "children": [
          {
            "comment": "I remember Tinder was literally using DynamoDB but I am also curious about why the information is provided by guessing it.",
            "points": "154 points",
            "children": [
              {
                "comment": "Because chatgpt told them so",
                "points": "146 points",
                "children": [
                  {
                    "comment": "lol",
                    "points": "7 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Alternatively, Tinder scales by offloading all scaling problems to AWS",
            "points": "153 points",
            "children": [
              {
                "comment": "This and pay ton of money to AWS",
                "points": "40 points",
                "children": [
                  {
                    "comment": "Uncle Jeff's new dick rocket aint gonna buy itself",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Don‚Äôt we all? If you are not paying the bills is literally a streamline solution to just let AWS scaling do its magic",
                "points": "10 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Is it an ad for AWS?\n\nNo, this newsletter is a recurring pest on the reddit frontpage that churns out low-quality blogspam articles that crudely summarize existing publications about major brands and puts attention-grabbing headlines on them. There's little real technical information, it's often out of date, or just speculates at the details.",
            "points": "65 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "They used to post articles with more insider knowledge, but I guess they ran out of sources and refuse to stop the series.",
            "points": "9 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "It's a practice system design interview told as a story.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "How much is their DynamoDB bill? It destroys bottom lines lol.",
        "points": "160 points",
        "children": [
          {
            "comment": "Not a problem when you can suck $20 a week out of lonely dudes",
            "points": "194 points",
            "children": [
              {
                "comment": "Will this actually be sustainable income? I feel like as more people realize how many fake/bot profiles are on these dating sites, their utility drastically vanishes.\n\nEspecially when there has been study after study where if you aren't in the top 20% of good looking males, you aren't going to be getting as many messages.\n\nI mean imagine a room of 100 men and 100 women where 80 of the women are only noticing and responding to 20 of the men.\n\nIt's not a good dynamic.\n\nMaybe social media was a mistake.",
                "points": "53 points",
                "children": [
                  {
                    "comment": "That‚Äôs what I ask myself. But tinder is so fucked that it‚Äôs gotten me, a dude who practically grew up in the computer corner of my house, to actively take steps towards meeting new people in person and being social in the physical world",
                    "points": "35 points",
                    "children": [
                      {
                        "comment": "teach me",
                        "points": "2 points",
                        "children": [
                          {
                            "comment": "try figuring out whether you‚Äôre censoring yourself in speech and action. I‚Äôve been realizing how much of my past several years have been me suppressing myself from doing or saying things I wanted to do that would have been fine if I weren‚Äôt so afraid",
                            "points": "16 points",
                            "children": [
                              {
                                "comment": "I don‚Äôt know if this would work for me. I suppress my speech and actions because I‚Äôm an impulsive asshole. Lol",
                                "points": "6 points",
                                "children": [
                                  {
                                    "comment": "You and I are very different people then so respect",
                                    "points": "2 points",
                                    "children": [],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              },
                              {
                                "comment": "How to do this? I realized I do this with women too, so as not to come off as overtly sexual/corny/etc., but I've been told I am boring and overthinking.\n\nAlso afraid I don't get \"cancelled\", because I don't know how to \"deliver\" my lines. I've heard people outside say some very edgy, almost misogynistic things (but not actually), but they delivered them in a way that made everyone laugh (at least the women in the group), meanwhile I think if I tried the same thing people would look at me as if I killed their dog or something.",
                                "points": "0 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "it's more 100 men and 30ish women in the room (which doesn't even exclude fake profiles) so even if the women gave every men the same level of attention regardless of whether or not they are compatible / attracted to them, overall men would still end up with not that many messages",
                    "points": "12 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "Tinder has been there for over 10 years and it is not going anywhere.\n\nI mean even if this study correct, it's still worth the bet - your chances are never 0%. The product is making money, and people are getting relationships. The dynamic is not perfect but it works.",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "I don't think that they will ever lose all these customers. People are lonely and dumb.\n\nThe only way to bring such apps down is by providing a better, cheaper alternative and at best gamify it in a way to teach people about loneliness and about what's really important in relationships. The first part probably is achievable. The second part is kinda impossible.\n\nAnd yeah social media was a mistake. Society was a mistake already. It ain't getting better from here on. This is not a doomer take. Most people will just have a better life without caring for society.",
                    "points": "3 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "It‚Äôs not excactly about ‚Äúlooks‚Äù. Our culture teaches women to be presentable and to be looked at from a very early age - girls are complimented for their looks even as small children. That‚Äôs why many women have a strong sensibility to visual communication about someone‚Äôs personality, and quite honestly, straight cis men suck at making profiles that are even remotely appealing.\n\nI‚Äôve spectated my straight friends swipe through endless amounts of cars, bicycles, dead fish, bad photos, photos of friend groups, weird family party shots and killed animals, with a profile text that often says nothing understandable. This is not to say that all genders weren‚Äôt guilty to the same things, but men have horrific profiles more often.\n\nHave your women friends fix them for you or take some nice photos. :-)",
                    "points": "-4 points",
                    "children": [
                      {
                        "comment": "I'm honestly fine because I don't have the personality of a wet paper bag.\n\nI will say that everything you are talking about, has been mentioned ad nausea on the ok cupid blogs over a decade ago.\n\nhttps://web.archive.org/web/20101016050944/http://blog.okcupid.com/",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "ngl i forgot we were talking about tinder and thought you meant something totally different",
                "points": "4 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "I had this strange global flash where all this was a long long misery fueled chain of bit flipping into heat.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "Is that really how much it costs? Never used it.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "If it is actually DynamoDB and if AWS cares about them as a client, likely costs them 40-50% less than what your average consumer would pay.\n\nAWS isn't expensive enough IMHO at TikTok scales of revenue that I would worry about it IMHO.\n\nYou'll likely blow through more than the next decade of savings in engineering effort moving you and you can always negotiate pricing of services with AWS.\n\nIe. We used their edge computing quite a bit, we indicated we were going to switch to Akamai and then they basically lowered the costs of their service to us by about 80% for Cloudfront.\n\nBig org's aren't \"afraid\" to move so these major cloud providers do actually have to prove that value is occurring to retain them.",
            "points": "10 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Billing for a large company is not really an issue if it means getting shit done fast. I used to work for a company that pays about $1M per month on Dynamo DB, revenue is also in the billions so it's pretty much negligible",
            "points": "15 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "It's a big bill, but you also have to realize that 1.6billion/day is only 18.5k/sec which is not that impressive of a number.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Just wait till you hear about how Plenty of Fish runs off a single MS SQL server that does 840,000,000 read/writes a day.. LOL. I was the tech lead there.. Microsoft said they couldn‚Äôt support us because they ‚Äúdidn‚Äôt design SQL Server for those kinds of loads‚Äù. Was a fun place to work. It‚Äôs owned by Match Group that also owns Tinder, OKC, Hinge and a few hundred other online dating platforms around the world.",
        "points": "73 points",
        "children": [
          {
            "comment": "Wasn‚Äôt there the legend that it was largely a solo dev for the longest time ? I remember reading about it way back in the day. He was ultra efficient ‚Äî if I recall correctly a bunch of stuff done low level in C++ ?",
            "points": "19 points",
            "children": [
              {
                "comment": "He was the founder.. Markus Frind.. and yes he wrote it all himself back in the day and documented how he grew the business. The old site was written in classic ASP and then migrated to ASP.net and now runs on .net core backend API and React.js Front end. He ran the site out of his condo.. servers were in his closet for many years. Didn‚Äôt hire his first employee until the site was already doing about 10 million a year in revenue. He sold it to Match Group a few years back while I was working there and is now a billionaire. Keeps a very low profile running a winery in Kelowna, BC. POF was his school project lol‚Ä¶ not bad. Super humble guy, grew up poor, built POF from scratch with no investment. He was a terrible programmer.. I had to fix all his original code and rewrite the site from scratch. What he was good at was SQL server. Most of the site business logic runs in very efficient and highly optimized Stored Procedures.",
                "points": "59 points",
                "children": [
                  {
                    "comment": "Thanks for the background ! I've been in the industry a while and it's amazing to see these absolute vast differences in team sizes per product. 1 very very good dev at efficient DB layer can make the world of difference in site scalability. I was tangentially involved with a large media site at one point that had pretty big traffic and the dev there was absolutely laser focussed on the db layer. Vs todays world a lot of people are like 'we need to go to web scale we need microservices'. And all of a sudden there's hundreds of devs....\n\nI've always had him in the back of my mind as 'he's arguably one of the highest revenue per developer devs on the planet'. That comment confirms it.. kudos to him even if his front end code was a bit shonky! lol.",
                    "points": "16 points",
                    "children": [
                      {
                        "comment": "Not a problem :) It is a fascinating business case and it was super cool to see how a major dating website ran behind the scenes. Really enjoyed the work that I did there and the team I worked with. There were only about 40 employees when I joined and all of them were rock stars. Learned a lot from that experience.",
                        "points": "3 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "Man, the terrible days where people figured you should put business logic inside of SQL servers. At my company we still periodically find servers with thousands of lines of PSQL ‚Äúcode‚Äù",
                    "points": "5 points",
                    "children": [
                      {
                        "comment": "Ha ha.. yep.. debugging issues was a nightmare. Thank god for Entity Framework.. there aren‚Äôt too many reasons to used Stored Procs anymore.",
                        "points": "2 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "More ChatGPT articles? And from the same source even?",
        "points": "96 points",
        "children": [
          {
            "comment": "I wonder how they get their upvotes. Probably bought",
            "points": "15 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "This newsletter is low-quality blogspam but I don't think it's GPT. It does seem to be a real person cranking out these low-effort articles with a different major brand in the headline every time.",
            "points": "2 points",
            "children": [
              {
                "comment": "Ah yes. Unlike voidstar articles.",
                "points": "-1 points",
                "children": [
                  {
                    "comment": "Is this a sarcastic jab at me I can't tell",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "It's not a great article, but it doesn't read quite like ChatGPT:\n\nThat means it acts as a central entry point for user requests to the infrastructure. And handles user authorization and security rules.\n\nChatGPT probably wouldn't use a period. When a comma is needed.",
            "points": "1 point",
            "children": [
              {
                "comment": "nice try, chatgpt",
                "points": "8 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "The goal of a good matchmaking app should be less swipes, not more. It's obvious that the goal of Tinder is to keep you lonely (and paying) as long as possible. Please save your money and mental health and don't use it.",
        "points": "52 points",
        "children": [
          {
            "comment": "As with all social media, the goal is to keep you engaged.\n\nWe all have control over that aspect of social media, though it's hard to exercise it because they use psychology against us. Understanding engagement is the goal helps break the cycle IMO.",
            "points": "12 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "This. You will lose all hope of you use tinder. And gets worse when you pay.",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Exactly. If they get so many swipes, it means almsot every swipe is pretty much worthless",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I really miss when Jane McGonigal was making headlines. I ‚Äúbumped into her‚Äù at the book store the other day (for some reason Technology was next to Self Help) and she has a little more shelf space than the last time I heard her name.\n\nHer idea was to use gamification for constructive instead of extractive purposes. That was a better time.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Where is the scalability issue with Tinder? I would the all the date would have very flexible consistency requirements, and the data can be easily partitioned by region or more. Even the incoming data can be partition across N number of Kafkaesque pipes.\n\nI didn't read the article, but am I missing something?",
        "points": "29 points",
        "children": [
          {
            "comment": "When you have an ugly user that everyone rejects, it will lead to high swipe count and very sparse data of actual approvals. So those ugly users could be partitioned into their own ugly DB for compressing the sparse data. When there is throughput issues in the system and the delay gets big, the client can simply use the best effort strategy: \"This user is so ugly, probably got rejected.\" That way they can keep swiping at a high rate, even during peak load.",
            "points": "42 points",
            "children": [
              {
                "comment": "uDb, uglyDb",
                "points": "18 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Where is the scalability issue with Tinder?\n\nI didn't read the article, but am I missing something?\n\nYou're not missing something and there is no interesting technical problem being solved.\n\nThis newsletter gets on the front page periodically with some version of the same headline every time, \"how $Brand scaled to $bignum requests per day\". The articles always recycle the brand's existing blog posts or technical publications to sound authoritative. But there's usually no real insight there, and programmers know that a billion requests a day against a highly partitioned or horizontally scalable design is not really a hard problem.",
            "points": "6 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Bots swiping each other, that's how.",
        "points": "7 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Can we all agree to stop measuring things in transactions per day? It both makes it sound huge and also ignores the real problem of what your peak operations per second are (4 am tends to really pull down the average).\n\nThey are averaging 18.5k/s which is pretty interesting. But I bet that‚Äôs peaking at more than 35k/sec, which is closer to the aggregate traffic of my last employers‚Äôs entire cluster before we memcached all the things.",
        "points": "7 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Does anyone actually spend $20 a week for unlimited swipes?? To me that just seems like an insane amount to pay",
        "points": "3 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "This blog takes potentially interesting topics and writes boring, surface-level \"explainers\" that aren't going to teach anyone anything useful about design.\n\nLike yeah, on one hand the unknown in the headline is obviously horizontal scaling through geosharding. But there's still plenty of interesting design blogs where the hook is less interesting than this one.\n\nI got baited again.",
        "points": "3 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "their dynamoDB bill must be high lol",
        "points": "2 points",
        "children": [
          {
            "comment": "Why so you think they are so expensive with their subscriptions.. üòÖü§™",
            "points": "0 points",
            "children": [
              {
                "comment": "Never used Tinder before, so.",
                "points": "0 points",
                "children": [
                  {
                    "comment": "Don't. If you are not depressed you will be after a while ü§£",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "How much you want to bet they are actually using kafka over dynamo",
        "points": "2 points",
        "children": [
          {
            "comment": "They literally mention how they use Kafka in the article, which I assume you did not read?",
            "points": "14 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Huh? Kafka is SQS in AWS land not Dynamo",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "horizontally?",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "What a poor article üòû",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Money.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "That‚Äôs just about 18.5k swipes per Second. Not that much actually",
        "points": "-1 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "it takes a lot of technical effort to bang an ugly chick",
        "points": "-13 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I'm single!",
        "points": "-6 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bijziq",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://mtlynch.io/zig-extraneous-build/",
    "title": "Why does a extraneous build step make my Zig app 10x faster?",
    "points": null,
    "comments": [
      {
        "comment": "If I know the maximum memory requirements of my Ethereum interpreter at compile time, I can outperform the official implementation by 3x.\n\nYou could reap most of the benefit by passing a maximum heap size as an argument, allocating that, and then using that as the argument to FixedBufferAllocator.\n\nIt would be a single allocation, so relatively fast -- you could even short-circuit the general purpose allocator and ask the OS directly -- and a fixed-cost overhead.",
        "points": "62 points",
        "children": [
          {
            "comment": "Oh, that's a good idea.\n\nI could get the performance benefits of the fixed buffer allocator, but it lets me defer the max memory decision to runtime rather than compile time.",
            "points": "24 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Pretty cool write up! I had no idea that bash pipes execute concurrently like that.",
        "points": "68 points",
        "children": [
          {
            "comment": "When I started my degree in ComSci, I remember there was a first year class that taught some applications like Microsoft Excel or something... I thought I would just sleep the whole lecture because I \"knew\" Excel already... to my surprise, they taught a lot of stuff I would never even have imagined Excel could do! By the end, I was really happy to have learned that stuff.\n\nMost people seem to have this attitude: we assume we know stuff just because we played around with it for a few hours :D but very likely you have very little idea what's really going on until you do a deep dive on the topic (either by taking a course or reading a book/tutorial/video whatever). The more ignorant you are, the more you will think you know the topic because you don't even know what kind of things you don't know yet (https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect).",
            "points": "43 points",
            "children": [
              {
                "comment": "When people claim they know excel, show them this: https://www.youtube.com/watch?v=yYaLQ3LazYM",
                "points": "18 points",
                "children": [
                  {
                    "comment": "This is like saying that you can't claim you are a carpenter until you build a boat out of toothpicks.",
                    "points": "15 points",
                    "children": [
                      {
                        "comment": "I think it more like showing a carpenter a boat built out of toothpicks. They will probably think its cool, and may even learn something.",
                        "points": "2 points",
                        "children": [
                          {
                            "comment": "Except carpenters don't build boats?\n\nI wouldn't want to be in a boat built by a carpenter.",
                            "points": "0 points",
                            "children": [
                              {
                                "comment": "And people that know excel don't build roller coaster animations in excel. So I don't know why you say \"except\" because it sounds like we agree.",
                                "points": "0 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Whenever people tell me they know Excel at the expert level, I just kind of prod them with topics most have never heard before.\n\nWhen people ask me what my Excel level is, I ask which part.\n\nExcel is so amazingly big, it's hard to speak about it as a whole. Might as well reference a topic as broad as \"literature\".",
                "points": "0 points",
                "children": [
                  {
                    "comment": "Last year I learned the R1C1 reference style and it was a real game changer. Stable formulas that don't rely on the auto-incrementation.",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "I always forget about that until I remote in to look at someone else's sheet. Back in 2011, I had a support ticket to Microsoft where changing between R1C1 and A1 lead to calcChain issues, so I avoid switching between the two modes.\n\nFunctions in that area are indirect/reference.",
                        "points": "0 points",
                        "children": [
                          {
                            "comment": "That's how I use it, via INDIRECT instead of changing the style.",
                            "points": "0 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I think it's something that people don't consider anymore since software is so powerful. Back in the dinosaur times, it was a lot easier to run into situations where the amount of data wouldn't fit in memory at the same time, and might not even fit on disk if it had to save it between commands. Pipes were a way to get around that necessity.",
            "points": "4 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "It's obvious if you use tail -f from time to time.",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "make that a comptime 2000 bytes, and you will do even better.",
        "points": "1 point",
        "children": [
          {
            "comment": "Can you show a diff of what you mean? Here's the relevant code:\n\nhttps://github.com/mtlynch/eth-zvm/blob/8d1f234ab94587b9feebcac2ecc3e0f89904aa76/src/main.zig#L6-L8\n\nMy intuition is that comptime can't beat a stack allocated buffer because the memory still has to exist somewhere at runtime, but I'm new to Zig, so maybe I'm missing something.",
            "points": "0 points",
            "children": [
              {
                "comment": "I'm on my windows machine, but something like this. The comments will be more correct, since it has been a hot minute using zig. But you are saying the word that its a \"stack allocated buffer\" so maybe fixed array buffer is not on the heap *shrugs*\n\n```var buffer: [2048]u8 = [256]u64{0} ** 8; // fill a comptime sized array with 0 bits. this is entirely on the stack.```\n\nWhat I would do next is run this through kcachegrind and look through the callgraph to see where percent estimate of functions is spent and see if program startup is the next major bottleneck.\n\n**Edit**\nFurther edit, remove all the timer and logs stuff. You can always run `time` on your binary",
                "points": "1 point",
                "children": [
                  {
                    "comment": "Thanks! I'll try it out.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "[deleted]",
        "points": "21 points",
        "children": [
          {
            "comment": "Eh, I hate crypto just as much, but honestly the article has nothing to do with Ethereum. And while it's somewhat basic, it does cover some very good to know stuff.",
            "points": "21 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Thanks for letting us all know",
            "points": "16 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bijx0r",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.azilen.com/blog/product-development-methodologies/",
    "title": "Product Development Methodologies [Inspired by Hannibal & Rome]",
    "points": null,
    "comments": [
      {
        "comment": "This tactical innovation can be associated with creativity and problem-solving skills.\n\nBut what‚Äôs more tactical innovation was ‚Äì bridge-making for elephants while crossing the Alps!\n\nThese examples don't really seem to teach meaningfully lessons. While Hannibal did achieve amazing feats, most of his elephants died in the process of getting to Rome. He didn't even use them in the initial attacks on Rome. When he did use his elephants, they back fired immensely (they literally ran into the direction of Hannibal's army).",
        "points": "3 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I understand the desire to take a historical leader and relate it to software concepts, but I feel that better messages can be taken from Hannibals military achievements. Maybe the usage of having a strategy before committing to a plan, or the importance of moral in a team.\n\nI feel the article just wants to use Hannibal because he is a \"cool\" person, but doesn't really go into meaningful lessons from the actual story.",
        "points": "3 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bijako",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://techcommunity.microsoft.com/t5/microsoft-developer-community/how-to-install-github-copilot-in-visual-studio/ba-p/4088771?WT.mc_id=academic-0000-abartolo",
    "title": "How to Install GitHub Copilot in Visual Studio",
    "points": null,
    "comments": [
      {
        "comment": "Requires Visual Studio 2022 17.5.5 or later.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1bii91u",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://yzena.com/2024/03/build-system-schism-the-curse-of-meta-build-systems/",
    "title": "Build System Schism: The Curse of Meta Build Systems",
    "points": null,
    "comments": [
      {
        "comment": "The previous 16 tools all got it wrong, but surely your 17th one will get it just right.",
        "points": "81 points",
        "children": [
          {
            "comment": "yes, however it will be written in brainfuck, and will require the configuration in malbolge.",
            "points": "6 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Well, if nothing else, it will get it right for me. :)",
            "points": "27 points",
            "children": [
              {
                "comment": "it will get it right for me\n\nI'm failing to understand why people like to take this self-centered approach only when it comes to building C++ and C code, and this is not a good thing. Open source code is built for other people and the build system working for you and only you is a problem. Having to learn the N+1th custom build system does no good for anyone.",
                "points": "5 points",
                "children": [
                  {
                    "comment": "I both agree and disagree.\n\nThe problem is that build systems don't solve everyone's problems well enough. I would like to have the problem solved well enough to standardize.\n\nI promise that I put in the effort to do so. I spent three years on this, and the design doc is over 500 lines of text.\n\nAll that said, I hate CMake enough that I would avoid it in any case, even if it was standard.",
                    "points": "2 points",
                    "children": [
                      {
                        "comment": "I vastly prefer CMake not only because it is the most used in spaces where usage can be quantified (i.e. open source projects), but also because it is practically the only usable cross-platform build tool that has at least 2 decade's worth of solutions to related problems. From my experience, it's also very easy to discuss issues with the CMake developers and to get your changes in following that.\nThis further exacerbates my confusion when people decide to roll their own.",
                        "points": "5 points",
                        "children": [
                          {
                            "comment": "Fair enough.",
                            "points": "0 points",
                            "children": [],
                            "isDeleted": false
                          },
                          {
                            "comment": "The \"cross platform\" thing creates way more problems than it solves. The whole thing becomes so complex that not even a comprehensive, readable manual for CMake exists. Just layers upon layers of ad hoc \"magic\" which is not understandable any more.",
                            "points": "0 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "That's literally impossible unless everyone uses the same build system. This is a governance issue. Just use rust.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "never do anything if anyone's tried before",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "slightly related XKCD",
            "points": "-7 points",
            "children": [
              {
                "comment": "It‚Äôs fully related",
                "points": "16 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "This is what I was referencing",
                "points": "9 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "As the legend goes, Stuart Feldman was working at Bell Labs, and he had a problem.\n\nI expected this to continue \"Then he invented Make, now he has two problems\".\n\nWell, I guess that something made him loathe to give up Make because he chose the latter and made Autoconf.\n\nNow we have three.",
        "points": "40 points",
        "children": [
          {
            "comment": "Don't be dense, cmake also exists! üòâ\n\nWe have four problems!",
            "points": "13 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I‚Äôm pretty sure build tools are combinatorial not additive. So by autoconf he has five problems.",
            "points": "10 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Heh, Make was good for its time.\n\nAutoconf, though, I agree; it was a problem from the start.",
            "points": "10 points",
            "children": [
              {
                "comment": "\"Congratulations, you're not running Eunice.\"\n\n...and it was born after a series of messes too.",
                "points": "3 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "The article is interesting, and it covers some points really well, but seems to miss the ugly part of some key points and remains optimistic which makes me wonder what will turn out.\n\nI actually believe you don't need Turing Completeness in a build system. As a matter of fact a key feature of any build system is that it has to actually build the thing, and if it can build it, then it must halt, and you can't guarantee that on a Turing Complete system.\n\nThat said it's not easy, and Total Functional programming langauges are still to find a way to be pragmatic to use, and no one has mapped those to build system languages, IMHO.\n\nThe thing is, the challenge is, in a simple mistake that I keep seeing build systems do:\n\nSo what if you didn‚Äôt need to specify all of the dependencies of a target? What if you could find them during the build itself using the source code itself?\n\nAnd the author answers it themselves:\n\nbecause <language> has a built-in build system and good module support.\n\nThough I would change that into:\n\nbecause <language> has a build-in requirement to define dependencies explicitly in code.\n\nIn C/C++ each file doesn't define dependencies. Sure we have header files, but header files aren't dependencies, they are just common definitions. Header files are a pre-processor hack, you could copy paste all the definitions in yourself, and you'd get files that have 0 explicit dependencies. And the compiler doesn't even care, it just generates .o files and calls it a day, each one with their implicit dependencies, it's only when you get to the linker that you see what is going on. What files do those .o files need? Only the linker knows! Actually no, not even the linker, the linker just knows what names need implementations, but it has no idea where they are.\n\nWell maybe that was C/C++, but modern languages haven't got that issue right? Well lets talk Java, a language were you have dependencies that you only need to compile the code, that you only need at runtime, and that you need at both! Which is which? Who knows, run the code and see if it breaks! Is it too bloated and you want to shrink it? That's not the java way! Don't be silly you just ship the entire SunOS!\n\nAnd see there's the thing: if you want to be grow into a great looking, big, strong adult you can't just eat cake you also have to eat your veggies, uhm sorry, right advice for the wrong group. Let me try that again: if you want your build to be sane, you have to list your dependencies explicitly somewhere.\n\nHere's my hot take: if you want a general build system, you have to explicitly define dependencies in it, statically. You can have tools that generate these dependencies for languages that are explicit, but I would say that autoconf got it wrong: these tools shouldn't be run as part of the build process, but instead they should be pre-ran on any code-change, enforced by a CI system for modern things. If you think about it that was the genius of make: each step gets explicitly created as artifact files, which mean you don't need to rerun it each time. This also means it's a lot easier to reason about what the build system is doing because you can see the dependencies. So when I update my go project and try to submit a PR, my CI system says that my build-files are showing a diff when they run the godeps (or whatever) tool, so I run it locally, see the diff, realize that I forgot to explicit add some files/dependencies, and then commit that to my PR which then gets submitted. If my project where C or Java though, the only way to be 97% sure is to compile and test.\n\nWe can do a minor improvement, we can allow our build system to define a dynamic tool that generates the dependencies, but then this means that this tool is required for any dependency/build analysis (consider that you don't need compilers, linkers, or any other external tool to be able to do this normally, so it goes out of the way). It makes the tool more complex and has some gotchas for the engineers setting up things to work with it, but it's not an unreasonable tradeoff, that one is a matter of opinions. It also means that planning a build may not terminate (since we're calling arbitrary Turing machines now) which is a bitch to debug, since you have to work off an incomplete, and broken action-tree, but there's ways to make this work it just adds more complexity to the tool (which now has to isolate and define the problem well enough) but it doesn't make the model or what the developer is doing more complex really.\n\nBut you can't have dependency analysis for free on every language. Because we can only easily tell what we didn't find, but have no idea to know where to find it, it's hard to give a good error other than \"when compiling we can't find <the thing> you should go and find it and give us that dependency\".",
        "points": "41 points",
        "children": [
          {
            "comment": "As a matter of fact a key feature of any build system is that it has to actually build the thing, and if it can build it, then it must halt\n\nHow much does this really matter? What are you trying to achieve by ensuring that the build terminates by construction?\n\nI mean, even in a language that only supports bounded iteration, I can still write a program that will run for longer than I will be alive. From my perspective, such a program will never terminate.\n\nAnd, at least with builds, I feel that we generally have some protection against infinite loops in our build definition. If I run a build interactively and it seems to be taking too long, I'll kill it. And all automated build infrastructure has some way to specify a timeout. So practically, all builds will terminate... though some might terminate with \"timeout_exceeded\".\n\nGiven those practical matters, what more do I get from a non-Turing-complete build language?",
            "points": "9 points",
            "children": [
              {
                "comment": "This is a great point, there's a pragmatism involved. What I am saying is that there's no value in a build-script that cannot terminate by construction, so we can focus entirely on the subset of programs that terminate.\n\nAn ideal build language is expressive, but also non-Turing complete. In practice it's really hard to do, and it certainly is easier to just take a Turing program and then bound it by some reasonable timeout.\n\nBut the important thing is that build languages do not need to be Turing complete, but they may need to be so expressive as to make it completely impractical1 to not have Turing Completeness.\n\nBut it should be clear that it's a very different thing to say \"you must have this feature\" to \"you don't strictly need it, but it's a way worse experience without this feature\". By admitting it's about accessibility and making it easier for humans, it makes the compromises and decisions we make much more reasonable.\n\n1 I mean could you imagine if you needed to do a Coq proof in order to allow your build to run? Yeesh.",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Another detail here: Build Systems a la Carte doesn't quite cover a key difference between suspending and restarting schedulers. If you have a lot of CPU to throw around, restarting schedulers can be even faster. Take Bazel, it's meant to work with a system where the builds happen in the cloud. So whenever you have a \"step\" to run in your tree, you allocate a container-job that will return the id of the artifact you need to download (be it a previously existing one or a new one). As you wait for your dependencies to compile, you can spend quite some time just waiting and taking up resources. But if you decide to be optimistic and assume you have enough to begin your build, if you happen to be right you could save a lot of time, and if you happen to be wrong, then you never really lost more time than you would have otherwise. You do lose some CPU, but at scale the time you save in Eng-Hrs due to slightly faster compile times makes up for it. When building locally though it is super-wasteful and it's better to be lazier and wait until you are 100% certain what the job is (the suspending scheduler).\n\nThis makes me think that there might have been a hidden lesson on the meta-build systems. If we see a build-graph (as defined by whatever config you have) as a tree, a build system is a Hylomorphism which first unfolds (through a anamorphism) the config-tree into a build-plan (which itself is a tree of dependencies and actions) and then folds (through a catamorphism) into an artifact (and the cache is just memoization here). This makes me think if we could get some insight into just how much power we need (without going full turing) a build system needs by using recursion schemes (for those curious here's the ending of a great intro to the subject which links to all the previous parts) and if anyone has done anything here.",
            "points": "9 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "In the Visual C++ world, there's a #pragma you can put in a header file that tells the compiler to write a note to the linker that tells the linker that a certain library must be linked with.",
            "points": "2 points",
            "children": [
              {
                "comment": "Agree there's great ways to add this. I think I'd be fine with a build system that lets an external tool describe what the dependencies should be based exclusively on the sources, it adds an extra step but it's not too bad. Having it baked directly into the build system is limiting it too much to work only as the author imagined it. Like it or not the reason people still use Make is that it assumes very little of how it should be used.",
                "points": "0 points",
                "children": [
                  {
                    "comment": "I think I'd be fine with a build system that lets an external tool describe what the dependencies should be based exclusively on the sources, it adds an extra step but it's not too bad. Having it baked directly into the build system is limiting it too much to work only as the author imagined it.\n\nI agree.\n\nRig will be able to do that. It has to in order to handle #include in C, so I made sure to make it more general.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "But you can't have dependency analysis for free on every language. Because we can only easily tell what we didn't find, but have no idea to know where to find it, it's hard to give a good error other than \"when compiling we can't find <the thing> you should go and find it and give us that dependency\".\n\nThat might be true of Java & C++, but lots of languages have the property where you can find every imported file and symbol by parsing the source. Stop using ancient languages!",
            "points": "2 points",
            "children": [
              {
                "comment": "That's why I said \"on every language\". I mean if I have to rewrite millions of heavily battle tested, very reliable LoC to change to a new build system.. I probably won't.\n\nAlso in some environments things like runtime-injected dependencies are a feature, not a bug. And while I don't really have a tender part for a lot of JVMs decisions: I feel it's over-engineered to improve 20% of the use cases at the cost of the other 80%, when you're in that 20% it is really wondrous.\n\nI can totally see problem spaces where the way you configure things is by defining which dependencies you bring forth, and this is very common in a build system even when compiling things differently. Imagine a build system that allows cross compiling, but also chooses different implementations of some core library based on the platform, there's ways to abstract that away and let the automated dependencies work, but you still have to be able to define which file is for which platform at some point.\n\nSo in conclusion: sometimes you want that \"let me tell you which dependencies to use\" as a feature, and your build system will need to allow it once you go into non-trivial situations.",
                "points": "0 points",
                "children": [
                  {
                    "comment": "Just so you know, I completely agree with you.\n\nRig's targets can take static dependencies, and that will not change. Ever.\n\nIn fact, they are a bit more useful. You can build an array of dependencies, and then just put the array name in the dependency list. Every item in the array will be a dependency of the target being created.",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "Yeah I got that perception from the article. I mean I honestly agree with a lot of your viewpoints and would love to see what comes out of it.",
                        "points": "1 point",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I don't love this:\n\nSo when I update my go project and try to submit a PR, my CI system says that my build-files are showing a diff when they run the godeps (or whatever) tool, so I run it locally, see the diff, realize that I forgot to explicit add some files/dependencies, and then commit that to my PR which then gets submitted.\n\nThat's not much of a pain, but from the perspective of anyone who isn't a build-system nerd, it's a bunch of nonsense that I have to do that the computer should be doing for me. It's also not awesome to be having to review and check in generated code. So what are we getting from this?\n\nFrom seeing Bazel work well in a few places, I think we get an enormous amount of mileage out of making builds hermetic, even if they're still dynamic:\n\nWe can do a minor improvement, we can allow our build system to define a dynamic tool that generates the dependencies, but then this means that this tool is required for any dependency/build analysis...\n\nRight, but if you've actually captured all of your dependencies on some level, then it's not much of a burden making that tool available -- ideally, the tool is itself a build artifact, and its outputs are cached along with all other intermediate build artifacts.",
            "points": "2 points",
            "children": [
              {
                "comment": "I don't love this\n\nThat's more than fair, as I said I see it a bit as a purist and based on my experiences: I like being able to see explicitly what files the build system is taking, without having to go and look and reason how each language defines its dependencies dynamically. But I also think it's not that bad and it could go the other way.\n\nit's a bunch of nonsense that I have to do that the computer should be doing for me.\n\nSet up a pre-commit git-hook that does it for you and then it becomes completely transparent (in that you don't have to use it, but it's easy to see what the tool is doing behind the scenes in the commit diff).\n\nSo what are we getting from this?\n\nSeparate concerns deserve separate definitions, even if by coincidence they happen to be the same thing. DRY is not about not repeating pieces of code, but rather not redefining concepts. The external (as in imported from some library) definitions my code use are strongly related but not the same thing as the libraries themselves which these definitions must come from.\n\nBut again I do see this as a bit of a purist take and I don't mind allowing dynamic takes.\n\nFrom seeing Bazel work well in a few places, I think we get an enormous amount of mileage out of making builds hermetic, even if they're still dynamic\n\nFunnily enough my experiences come from working a lot in Bazel at a previous job. And the philosophy at Google is generally to move away from dynamic dependencies and have everything be explicit, because it helps other engineers maintain your code better (e.j. to see all users of your library you only need to grep all BUILD files in the monorepo to see who explicitly uses your dependency, otherwise you'd have to build a reverse dependency graph which requires building the whole mono-repo which, last I remember, was being replaced to just use a cloud-service that keeps track of the whole build graph because it was such a pain already).\n\nThe first programming language that had a tool to update the dependencies was golang with a tool called glaze and yeah, unless you did some weird thing, it was automatically ran for you as the equivalent of pre-commit (if you skipped it, a CI guard would catch it though).",
                "points": "1 point",
                "children": [
                  {
                    "comment": "I have replied a lot to you. Sorry! :)\n\nJust so you know, that's not because I disagree. In fact, I think your comments are the most nuanced, and therefore insightful, on my post.\n\nI like being able to see explicitly what files the build system is taking, without having to go and look and reason how each language defines its dependencies dynamically.\n\nThis is making me feel better about Rig's design.\n\nI designed Rig to get out of the way and to let the user do what they want.\n\nThis includes having static dependencies, as I mentioned in another reply. I just didn't mention that Rig can also do static dependencies in the post.\n\nThe syntax looks like this:\n\ntarget \"some_file.o\": \"some_file.c\"\n{\n    $ @(config_str[\"cc\"]) -o @(tgt) @(file_dep);\n}\n\n\nOr if you want an array of files to build:\n\nsrc_files: []str = @[ // ...files here\n];\nforeach f: files\n{\n    target f +~ \".o\": f\n    {\n        $ @(config_str[\"cc\"]) -o @(tgt) @(file_dep);\n    }\n}",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "Set up a pre-commit git-hook that does it for you and then it becomes completely transparent (in that you don't have to use it, but it's easy to see what the tool is doing behind the scenes in the commit diff).\n\nYou mean I have to check my code into git before I can build it? Hard NO.",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "Then set your editor to run it for you on any save of code.\n\nI mean at this point you're just making it complicated. It's 2024, most development process include a set of tools to automatically lint, format, etc. code as you go. It's not that hard to set up the tool. Of course in some companies they can set up the IDE for you, it's a matter of your preference too.",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "I think this was about some static analysis like ‚Äúwhen the CI server rebuilds your package manifest it should get a result that matches the one you checked in, otherwise the CI run fails.‚Äù\n\nFundamentally this should feel just like any other lint, unit test, or formatter step you can run locally via a script wired into a pre commit hook but will definitely want your CI server to confirm before marking a commit as passing.",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Author here.\n\nI actually believe you don't need Turing Completeness in a build system.\n\nWell, I am going to publish a whole post detailing why Turing-completeness is necessary, but as a small taste, did you know that you cannot build LaTeX without a Turing-complete build system?\n\nLaTeX iterates until a fixed point. You may set it to iterate a lot of times, and that will find a fixed point most of the time, but it does not work every time.\n\nSo a general build system does need to be Turing-complete to build LaTeX.\n\nAs another taste, did you know that Starlark and Meson, which both claim to not be Turing-complete, actually are?\n\nAs a matter of fact a key feature of any build system is that it has to actually build the thing, and if it can build it, then it must halt, and you can't guarantee that on a Turing Complete system.\n\nI do agree with this.\n\nBut one thing my post does not mention, because it is for next week's post, is that my build system will have a way of restricting it to a non-Turing-complete subset. This will actually be default.\n\nYes, I know Turing-completeness is ugly. Trust me. I have 4000 words already written about Turing-completeness.\n\nIn C/C++ each file doesn't define dependencies.\n\nYes, and this is a problem, but it can be hacked around.\n\nMy build system is in C, and once I add dynamic dependency support, I'm going to use a \"magic comment\" in every file to say what targets need it.\n\nCan it still have problems? Sure; I still need to compile and test. But the source of truth is actually in the source like other languages.\n\nAnd I'm building a language that has dependency information in the source, like Go.\n\nWe can do a minor improvement, we can allow our build system to define a dynamic tool that generates the dependencies, but then this means that this tool is required for any dependency/build analysis\n\nWell, if the build tool is Turing-complete, just build the tool in the build system itself! Then no tool is needed. :)",
            "points": "8 points",
            "children": [
              {
                "comment": "Fix-point semantics do not require Turing completeness. Look at Datalog, for example.",
                "points": "3 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "LaTeX iterates until a fixed point. You may set it to iterate a lot of times, and that will find a fixed point most of the time, but it does not work every time.\n\nAh I see the misunderstanding here. A Build process must be Turing Complete, because compiling some languages is a Turing Complete process (and in theory there could be a scenario where it never finishes compiling, it's impossible to be certain).\n\nTo me that's separate of the Build System whose job is to define what the Build Process must do (as in list of compilation steps etc.). What I mean is that creating a Build Plan should be a process that always halts, therefore benefits from not being Turing Complete.\n\nThis is also why I prefer tools updating the script rather than the build process running tools to generate dependencies. Because in some languages finding dependencies might be a Turing Complete process that sometimes never finishes (impossible to know) and in that case you can't make a build plan. But it's a pragmatic compromise (and if you want to be a purist you can see as the build system first build step is building its own explicitly defined build plan, but by keeping everything together you can optimize that you can start building things even as you haven't finished the whole plan).\n\nAs another taste, did you know that Starlark and Meson, which both claim to not be Turing-complete, actually are?\n\nNot surprising, it's very hard to make a non-turing-complete language that is non-trivial.\n\nI am familiar with Starlark and it does some things to guarantee that it halts, so it achieves this non-Turing completeness by arbitrarily refusing to run certain otherwise valid programs. And yeah, I agree that isn't strictly enough, we might as well say that all computers are non-Turing complete because they have finite memory (you can solve the halting problem with finite memory for example, it's just impractical). A build could take a huge amount of time due to code that takes too long to fail.\n\nBut one thing my post does not mention, because it is for next week's post, is that my build system will have a way of restricting it to a non-Turing-complete subset. This will actually be default.\n\nI'd be interested in learning more about this, some languages have done interesting things but I haven't seen a build system openly do this compromise.\n\nMy build system is in C, and once I add dynamic dependency support, I'm going to use a \"magic comment\" in every file to say what targets need it.\n\nThat's fair, it does put the onus on the language itself, and may limit how many languages port into your build system, but it's an interesting choice certainly.\n\nPersonally why not consider the \"allow an external process to get the dependency list\" way, with an explicit list allowed sometimes? That way users can choose what is best for them, if the solution is ls *.c to get all dependency files, why not?\n\nWell, if the build tool is Turing-complete, just build the tool in the build system itself! Then no tool is needed. :)\n\nFair, but I do think there's a value in allowing \"plugins\" or just external systems that extend the command. The advantage is that you don't have to reinvent the wheel for your language. If golang already has go list and even go mod graph why not reuse those instead of reinventing the wheel. You'd still need a bit of code to map their output into the input your tools expect, but it should be very doable in your language.\n\nAlso with your magic comment C, it's just another tool that people can use on their own, extend, or change. Meanwhile people could use clang -da (or something like that I don't remember off the top of my head how the dependency analyzer works, I'd have to read a lot of docs) and could begin experimenting with the realities of dynamic dependency generation.",
                "points": "3 points",
                "children": [
                  {
                    "comment": "To me that's separate of the Build System whose job is to define what the Build Process must do (as in list of compilation steps etc.). What I mean is that creating a Build Plan should be a process that always halts, therefore benefits from not being Turing Complete.\n\nIn an ideal world, yes.\n\nUnfortunately, as said in the post, CMake was not Turing-complete at first. Now it is. There's a reason for that; sometimes, it is even necessary for building the build plan.",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "Oh yeah I agree in the pragmatic view. That is, it's incredibly hard to not make a PL that is powerful and expressive enough but not turing-complete. And there's the argument for usability (could you imagine if people had to write a Coq proof of their build config?) which I think is very reasonable to argue that it's better to not fight Turing-Completeness.\n\nBut I also feel that it's important to enter this with an acknowledgement that Turing Completeness is not the goal, but rather a shortcut that must be managed. That the language avoid features that make it easy to have unbounded recursion or infinite loops, sure it might be possible to do so, but it shouldn't be easy.\n\nThat said from what I've read on your posts it seems you have the right attitude here. Proposing a non-turing, trivial and minimal system by default, with some \"escape hatch\" to go into a more powerful super-language that can also result in foot-shooting is a very very reasonable take.",
                        "points": "1 point",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "With the amount of time you spent debating C/C++ build systems, you could have just switched to rust. The lack of a first party build system can't be hacked around. It's fundamentally a governance issue.",
                    "points": "-1 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Defining dependencies in the code file is, IMO still explicit. The only thing that changes is where you define them. Is it in CMakeLists.txt or directly in the source? There really isn't any difference.\n\nWhat about include paths for C/C++? How would you do those, if not explicitly defined? I do not want every directory with an .h file to be in the include path. In fact, it is actively detrimental to the way I structure my projects.\n\nWhat about custom linker scripts and linker include directories? How would you deal with those? Every change in the linker script, or files it includes, should trigger linking in the build, regardless of other files changing.\n\nWhat about code generation? Say, generate source from Protobuf descriptions? Which needs a protoc plugin?\n\nWhat if, say, my project builds ten executables, and they all have the exact same dependency list? I don't want to repeat myself after all.\n\nIn the end, this all boils to one thing: a system that does something for a human must either be perfect (impossible) or predictable. And if it's predictable, people will (ab)use that predictability to force certain actions. Might as well just make it closer to actual programming at that point.",
                "points": "1 point",
                "children": [
                  {
                    "comment": "In the end, just use rust",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "And all of that is why Rig is Turing-complete so that it is closer to actual programming.\n\nTo answer, I think there is a difference. The closer to source that something is defined, the more accurate it is likely to be. Like doc comments.\n\nSecond, Rig will be capable of DRY even with computed dependencies. It has a build database that build code can store stuff in. When running a build, all of your executables can look in the database for it and dynamically add those depebdencies.",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "Rig being your new build system?\n\nOne more edge case: what about files which nothing depends on, but are critical do the build? Like files which only contain interrupt service routines and nothing else? Especially if an alternative version of that function is defined as a weak symbol in another file which already *is* part of the build?\n\nI'm not saying it's impossible to have automatic dependency detection. I'm just saying that there's a gazillion edge cases you need to handle and you will be debugging and twiddling with that till the end of times.\n\nAnd if those dependencies have to be written out explicitly, than honestly there is little difference if they are in code or in a separate file. You still have to go somewhere else (top of the file, different file, doesn't matter) and add that dependency.\n\nYour argument about being closer to code being more accurate IMO doesn't hold for specifying dependencies in a build system, because if those are *not* specified, something will break. And in case of missing dependencies, it will break visibly, during build. At least in the languages I'm familiar with, from other comments Java seems to be some sorta weird edge case here.",
                        "points": "0 points",
                        "children": [
                          {
                            "comment": "Rig being your new build system?\n\nYes, sorry, the name is mentioned in the ad in the post.\n\nI'm not saying it's impossible to have automatic dependency detection. I'm just saying that there's a gazillion edge cases you need to handle and you will be debugging and twiddling with that till the end of times.\n\nAnd this is why Rig will be Turing-complete.\n\nRig will have a standard library that will take care of 99% of everything. For that 1%, it will not get in your way.",
                            "points": "0 points",
                            "children": [
                              {
                                "comment": "As someone who spends a lot of my time in that 1% (all the edge cases I listed earlier are from my day job) I'm worried about rules made for the 99% screwing me over.\n\nAlso: what is your plan for CLion integration?",
                                "points": "1 point",
                                "children": [
                                  {
                                    "comment": "As someone who spends a lot of my time in that 1% (all the edge cases I listed earlier are from my day job) I'm worried about rules made for the 99% screwing me over.\n\nThat's a valid fear.\n\nRig's standard library will be opt-in. You won't get that 99% behavior unless you explicitly call it.\n\nIf you sit down and wrote a standard Rig build file, it will act a lot like POSIX Make. Well, it will once I implement raising errors when certain keywords are used.\n\nEdit: And as for CLion...\n\nRig already has primitive support for build configurations. First, I would expand that out.\n\nI would just have Rig generate a Makefile that calls into Rig with the given build configuration. Then CLion can use the Makefile.",
                                    "points": "0 points",
                                    "children": [
                                      {
                                        "comment": "I'm not familiar enough with Make to know the differences between POSIX and GNU. In fact, I've only ever used Make a few times. University was largely VS, and after that I went directly for CMake. My biggest Makefile to date is building an Asciidoctor document with graphs made using Graphviz",
                                        "points": "1 point",
                                        "children": [
                                          {
                                            "comment": "I'll put it this way: Rig was built from the fire of my loathing of CMake. Rig was designed to be more out of your way than CMake is.\n\nAs an example, Rig will not automatically generate a command-line for compiling a C file. Its own build creates a command line from scratch using data about what options exist for the compiler.\n\nTake this poor soul:\n\nI literally just need the build system to COMPILE code. You know the most important part of any C build system? COMPILING code. Not dependency management. Not checking if my compiler works on my dev platform. NOT producing *** code for windows, mac, or linux machines. CROSS COMPILATION ONLY.\n\nI literally found that comment about when I started designing Rig, and it's been my north star ever since.\n\nEdit: I've been evangelizing too much. Sorry. I think it may be best for you to ignore Rig when it comes out unless you're actually curious. I'll shut up now.",
                                            "points": "1 point",
                                            "children": [
                                              {
                                                "comment": "",
                                                "points": "",
                                                "children": [],
                                                "isDeleted": false
                                              }
                                            ],
                                            "isDeleted": false
                                          }
                                        ],
                                        "isDeleted": false
                                      }
                                    ],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "magic comment\n\nThis was my first thought about dynamic deps in C.\nLooking forward to see your implementation!",
                "points": "3 points",
                "children": [
                  {
                    "comment": "I am sorry to say that the magic comment thing won't exist at release. I don't have support for dynamic dependencies yet.",
                    "points": "-1 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "My build system is in C, and once I add dynamic dependency support, I'm going to use a \"magic comment\" in every file to say what targets need it.\n\nHow about a companion file that lives right next to it? Eg: if you have \"HelloWorld.c\", its companion file would be \"HelloWorld.deps\". That would avoid the \"ick\" factor of having comments that aren't just comments. It would also work for languages that use different comment syntax.\n\nAlso, did you mean to say \"what targets it needs\" instead of \"what targets need it?\". Because if you have to list which targets need it, what happens if you need to use a library that you're not allowed to edit? Eg: because its source code is not available to you, or because it's from a package manager?",
                "points": "0 points",
                "children": [
                  {
                    "comment": "The companion file idea is also good, and my build system could do that too.\n\nAlso, did you mean to say \"what targets it needs\" instead of \"what targets need it?\".\n\nIt is confusing, but I meant what I said.\n\nThis is for the case in my repo alone, where what is built depends on the configuration and it's in C where the location of a particular item could be anywhere. In that case, the best location for dependency info is where the item is, even if it's backwards.\n\nBut Rig will be able to handle both directions.",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Compilers are also written in Turing-complete languages but that does not mean that systems using them need to be Turing-complete as well.\n\nAnd for the case of LaTeX, there exist tools which do exactly that. A \"LaTeX compiler\",if you want si.\n\nIt is also completely normal that systems layer a declarative part over more complex internals. This works well when done well, it reduces complexity and THIS IS A GOOD THING.\n\nLaTeX is also a special case because a reference in a introduction can refer to a page number in a later chapter which could be 2 or 3 digits, and this extra digit could change all subsequent line breaks - and therefore the page number it us referring to. This is not a normal property of programming languages or linking of object files - they are built in an unidirectional flow for good reasons. LaTeX is super successful and its user interface is purely declarative. Good luck typesetting your documents in C instead.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "As another taste, did you know that Starlark and Meson, which both claim to not be Turing-complete, actually are?\n\nAs the author of Meson, I'd be interested in knowing why this is the case.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I actually believe you don't need Turing Completeness in a build system\n\nTuring incompleteness is such a boring property. The C programming language is Turing incomplete if you add to the spec that any program that runs for more than 1000 years exits. Yawn.\n\nIt says absolutely nothing about the quality of a DSL in terms of its capacity to write clear and correct build descriptions.",
            "points": "0 points",
            "children": [
              {
                "comment": "Turing incompleteness is such a boring property. The C programming language is Turing incomplete if you add to the spec that any program that runs for more than 1000 years exits. Yawn.\n\nI mean in that definition all software is Turing incomplete, because programs have limited memory and they can run out of it, while Turing completeness requires infinite memory.\n\nThe argument is petulant and sets up a straw-man. Worst of all, for all intents and purposes this is how all build systems work right now, they just timeout, which means they are a kind of Turing Incomplete, but no one would consider it as such. When we talk about Turing Incompleteness we are talking about the language running on a virtual machine that is mathematically defined as Turing Incomplete.\n\nYou can't just add to the C spec \"the C VM will halt after 1000 years with an error\" because there's no mathematical meaning to \"1000 years\", that concept is a physical one, and neither the spec, nor the VM have it implicit in their definition (there's no definition of how fast the machine runs, we can assume each step is instantaneously fast except for actions that explicitly wait a non-instantaneous duration of time).\n\nThis is why I brought up, and linked to the definition, of Total Functional Programs. They are non-turing by a simple mathematical definition: they are a subset of Turing Machines that can be guaranteed to halt. Now how to define all possible Total Functional Programs, and not a subset, is a whole ongoing problem: turns out you can still have loops, and recursion, but just not every kind.",
                "points": "3 points",
                "children": [
                  {
                    "comment": "It says absolutely nothing about the quality of a DSL in terms of its capacity to write clear and correct build descriptions.\n\nYou have not addressed the portion of my comment which challenges the presumed link between Turing (in)completeness and usefulness. This is the most important part.\n\nbecause there's no mathematical meaning to \"1000 years\"\n\nThen define it as a tremendous but finite number of VM steps. Talk about straw-manning... üôÑ\n\nAlso, the C programming language has specified a clock function since 1989, but whatever...\n\nwe are talking about the language running on a virtual machine that is mathematically defined as Turing Incomplete.\n\nThe variant of C I sketched is 100% mathematically defined as such. Do the same thing for, say, Standard ML and have the rules count the depth of the inference tree and cut that off. There's a bunch of mathematically sound ways to place a temporal limit on a language. As soon as that is established, you know that all programs halt.",
                    "points": "-3 points",
                    "children": [
                      {
                        "comment": "You have not addressed the portion of my comment which challenges the presumed link between Turing (in)completeness and usefulness. This is the most important part.\n\nLets start with what I said in my first post:\n\na key feature of any build system is that it has to actually build the thing, and if it can build it, then it must halt, and you can't guarantee that on a Turing Complete system.\n\nI guess what what you really are tying to ask here is \"why would this be better than just having allowing turing machine code with a bounding, why go for something more?\"\n\nI guess you've never ran on a machine that set arbitrary limits that you can't move and that really grind your gears. Never had to debug a build system that is failing to build because someone put a stronger CPU constraint that makes a specific step go a bit too slow and timeout now.\n\nYou know what's better than having broken/bugged code crashed? Not being able to even write broken/bugged build code. Once you understand the simple language of the build system, you can do whatever you want and it'll work. With bounded turing-complete code you have to learn about timeouts and how to change those bindings when it make sense and adds all these things that require the resident build expert to chime in. The language structure itself hints at how to write efficient code.\n\nDid you know that Skylark was originally just raw python? But they had to disable and limit a lot of the macros/equivalents because it would spiral out of control. There's subtle changes in skylark that drive developers to write not quite python, and instead code that tends to be more efficient.\n\nAnd in this area there's more than turing-incompleteness to make it worth the while. Things like purity (or hermeticness of build in bazel speak) I think are more valuable. And again I think you can take a stance to make it really hard to get the full turing-completeness to backfire by careful design, while still not preventing a y-combinator.\n\nThen define it as a tremendous but finite number of VM steps. Talk about straw-manning...\n\nI get what you're saying, but there's a reason the C spec doesn't even define a stack. It goes out of its way to ensure that the definition is mathematically Turing Complete. It does have considerations for what happens when the code runs in a machine that isn't Turing-Complete (like every physical real computer in the universe), but it doesn't make the VM like that, for a good reason.\n\nAnd yeah, certainly many build systems, and even static-parts to the language like Rust's macro system do use exactly what you say to make things non-turing complete.\n\nAlso, the C programming language has specified a clock function since 1989, but whatever...\n\nI'll quote myself:\n\nwe can assume each step is instantaneously fast except for actions that explicitly wait a non-instantaneous duration of time\n\nThat wouldn't include the clock function though, it can very well return 0 in the world I proposed.\n\nThe variant of C I sketched is 100% mathematically defined as such\n\nYes but it misses the point. Since computers have finite memory you can run a program while keeping track of the whole memory of the machine (including registers, including hardware stateful information, including the memory of computers connected through the network, which might include the whole internet, etc. it gets big). Once you see two equal states of memory you can know, 100% that the program has cycled. No matter how long the program takes, because the number of valid memory states is finite (no infinite tape after all) you will eventually iterate through all possible states, at which point if the program hasn't halted, it must cycle. Therefore the halting problem can be solved. As for the scenario that Turing proposed: the oracle has to be bigger than the program it analyzes, if the oracle analyzes itself analyzing itself, it will simply run out of memory, so it always halts due to crashing because otherwise it'd cycle until it runs out of memory, halting. Basically finite memory means any program can halt, cycle or go OOM and that makes all the difference.\n\nBut do we care when we say that C is Turing complete? Same thing with purity: it's pedantic to say that stack allocation is a side-effect (though here it has an implication).",
                        "points": "1 point",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "if you want your build to be sane, you have to list your dependencies explicitly somewhere.\n\nbut i don't wannaaaaaa",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I actually believe you don't need Turing Completeness in a build system. As a matter of fact a key feature of any build system is that it has to actually build the thing, and if it can build it, then it must halt, and you can't guarantee that on a Turing Complete system.\n\nYes, that's the key. Turing completeness means you can write complex stuff in it which may or may not be what a build system should aspire to (in contrast to a programming language. Some things are just inherently complicated; if you have a language that cannot express complicated ideas then you couldn't program such things in it, which generally is a bad thing for a programming language. But a build system's purpose isn't to express arbitrary codable ideas. It's to.. run a build).\n\nMore crucial, various systems and tools need to continually reason and analyse exactly what a build script means. An IDE needs to just insta-pick up any change to the build definitions that, say, adds a dir that is marked as containing source files, or changes the version of the language the source files in some srcdir are targeting, or adds a dependency, you name it. This requires not 'just' \"run the whole build every time the build file is modified in any way\", because that's usually simply not feasible, or at least highly annoying, as builds tend to take vastly more than the ~2 seconds (and I'm being generous there) before programmers go do other stuff while they wait and lose the flow (insert XKCD here).\n\nThat's why in general I go: Neat! New build system! Oh, it's turing complete? Well, nevermind, I'm not touching it, it's probably shit.\n\nI understand it's a rule that is bound to sort some wheat with the chaff, so to speak, it is quite simple (because the build systems that are TC tend to advertise it clearly).",
            "points": "1 point",
            "children": [
              {
                "comment": "That's why in general I go: Neat! New build system! Oh, it's turing complete? Well, nevermind, I'm not touching it, it's probably ***.\n\nYeah, I hear you.\n\nRig will not be Turing-complete by default. You'll have to opt-in to it.\n\nThe default will allow nothing beyond what POSIX Make can do.\n\nI understand it's a rule that is bound to sort some wheat with the chaff, so to speak, it is quite simple (because the build systems that are TC tend to advertise it clearly).\n\nHeh, yeah...guilty.\n\nBut here's the thing: I wrote this to solve problems. If it doesn't solve your problem, you shouldn't use it.\n\nAnd it probably won't, to be honest. When it comes out in two weeks, just ignore it. Sorry for the noise.\n\nI know that as a creator, I'm liable to want to evangelize, so I have deliberately chosen to say \"You shouldn't use Rig\" as much as possible.",
                "points": "-1 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "A much simpler way to put it: it sucks when a programming language does not have an officially supported build system.\n\nAll of the weird issues with building C and C++ are because no one is in charge of making builds work well. Every build issue can be explained away as ‚Äúyou‚Äôre doing it wrong‚Äù.\n\nI really respect how languages like Go and Rust have one way to build and if that doesn‚Äôt work well you can file a bug report and actually work towards an official solution.",
        "points": "32 points",
        "children": [
          {
            "comment": "This is true.\n\nHowever, there is a caveat: what if you need those languages to work together? How do you build them together?\n\nA general E2E build system with dynamic dependencies can do that.",
            "points": "9 points",
            "children": [
              {
                "comment": "Even if you could get everyone to use Rust or Go, eventually your build needs to interact with the real world!\n\nWe can artificially say that my dependencies are just files but in reality, I want to rebuild my code whenever a GitHub dependency is updated or whenever the SQL server version is changed, etc. The design document is a dependency, too!\n\nYou can erect a boundary and say that your build system properly handles all dependencies within it but the location of that boundary was arbitrary.\n\nI agree with you: we need a general build system with dynamic deps.",
                "points": "3 points",
                "children": [
                  {
                    "comment": "If you need a custom build script in rust, you just modify build.rs which of course is all written in rust. So It is general. Your use case sounds like a leaf node anyways. The boundary might be arbitrary, but if a library doesn't Just Build when you add it as a dependency, then no one uses that library. And if no one but you is building your code(AKA, leaf node in the dependency graph), then by all means make it as weird as you want.",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "It also sucks when a programming language does have an officially supported build system because it never covers all cases.\n\nIf we all agreed we only develop on unix and for unix then I think we could work this out. But my wristwatch has a microprocessor in it and there's just no way to build for it using a system that only knows how to generate code for unix.\n\nAnd then if you do say \"well we'll run on unix but target everything\" then you build out you can't maintain your build system because it's too much work to target everything with every change.",
            "points": "0 points",
            "children": [
              {
                "comment": "An official build system is still better than nothing in that case. If you want to support a weird build target you know exactly what to do: fork the build system.\n\nWhat benefit do you get by throwing out all the rules and saying anything goes?",
                "points": "2 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Having control over the build process is a godsend the moment you want to insert something nonstandard into the build process. Just last week I wrote an experimental preprocessor to extract #shader...#endshader blocks from my source code, convert the text between to a quoted string and insert a statement at the #glinit marked location to create the shader at runtime.\n\nBecause I was in charge of the build process, effectively using the compiler as a library instead of a framework, I was easily able to insert my preprocessor before the compiler, and only for the source files that need preprocessing. If I wanted to do this in Java (and I have before), I'd have to copy the entire source folder, since the Java compiler acts more like a framework, or write some compiler plugin using undocumented interfaces; alternatively, I could process the whole object folder after it was compiled (which is easier in Java than in C++).\n\n(You can argue about whether it's kosher to extend the language like this instead of putting your shaders in separate files, but the process to embed those separate files in your executable also involves custom commands in the middle of your build process, so it's moot.)",
            "points": "2 points",
            "children": [
              {
                "comment": "You can customize your rust build by modifying build.rs, which is written in rust. So you can make it as weird and complicated as you want.",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "The whole way C works makes it extremely painful to have a real packaging system. Ifdefs and the devs that love them make the job tricky. Which isn't to say it would be impossible.\n\nRust has basically achieved the best that can be done on this front. By still pulling down source but doing so in a structured manner rather than having \"here's a bunch of headers, source files and appropriate preprocessor defines that have to be cobbled together\".",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "This article misses a major feature of a (meta) build system: Can my IDE of choice open a project using this build system?",
        "points": "5 points",
        "children": [
          {
            "comment": "That is perfectly possible in an E2E build system. Mine will eventually generate native IDE files that call into my build system.",
            "points": "2 points",
            "children": [
              {
                "comment": "Some IDEs don't have \"native\" files and integrate with build systems directly (through some kind of API provided by the build system). For those it is necessary to create a plugin that does that.",
                "points": "1 point",
                "children": [
                  {
                    "comment": "Fair. I am willing to do the work should users require it.",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Counter point: why should build systems accommodate the IDE? Why can't IDE's be general enough to allow opening a project by its folder? This is how text editors like VSCode and Sublime Text operate. With open protocols, like the LSP and DAP, they can provide IDE quality features.",
            "points": "0 points",
            "children": [
              {
                "comment": "Because if my project autogenerates code, my IDE needs to understand that in order to provide autocompletion (possibly via LSP) for the generated code.\n\nProjects also might:\n\nset include paths, important for autocomplete.\ndownload dependencies, also important for autocomplete\nset compiler flags (e.g. language version, toggling warnings, etc) which is relevant for warning/error reporting within the IDE\ninclude different implementations based on OS / env vars / whatever. IDE needs to understand which is the currently selected implementation",
                "points": "0 points",
                "children": [
                  {
                    "comment": "It sounds like the issue is configuration: header search paths, pre-processor definitions, etc. Perhaps the better solution is an open file format that is specifically for communicating project configuration to a text editor. Imagine a JSON file (or the like) that is checked out with the repo or dynamically generated at configure time that is read by the text editor when \"open folder\" is used. It could provide immediate project configuration, build targets, header search paths, etc. It is sorta like a project file, but IDE agnostic.\n\nThis is hypothetical of course and your points are valid for the current state of affairs.",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "Thing is, a description using such a format would replicate information already in the build system's configuration.\n\nprogrammers hate repetition\n\nAnd even if you solve that, e.g. by having the build system generate that file, it will still be bare bones. As an example, let's take a typical Qt project: You create some .ui files with the Designer from which header files will be generated. Of course you want, whenever you change a .ui file, the IDE to regenerate that header automatically so that your changes are immediately available for autocompletion. For this, the IDE needs to know the relation between header and .ui file, and how to generate that file. Other SDKs and environments have similar workflows. I don't think it's viable to build a standardized format that supports this in a sensible way.",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "That's interesting. I'll share some of my opinion following opinion regarding how Nix could be a build system (one that I actually use, but not for compiling C files): - Nix have a really nice approach to things. Hashing both the input and the input lead to a really good way to cache stuff, and declaring all inputs allow to have cloud builds too. - One downside is that you can't do early breakoff. But recent work allow to rewrite the hash in the output based on its input to a hash based on the output content, which now allow for early breakoff. - There are two reason I believe Nix can be too generalized: - Performance issue (it can have to parse and run many source file and build the dependancy graph. But actually it's still shorter than running autoconf in most projects) - The fact that it is conceived in a way that most dependancies come from the build itself. For exemple, you will need to use gcc of NixPkgs (or the package you manually create. But that's inpractical). Actually, every inputs are added to the cache be it from your code repo or dependancies fetched from internet (or a cloud cache).\n\nn But first and foremost the reason not to use Nix for building sources as you describe is the lack of tooling\n\nStill, some things that can be done include: - Using one compilation units per crates in Rust (by parsing the Cargo.toml and lock file and directly calling rustc) - Split a video files into each of their frames, and upscale them individually (something I use to build by animated wallpaper where the source is a not very high resolution GIF) - Build a whole operating system (or a container containing said os). It's what NixOS and NixPkgs does, and the way it's meant to be used.\n\nFollowing those reflection, I don't thing Nix in particular can make a really good build system, but I do think that a E2E build system that use hashing could be very good.\n\n(maybe one day there will be a Make2Nix, so hashing could be used with Make. It'll be very good at detecting hidden dependancy, and might also be usefull for CI with it's caching)",
        "points": "3 points",
        "children": [
          {
            "comment": "What if I told you that my ultimate goal for Rig is \"Nix for mere mortals\"?\n\nBecause it is. :)",
            "points": "1 point",
            "children": [
              {
                "comment": "This pleases my soul",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Author's lessons about make being designed in a weekend:\n\nSimple implementations lead to disasters, and\nBreaking compatibility is sometimes necessary; do it as early as possible.\n\n\nThe \"disaster\" here is that Make requires Tabs for indentation :D\n\nSorry but no. Maybe you don't like that, but it works, it does the job. It's NOT a disaster, or even a bad decision.\n\nAbout breaking compatibility: that's the last thing you want from your build system. Make got it right. Gradle has it wrong. I've had to update my builds so many times over the years that next project I need a build system I will use anything but Gradle. I already wrote my own build system just to avoid Gradle!",
        "points": "17 points",
        "children": [
          {
            "comment": "You must be me; I had to use a third-party system that only supported Gradle. My choices were to port the entire (open source) system to something other than Gradle, or embed it in another framework by writing out a basic build script and replacing the compile step with cp -r. I chose the latter.",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "It's NOT a disaster, or even a bad decision.\n\nlet me know what happens when you copy and paste that info.",
            "points": "-2 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I like make. It's pretty simple especially for custom rules. I tend to use POSIX make since ever but now I also go with GNU make when needed. I mean I convert custom files with just like\n\n%.h: %.png\n    bin $< $>\n\n\nOn POSIX you use .png.h and add the extensions into .SUFFIXES.\n\nWith CMake, meh. You create a list that you iterate to call add_custom_command. You create a list with all output generated and add them as dependencies to an other target. But yes, at least it's portable.\n\nAnother gripe: if I use CMake to cross compile then I no longer build host executables to be ran at the same time (e.g preprocess, tests). Again, with Make it just basically using CC and an other macro (e.g. HOST_CC).\n\nGNU make is really powerful enough for most situations. The main problem is lack of tool support and... Windows. There are various projets that are built with pure GNU make with no hassle.\n\nOther than that, I still recommend CMake for portable uses even though it has various warts.",
        "points": "8 points",
        "children": [
          {
            "comment": "Cmake is ugly. I hate that syntax. It also generates an ugly build.\n\nScons has the nicest syntax so far because I already know python.",
            "points": "4 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Another gripe: if I use CMake to cross compile then I no longer build host executables to be ran at the same time (e.g preprocess, tests). Again, with Make it just basically using CC and an other macro (e.g. HOST_CC).\n\nYou can use CMAKE_CROSSCOMPILING_EMULATOR and run the executables in qemu, c-spy or any emulator or simulator of your choice. I do this with embedded ARM code; coupled with semi-hosting and they can even use the local filesystem and terminal I/O. Perfect for unit and integration testing, code generators, tools etc.",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "It would have been nice to have a quick explanation what a suspending or restarting scheduler is without having to go read yet another paper, but that's okay.\n\nI've never worked on large software myself but hear tell of the baroque build systems they engender. If/when you need Turing completeness, to me that says you should use a proper scripting language, preferably one everyone knows and likes, which I suppose means Python or Javascript these days. It will be interesting to see what Gavin's answer is here.\n\nEven though Make usually meets my modest needs, we can obviously do better than anything in popular use right now so I look forward to April 2. I just hope the cloud component is optional because I am not working with other programmers or even in a company.",
        "points": "1 point",
        "children": [
          {
            "comment": "It would have been nice to have a quick explanation what a suspending or restarting scheduler is without having to go read yet another paper, but that's okay.\n\nTime crunch, sorry.\n\nBoth schedulers are for the case when the build system runs a target but is then told about dynamic dependencies while running the target.\n\nAssume at least one of those dependencies is not satisfied.\n\nA restarting scheduler will wipe away all trace of having executed the target. When the dependency is satisfied, it will start execution of the target all over again.\n\nA suspending scheduler will suspend the target, fulfill dependencies, and start executing the target from where it left off.\n\nIt will be interesting to see what Gavin's answer is here.\n\nA general-purpose programming language that I have been designing for 12 years.\n\nRig has zero dependencies; using my own language is the only option for that.\n\nBut have no fear; it looks sane, probably somewhere between Rust, Zig, and Nim.",
            "points": "1 point",
            "children": [
              {
                "comment": "Thanks, I appreciate the quick explanation of scheduling.\n\nI'll take your word for it that your own language is the right solution here. You've done far more thinking about it than I have, and I don't really care for Python or Javascript anyway; one of them just seems like a natural choice if you had to pick an existing one. Thinking a moment longer, imagine if this was 25 years ago--Perl may have been the 'obvious' choice then, but look where it is now!\n\nGood luck.",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "However, there seems to be some wind shifting; there is a new type of build system coming to town.\n\nThat is not accurate. Direct build system, or what the article calls end to end, have existed for decades. And existed before cmake at least. Look into Perforce Jam. Or B2, previously Boost Build, which is the one I've been maintaining for more than 22 years.",
        "points": "1 point",
        "children": [
          {
            "comment": "Coming back to town.\n\nI was writing from the perspective of people who know nothing other than meta build systems.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Cmake doesn‚Äôt exist because Make sucks, CMake exists because Make doesn‚Äôt work on Windows. If you‚Äôre only targeting Systemd-based systems, then sure, you probably can suffice with Make.",
        "points": "1 point",
        "children": [
          {
            "comment": "I think you meant Unixy systems. Make certainly does not require systemd and it never will. Also, there are at least three ports of Make to Windows. One is Visual C++'s nmake, and the other two are msys and cygwin.",
            "points": "2 points",
            "children": [
              {
                "comment": "Historically, even that wasn't enough. Fortunately we don't have loads of weird Unixes anymore, each broken in different horrible ways. There's a reason autoconf goes through contortions to do its job, e.g. it couldn't even use functions in its configure shell script. You really did need a complex tool to figure out what OS-level functionality was available and in what form.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I stopped using C++ in 2012 and it's kinda funny and kinda sad that the state of the art is exactly how I remember it.\n\nAt the time there was another promising CMake-alternative called Premake which let you write arbitrary Lua to generate your makefiles / vcproj files. But I think it never really took off.\n\nBut anyway for you C++ users out there, you should know that you are holding on to an ancient & unfixable ecosystem. There are so many better options today, and so many problems (including build systems) are solved or at least drastically improved. You don't actually have to spend your days solving self-inflicted puzzles to things that your customers don't care about.",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I half-expected the article to talk about Boost and BJam (where, in order to build the system, you first need to build the build system).",
        "points": "0 points",
        "children": [
          {
            "comment": "Author here.\n\nThe same would apply to mine, so I decided to not throw those stones. :)",
            "points": "1 point",
            "children": [
              {
                "comment": "If you don‚Äôt mind a small suggestion: using left aligned text would make your article a lot more readable.",
                "points": "-1 points",
                "children": [
                  {
                    "comment": "Hmm...I do prefer justified. But I bet I can make a toggle that can switch to left justification.",
                    "points": "2 points",
                    "children": [
                      {
                        "comment": "That‚Äôd be great. The uneven spacing and the lack of ragged lines makes it harder to read, at least for me.\n\nEdit\n\nActually, reader view in Firefox automatically set the text to left flushed, so all good.",
                        "points": "0 points",
                        "children": [
                          {
                            "comment": "Oh good! I haven't had the time to test reader view. I'm glad it works.\n\nI'll still consider that toggle, though...",
                            "points": "0 points",
                            "children": [
                              {
                                "comment": "I understand you prefer justified text, but I‚Äôd recommend to do a little research instead. Most if not all article would recommend using left alignment for body text.",
                                "points": "0 points",
                                "children": [
                                  {
                                    "comment": "Maybe. But books are justified, so there seems to be disagreement.\n\nMaybe what I need to do is only use justification on desktops where the lines are plenty long to avoid the HUGE hole problem.",
                                    "points": "0 points",
                                    "children": [
                                      {
                                        "comment": "Books and magazines using justified text because it looks more polished, especially in case of multi column layout, it has nothing to do with readability.\n\nIt was a mere suggestion. In the end, it‚Äôs your article, you should do what you think the best for you and your audience.",
                                        "points": "1 point",
                                        "children": [],
                                        "isDeleted": false
                                      }
                                    ],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Should've also discussed sbt (Satan's Scala Build Tool)",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "This article doesn't do enough work to define a meta build system to justify its claims. There's no reason you can't metaprogram buck/shake/bazel/etc. build specifications.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "No IMake? I remember working with IMake back in the 1980s and thinking \"It doesn't get much worse than this.\"\n\nThen it did.",
        "points": "0 points",
        "children": [
          {
            "comment": "Author here. I am too young to remember IMake. Sorry.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I wonder why SCons is classified as meta buildsystem. It looks more like an E2E buildsystem in nearly all the mentioned categories.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "There are two interesting developments in this space.\n\nOne is to create packaging systems which use and support a variety other more basic build tools to build system distributions. Some of them are made in a way that the same tools support building of programs in development and managing arbitrary dependencies, especially Nix and Rust.\n\nAnother is the development of a model different to make. Make (and nearly all colleagues) use a text file that describes a dependency graph mixed with build instructions which are shell commands. A completely different way invented by D.J. Bernstein is to turn this inside out into a shell script which executes build commands as well as commands that describe dependencies between artifacts. This is what the \"redo\" family of tools does, and I think they are clearly superior to make as base tools. (But they do not replace things like autoconf which answers the question which dependencies and flags to use). redo mixes better with immutable and reproducible builds, and can be faster for development since it captures dependencies more correctly (no \"make clean\" just to be safe). But maybe in the end, \"make\" is good enough. It is not really a problem to build a program - managing its dependencies is, which Guix does solve well.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  }
]