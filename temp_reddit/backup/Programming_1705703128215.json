[
  {
    "id": "t3_19avik7",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://plainenglish.io/community/sharing-a-state-between-windows-without-a-server-48b990",
    "title": "How to Share State Between Browser Windows",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19aveqk",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "http://reddit.com/r/programming",
    "title": "Question — How to Use If-Then Statement to Add Valies to a CSV File (R and Python)",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19au1zr",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://coursegalaxy.newzenler.com/courses/data-structures-algorithms-java-masterclass",
    "title": "Data Structures and Algorithms In Java (DSA Masterclass)",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19atudk",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/",
    "title": "The CAP Theorom Twelve Years Later: How the \"Rules\" Have Changed",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19atnvm",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://blog.readyset.io/a-developers-guide-to-the-cap-theorem/?utm_campaign=eg&utm_medium=social&utm_source=reddit",
    "title": "The Role of CAP Theorem in Modern Day Distributed Systems",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19asf2n",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://stannedelchev.net/playing-windows-98-error-sounds-when-a-build-fails/",
    "title": "Playing Windows 98 error sounds when a build fails",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19as4mm",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://news.ycombinator.com/item?id=39057005",
    "title": "Voxos.ai – An Open-Source Desktop Voice Assistant",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19arphx",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://newsletter.eng-leadership.com/p/starting-my-career-again-as-a-junior",
    "title": "Starting my career again as a junior engineer",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19aqfpy",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://medium.com/@kova98/humans-are-shit-replace-them-with-tools-a063a1ab1b77",
    "title": "Humans Are Shit — Replace Them With Tools",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19aq459",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://github.com/mukulbindal/fishbowlpy",
    "title": "Please review the initial draft of my first open source project",
    "points": null,
    "comments": [
      {
        "comment": "All in all, it looks very nice.\n\nI would recommend you to include the text in this post to the project's readme (I was about to ask what's fishbowlapp after reading the repo).\n\nClasses like DriveType could be defined as enums.\nType annotations could be a nice addition.\nMaybe you'll be able to attract developer among the website community easier than in python.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19aq1sy",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://crystal-lang.org/2024/01/19/windows-support-1.11/",
    "title": "Windows support in Crystal 1.11",
    "points": null,
    "comments": [
      {
        "comment": "As someone who really likes ruby and also likes finding type errors before runtime, Crystal is super interesting but I haven't tried it. How does it compare to some of the efforts to bolt static typing onto ruby? Outside of type stuff, does crystal have other advantages?",
        "points": "-1 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19apzjh",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://face2id.org",
    "title": "Face2ID - Transform Biometrics to UUID Fast",
    "points": null,
    "comments": [
      {
        "comment": "Is this even possible? Any function from a connected space (face pics for example) to a disconnected space (like the finite set of UUIDs) is either constant or discontinuous, so two very simmilar faces (or pics of the same face) are gonna map to different UUIDs",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19apb8o",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://blog.devdetails.com/p/monoliths-microservices-and-serverless",
    "title": "Monoliths, microservices, and serverless aren't what you think they are",
    "points": null,
    "comments": [
      {
        "comment": "we have an architecture like monolith C and it actually works \"surprisingly\" well. The biggest limitation is the single point of failure postgres, but as we have migrated to other datastores, the mere fact that it's the same codebase running in a bunch of different modes/ways does not hinder us [much]. it is tricky right-sizing test suites, making sure the right tests run under the right circumstances, but the same exact complexities still exist with microservices. If anything, integration testing across microservices is more difficult than what we deal with today.",
        "points": "14 points",
        "children": [
          {
            "comment": "Yeah. It's been a transition phase for me many times going from monolith to microservices.\n\nOnce you have the infrastructure in place to scale horizontally and service routing, you can start strangling a few APIs at a time to a new, focused code base.\n\nOr sometimes never transition to microservices at all. Many times a distributed monolith is good enough.",
            "points": "2 points",
            "children": [
              {
                "comment": "one thing holding us back right now is that auth is fully handled inside of the monolith, so it has to act as the autenticating proxy to other services, which feels super jank, almost like a reverse monolith strangulation. definitely feels off.",
                "points": "0 points",
                "children": [
                  {
                    "comment": "I’ve done this several times. I introduce an API gateway and move coarse grain authz there. You can do it one API at a time. First pass can have the gateway call the monolith to do authz logic. Future passes can move authz out of monolith.\n\nIf you have fine grained access control, move that out too. That’s a bigger discussion.",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "we're annoyingly also latency sensitive so i'd rather not add another hop in front of every monolith call.\n\nit's very likely/possible that we go that route you're describing, but im also investigating \"libraryizing\" auth and letting each service be its own entry point (unfortunately that does imply some shared storage layer, though each can have their own local cache)",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Thank you! Yes, sometimes a series of small, single-purpose machines still is coupled tightly to their back-end database service. The mere format of the single-purpose machine makes no statement whatsoever about how tightly or loosely it couples to other components.\n\nIt is a major point of critique to the onslaught of microservices that got created under the pretense of easier maintenance: no, you didn't solve the coupling, so any change to your database model will still require a change in your clients. It doesn't matter whether that's a monolith or a myriad of small apps.",
        "points": "42 points",
        "children": [
          {
            "comment": "My company has like... 140 services running now? Many with one instance only, some with 2-8, but yeah, loads and loads of individual services. They sit in like a handful of data-centric clusters where they might as well all be one service except maybe one component that sits separately to allow for scaling.\n\nIdk why. Makes updating/deploying a huge PITA.",
            "points": "18 points",
            "children": [
              {
                "comment": "140? Those are rookie numbers, my friend. We have a single team with 70 services.\nAt least they are verticals, so they can mostly be deployed independently, but it’s still way too overkill.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Whenever I see architectures that started as microservices, on inspection, they're really tightly coupled, distributed monoliths. It's often a single team. Sometimes with dozens of \"services\". So, they get none of the benefits of microservices, but all the overhead.\n\nI prefer to start with a modular monolith, then transition to a distributed monolith, then transition to microservices when and if it makes sense for team organization.\n\nMicroservices solve an organization problem more than they solve a technical one.",
            "points": "27 points",
            "children": [
              {
                "comment": "How do you handle communication in a modular monolith? Queues, in-process communication, …?",
                "points": "1 point",
                "children": [
                  {
                    "comment": "Most of the time the modules don’t need to talk directly to each other. Ex: Users module doesn’t need to talk to Projects. But I need to filter projects to the logged in user. The user identity comes from a JWT — not by asking the User module.\n\nThe rest of the time it’s through queues.\n\nThe relatively rare times direct communication is needed, I use an abstraction that I can swap out with something like gRPC later.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "This is why I like the monorepo approach. You are basically a monolith that’s setup to be broke apart (with effort) since you’re distinguishing functionality, but still interconnecting them through imports and such.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I have severe PTSD from Microservices.\n\nI just look at what our team done and i wanna cry.",
            "points": "11 points",
            "children": [
              {
                "comment": "One org I worked for, it would take over a week to deploy a simple change to a micro service. It just slowed things down tremendously.",
                "points": "5 points",
                "children": [
                  {
                    "comment": "that's insane, one of the pros of microservices should be how easy/quick deploys are, must be maddening to deal with something implemented like that",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "They don't solve coupling problems in the first place. But they do solve bus factor problems, which can hit hard if it is a part of monolith. I go microservice because I'm misantrop and think other people are shit and should hold their shit to themselves. And die together with their creation. Elasticsearh was good, became cluster fuck of various small products, sql is just nightmare, rabbitmq....better be dead in the first place and list go on.",
            "points": "-2 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I don't think coupling is even a reason. I like micro services because they are disposable. We have core services and leaf ones that typically represent a single partner. Partners come and go. It is nice to throw their little integration pieces in the bin after they part ways without touching anything core.",
            "points": "0 points",
            "children": [
              {
                "comment": "That’s coupling…with a partner. It’s a loose coupling between the partner and the rest of your services. The loose coupling is what makes it easily disposable. That’s a good practice.",
                "points": "1 point",
                "children": [
                  {
                    "comment": "As I said it isn't about the coupling. It is that I can kill that integration without bringing the world down. Just with a simple stop command.\n\nI dislike monoliths because of how hard it is to throw shit away.",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "Feature flags achieve the same result with a lot more simplicity.",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Vertical Slice Architecture solves this",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Before chiming in, look at the 3 diagrams which ask:\n- Which is a monolith?\n- Which are microservices?\n- Which is serverless?",
        "points": "5 points",
        "children": [
          {
            "comment": "tl;dr biggest misconceptions\n1. Sometimes, you don't have microservices; you have a tightly coupled, distributed monolith.\n2. Microservices can share database infrastructure as long as you keep it loosely coupled. Pragmatic > Dogmatic (yes, this contradicts #1)\n3. FaaS is not the only kind of serverless. Actually, it's not even the most used.",
            "points": "9 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Blindly responding:\n\nA and B are the same thing, just B is scaled up more. Both simple monoliths.\n\nC is just... I have no clue what's going on here. Even ignoring the fact that i'm not 100% sure what \"q\" is supposed to be (I'm assuming some sort of queue?), this is definitely \"bizzarechetecture\". Still i'm inclined to call it a monolith just because of seemingly shared app code, but without any clear indication of what's a client or server I can't really be sure what it is.\n\nServerless... it's impossible to say given these diagrams other than \"Probably not B\", as even though B could represent the actual situation for a serverless application you probably wouldn't draw the diagram like that in this case.\n\n(Coming back up, I realize there are multiple diagrams, that's what i get for replying on a blind reading)\n\nReading further down\n\nor does it extend to the SQL database?\n\nWell, this is a question of context really. In the most normally assumed context the answer is \"no\". When we ask \"Is it a monolith\" the \"it\" we are referring to is the application business logic created by the developers. You can take other contexts of course, but there are enough to call both everything and nothing a monolith.\n\nSomeone told me, \"You can’t scale a monolith horizontally. You can only scale it vertically.\" That seems silly because I’ve scaled huge monoliths across hundreds of small servers.\n\nAgreed, that quote is dumb\n\nMicroservices.... any of these diagrams could be microservices. I'd even argue from an application developer standpoint A, B, and C are equivalent. The differemnce between these only really matters to those on the ops side of things.\n\nD lets you do a little more with sharing databse rows between apps; but this architectural decision doesn't invalidate it being \"microservices\".\n\nAs an aside, I hate the name \"microservices\" and every time I hear it I instantly think \"no, a normal number of regular services will do fine\" which I am sure is a blackadder quote or something, I always hear it in Rowan Atkinson's voice...\n\nAnd yeah, your follow up analysis is the same as mine for ABC, but on D\n\nIf multiple applications own the same data, they are not microservices. If each application owns data isolated from data owned by other services, then they might be microservices.\n\nI think the key word here is \"own\". As long as it's well defined who is the owner and what operations that entails then both apps could access the same data and be microservices. There are even some good performance related reasons you may want to do this. Weather or not D actually works out in practice and doesn't die to \"quick hack to meet deadline, will fix later i promise\" is another question entirely.\n\nServerless....\n\nWell I don't see any servers in this diagram so...\n\n(And also Ithink \"serverless\" can be kidna a dumb word too, but for more subtle reasons than microservices)",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I think that's conflating services with code components.\nA monolith code can be loosely coupled, I wrote tons of those.\nServerless is just running code on machine managed by the cloud provider.\n\nOn a regular monolith, an user can use the whole app while the server code executed won't leave the server machine (except for db calls).\nWhen your internal logic starts to do IO to process a single entity (job/user), you fo further from the monolith and closer to the microservices.\n\nYes, I think what differenciate the 2 are IO calls.",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "What do i think they are?",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "honestly its a bit pointless to discuss. for example, serverless is stated as \"The abstraction of infrastructure management makes it serverless.\"\n\nbut obviously infrastructure management can be abstracted to various degrees, and you still have to think at whatever level of abstraction you decide on for yourself. so how is this useful?\n\nsame for microservice; \"Loose coupling and cohesion make it a microservice.\"\n\nwell, packages modules and even classes and functions can be loosely coupled. and no one can agree on what constitutes \"loose-enough\" coupling anyways; its more that we can identify when things are not loosely coupled enough and must bear the cost. so again; what is really being said here, how is it useful and how does it help inform our decision-making as developers?\n\nfinally for monolith we have; \"Tight coupling makes it a monolith.\"\n\nthis is probably the most confusing one because it means if you have a bunch of well-factored packages and modules you actually don't have a monolith, even if they're all bundled up into a single artifact and deployed together. why is that a useful mental model?\n\noverall, what I have noticed in this kind of technical is that there's almost no use trying to \"generalize\" anything like this in tech. whats good for me may be bad for you, and vice versa. anything that is \"true enough\" for every situation is generally too vague or not useful. we need to be more specific.\n\nRather than trying to pin down imprecise language whose meaning needs to be specially interpreted in specific contexts, its better to study case studies similar to the kinds of projects most relevant to us as developers, as well as our own projects, and try and improve upon past mistakes.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Someone told me, \"You can’t scale a monolith horizontally. You can only scale it vertically.\" That seems silly because I’ve scaled huge monoliths across hundreds of small servers.\n\nThat pisses me off to no end. I can staple a photograph of the \"scale out\" settings page in Azure to their forehead and they'll still repeat that lie.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I feel like everyone who complains about microservices were not given a working budget to include monitoring, auditing and orchestration (and if possible A/B or canary deployment strategies), yeah without those microservices are impossible",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19ap8ze",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.citusdata.com/posette/2024/",
    "title": "CFP is open for POSETTE: An Event for Postgres 2024, formerly Citus Con",
    "points": null,
    "comments": [
      {
        "comment": "Hi folks, Eren from POSETTE team here,\n\nI wanted to share that POSETTE: An Event for Postgres 2024 started accepting proposals for talks this year. POSETTE (Postgres Open Source Ecosystem Talks Training & Education) is the new name of Citus Con and it is a free and virtual developer event organized by the Postgres team at Microsoft, now in its 3rd year.\n\nIt's a great opportunity to share experiences for first time speakers as well as seasoned speakers. All talks will be pre-recorded and livestreamed during the event with live speaker Q&A. The CFP is open until April 7th and the virtual event will happen on June 11-13.\n\nYou can get more information and submit your talk proposals at https://aka.ms/posette-2024\n\nI highly encourage you to submit your talk proposals if you have any stories, perspectives, tips or expertise to share about anything related to PostgreSQL. Please let me know if you have any questions or comments. Thank you.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19aoxbk",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://blogsystem5.substack.com/p/from-0-to-1-mb-in-dos",
    "title": "From 0 to 1 MB in DOS",
    "points": null,
    "comments": [
      {
        "comment": "The 80286 has no MMU. The MMU is for paging, and was introduced with the 80386. The 80286’s goop is a couple extra adders and comparators, basically ALUs, the shadow and descriptor regs, and a bunch of microcode.\n\nAlso, VM86 made it possible to run even one DOS program at a time in pmode. You could run some, very limited sorts of DOS programs unmodified in pm16, in theory, but any attempt at supporting access to MMIO &c. or huge pointers bogged down immediately, and any use of real-mode BIOS or what have you required a full CPU reset—once in pmode, you had to reset somehow to exit, and if everything went right, you could get the BIOS to vector back rather than bootstrap normally. (Even LOADALL couldn’t fix that.)\n\nLater versions of DOS could load-high themselves, although maybe MemMaker did more than that.\n\nIt also bears mentioning that there can be memory mapped in the MMIO region under 1 MiB—e.g., an extended BIOS data area (EBDA), to complement the normal BDA at 0x400. Often these either ate a bit of memory at the top of conventional memory, or used mobo regs to map some of the RAM that’d otherwise be placed >1 MiB into the 0xD0000…E0000 range.\n\nAnd the >1-MiB map may have holes for MMIO or BIOS around the 16 MiB boundary (80286 max address), the 4 GiB boundary (80386–P5 max address), at the 64 GiB boundary (P6+ max address in 32-bit mode), etc. (48+ bits now supported), so the memory map kinda repeats at each expansion.\n\nUnreal mode was a technique on the 80386+ where you popped into pmode, set ES SS DS FS GS to flat-map the 4-GiB address space, and return to real mode. As long as you don’t reload the seg regs, their shadow descriptors remain unchanged, and you can access any 32-bit address through them. However, if a segreg is reloaded you have to reenter pmode to restore it.\n\nBecause XMS was kinda shitty but DOS per se was still useful, it became common to use DOS extenders (like DJGPP’s) that could run mostly in pm32 but hop into VM86 for use of DOS/BIOS. These were very common for games. On the API side of things, DPMI was offered as a means of playing nicely with DOS, HIMEM.SYS (which actually emulated DOS in VM86 mode), and Windows when running in pmode.\n\nFinally, most BIOSes for 80286 or later CPUs do offer a means of copying sub-64-KiB blocks of memory to/from the extended area. It’s slow and limited, but it works in a pinch.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19aoxaz",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://motherduck.com/blog/perf-is-not-enough/",
    "title": "Perf is not enough",
    "points": null,
    "comments": [
      {
        "comment": "\"Test your software the way customers actually use it\" seems obvious but apparently even Google forgets it.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19aox9s",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://thoughtbot.com/blog/handling-errors-when-working-with-external-apis#when-to-choose-a-resumable-strategy",
    "title": "Handling external API errors: A resumable approach",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19aox8m",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://subethasoftware.com/2024/01/18/c-and-returning-values-quickly-or-safely-but-not-both/",
    "title": "C and returning values quickly or safely. But not both",
    "points": null,
    "comments": [
      {
        "comment": "What a bullshit, there is no reference in C.\nPointers is just a variable which stores address. Everything is passed by value in C, even variables with address, aka pointers.\n\nMoreover, pointer size sometimes larger than some builin types, like char, short, int. Pointers takes up to 8 bytes (on 64 bits systems, and 4 bytes on 32 bit systems)",
        "points": "15 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Passing by value is slower, since a new variable has to be created\n\nMy understanding was that passing e.g. int vs int* would be the exact same runtime cost. What does it mean \"a new variable has to be created\" in terms of assembly? Copying something larger than word size would take longer, but if something is <= word size, shouldn't it be identical to the cost of pass-by-pointer?",
        "points": "12 points",
        "children": [
          {
            "comment": "The terminology used in this is... a bit sloppy. In C, everything is passed by value, including pointers. This is sometimes called \"pass reference by value,\" in contrast to \"pass by value\" and \"pass by reference.\"\n\nMy understanding was that passing e.g. int vs int* would be the exact same runtime cost.\n\nIt depends on what you mean by \"cost\", exactly. For example, on some systems, an int* is going to be larger than an int. But that doesn't mean that it's actually more expensive, or that it's significantly more expensive to the point where you think about doing this.\n\nWhat does it mean \"a new variable has to be created\" in terms of assembly?\n\nI don't think they're speaking with enough precision for me to understand what they mean, or that they simply have a misunderstanding.\n\nWhat is also sort of amusing is that, well, in an unoptimized build, well, just look: https://godbolt.org/z/b6fxx61Kj More work being done in the pointer case. In an optimized build, we have to change the function slightly to return the int in the by value case so that the whole function isn't optimized away to a simple ret, but: https://godbolt.org/z/19qbPr7dx Not a meaningful difference.\n\nActually giving it a bit more thought, I think that they are thinking in terms of \"some giant struct with a lot of stuff in it\" but are using int in the example. Which makes it just a bad example.\n\nTo show off that sort of example, it would look like this: https://godbolt.org/z/55fccoToK",
            "points": "11 points",
            "children": [
              {
                "comment": "Actually giving it a bit more thought, I think that they are thinking in terms of \"some giant struct with a lot of stuff in it\" but are using int in the example. Which makes it just a bad example.\n\nThis is what I mean by copying something larger than word size. If the thing you're copying is word size or less, it's going to be no more expensive than passing a pointer.",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Not necessarily. Depending on the ABI, passing an into or other data type that could fit in the same space as a pointer, by pointer may even be slower, because if you pass a pointer, the value has to be in memory, which can break some optimizations, as well as the fact that writing to memory is slower than keeping values in registers.",
            "points": "0 points",
            "children": [
              {
                "comment": "Sure, but doesn't that also refute the author's claim that passing the int is slower than passing the pointer?",
                "points": "0 points",
                "children": [
                  {
                    "comment": "It... Does though, depending on the ABI and other optimizations applied. Basically I'm just saying, 99% of the time you're not going to get faster code trying to micro optimize like this.\n\nPassing a structure by pointer? Sure, makes sense. Otherwise probably just not worth it to both we with this stuff unless you profiled it.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "This is slower, and consumes more memory during the process of making all these copies, BUT it’s far, far safer.\n\nWhat is frustrating about this is if C had scopes you could just tell (a good) compiler \"screw the ABI do the stack math for me, avoid copying, and just make this fast\" and it will, flawlessly... if you're using (modern) GCC/LLVM. They'll even make the debug information looks nice when everything is inlined.\n\nThis works GREAT... except it is non-standard so when you need to develop C for something that isn't a modern ARMv8/x86_64 CPU you can't use it. Which is most of C development.\n\nSo even if this did get standardized tomorrow, it wouldn't appear on your PICs devboard for 10-15 years.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I find the arguments very weak.\n\nPassing pointers? Authors concern is that pointers could modify content or be of the wrong time, both of which the compiler will prevent by const and type checks. The real danger is pointers pointing to null or invalid locations - or more subtile two pointers pointing to the same (or overlapping) region.\n\nPassing a list of pointers vs passing a pointer to a struct has the major benefit that this struct now becomes easily maintainable. Imagine you expand the struct by one more field.\n\nReturning static memory? Yes it’s fast, and valid. No, with const the user cannot modify the content. All good? No. What’s more dangerous is that another call to the same function may modify the static values, and hence the values you use somewhere else in the program (since the goal was to avoid copying, right?)\n\nReturning structs is as fast as a copy. The struct is created on the stack, there is no cost in memory allocation. Adding 16 or 1m to the stack pointer is the same speed. The caller will later then need to copy it from the stack to his variable (likely also on the stack). but only once.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19aovra",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://onlinelibrary.wiley.com/doi/10.1002/spe.3313",
    "title": "On-demand JSON: A better way to parse documents?",
    "points": null,
    "comments": [
      {
        "comment": "If your requirements are such that you feel that you have to implement on-demand JSON parsing your time would probably be better served moving to a structured binary format instead.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19aovll",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://gleam.run/news/gleams-new-interactive-language-tour/",
    "title": "Gleam's New Interactive Language Tour",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19aovfy",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://supremecodr.com/designing-backend-system-process-to-handle-downtime/",
    "title": "How we handled our server downtime (managing automated processes/CRON)",
    "points": null,
    "comments": [
      {
        "comment": "Barely has any usefull information within \"writing\"",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19aou9t",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.cloudwego.io/blog/2024/01/18/harnessing-the-power-of-rust-for-cloud-development-with-volo/",
    "title": "A Rust RPC framework with high-performance and strong-extensibility for building microservices",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19aosn9",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://sourcehut.org/blog/2024-01-19-outage-post-mortem/",
    "title": "Sourcehut network outage post-mortem",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19aoshs",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://archives.loomcom.com/genera/genera-install.html",
    "title": "Run Lisp machine emulator on Linux",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19aodis",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://tembo.io/blog/simplified-ml-ops",
    "title": "Build your ML Ops platform on Postgres",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19ao66m",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://youtu.be/PDNaoVrK6oM",
    "title": "PathFinding Visualizer in Python and Tkinter. Source code is in the description.",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19ao0gi",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.youtube.com/watch?v=RqubKSF3wig",
    "title": "ex google engineer on how to build software as a team of one",
    "points": null,
    "comments": [
      {
        "comment": "Disclaimer: I'm a startup founder, mainly doing Devops and AI today as the company grew.\n\nA lot of his issues could be fixed by using docker [or any VM based service]. He repeats like 10 times in his talk the replicability between prod and local like it was some exceptional property. Should he know about docker/VM he wouldn't have used that as one of the key values, just doesn't make any sense.\n\nMaybe I'm just a devops and can't understand how is it possible to give a talk with such confidence and lack about the basic skills of working with and deploying a software, it's actually impressive.\n\nLooks like a case of an overconfident dev that create unmaintanable architecture even for himself 6-12 months down the line.\n\nDon't get me wrong for your personal project you can do all that just fine. For anything else that is supposed to live for longer, these kind of mentality and style of working will bite you in the ass sooner or later.\n\nPS example: It's because of these kind of guys that some companies are stuck using Ubuntu 10 in 2024 and can't update to install newly needed libraries or features, because every damn thing is interlinked so you're forced to rebuild the whole damn thing from scratch on a new server to use a newer OS and it's bound to be a nightmare of bugfixing for months.\n\n\"works on my machine\" type of guy",
        "points": "4 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19antjx",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://a0.to/reddit-read-edit-metadata-python",
    "title": "How to Read and Remove Metadata from Your Photos With Python",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19an92d",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://apidna.ai/the-risks-of-api-integration-and-how-to-mitigate-them/",
    "title": "The Risks of API Integration and How to Mitigate Them",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19an81p",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.crunchydata.com/blog/one-pid-to-lock-them-all-finding-the-source-of-the-lock-in-postgres",
    "title": "One PID to Lock Them All: Finding the Source of the Lock in Postgres",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19al153",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://github.com/AdvDebug/BehavEye",
    "title": "BehavEye: Advanced dynamic malware analysis tool",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19akshg",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://shiftmag.dev/triangle-software-development-2548/",
    "title": "The magic triangle of software development",
    "points": null,
    "comments": [
      {
        "comment": "Just one triangle? Have you not heard of the conjoined triangles of success?",
        "points": "32 points",
        "children": [
          {
            "comment": "You see? Everything comes back to the conjoined triangles of success.",
            "points": "4 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I was only referring to the serendipity of the coincidence.",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Nope, but I’ve heard of the Bureaucratic Triangle of Terror.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Speed and quality aren't opposite corners and the iron triangle doesn't always hold for software, especially if you measure development speed over the lifetime of a piece of software. High quality software is usually easier to change and therefore you can move faster.",
        "points": "9 points",
        "children": [
          {
            "comment": "I'll double down on this statement and add some context.\n\nA lot of solid empirical science has shown that speed of development and quality of work developed are nearly mutually inclusive. You can't really choose one over the other, to get one you need to invest in both and get both at the same time. Read up on the DORA related studies for the science.\n\nAnd once you phrase it like that it doesn't really make sense to do anything else except maybe rapid prototyping something that you will throw away, but even those get put into production most of the time and now you have low quality software you need to maintain and extend.",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Though this is true it's hard to swallow if I put myself in the product manager's shoes: my developers say that moving slowly now will lead to vague increases in speed later since the code will be \"more maintainable\" later, which means it's \"more likely\" that Future Developer Person will be able to add features to the codebase faster than otherwise.\n\nJust seems like a lot of \"this is true and I know it is based on experience\" but filled with many unknowns and promises and hope instead of backed by any kind of numerical data. Now that I think of it, that's probably why this is an ongoing discussion between devs and product managers",
            "points": "-2 points",
            "children": [
              {
                "comment": "Except there is numerical data backing the statement that development speed and software quality are not in opposition with each other.\n\nThe thing is, “quality” is actually too vague here. The kind of software quality you strive for is important. Basically, you’re right that if you make vague promises like “doing x will make the code more maintainable” and don’t explain yourself well then no one will believe you, and they’re probably right not to believe you. If you can’t make a clear case for a technical improvement to a non-technical person then you probably don’t understand the effect of what you’re proposing that well either.\n\nIf you’re interested in data from real software teams that measures their success in terms of how they develop software, the state of devops report produced by DORA and Google is a great resource: https://cloud.google.com/devops/state-of-devops",
                "points": "3 points",
                "children": [
                  {
                    "comment": "Thanks, I didn't know this was actually something empirically studied. Will check that out!",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Seems silly. One can increase the scope, maintain the quality and speed, by simply working for longer. I.e. the triangle doesn't take duration into account.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "This article can be represented by a singular point at the “speed” vertex.",
        "points": "-1 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "\"Better, faster, cheaper. Pick 2\"",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Honestly why even bring quality into the equation. X features in Y time is how it works. It's not up to management to weigh in on how the work is done, or to what quality. Only what is needed on what timeline to what degree of criticality.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19akqop",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.youtube.com/watch?v=qoBNbHjwKIw",
    "title": "Making your apps error proof with Remix.run",
    "points": null,
    "comments": [
      {
        "comment": "I don't know what your software does, but I do know it hasn't figured out how to prevent all errors.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19akils",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://platform.uno/blog/state-of-webassembly-2023-2024/",
    "title": "The State of WebAssembly – 2023 and 2024",
    "points": null,
    "comments": [
      {
        "comment": "When do you anticipate it being reasonable to use python say, instead of javascript, to build a progressive web app?",
        "points": "0 points",
        "children": [
          {
            "comment": "Never. You cannot manipulate dom from webassembly.\n\nAlso, if you want to use a better language then javascript. Make sure it's actually better...",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19akejs",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://medium.com/@TBeijen/why-kubernetes-focus-on-the-api-not-the-servers-57217668c1bd?source=friends_link&sk=7c48748cb7b402f5c92bd8b309be781d",
    "title": "Why Kubernetes? Focus on the API, not the servers",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19ajmuc",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://alexandrehtrb.github.io/posts/2024/01/symlinks-for-multi-repos/",
    "title": "Symlinks for repeated files in multi-repos",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19ajbht",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://essentialsoftwaredevelopment.com/how-does-public-key-encryption-work-c-example-simplified/",
    "title": "How does public key encryption work? C# Example Simplified - Essential Software Development Career + Technical Guide",
    "points": null,
    "comments": [
      {
        "comment": "You generate a symmetric key, bulk encrypt the data then wrap that key with the recipient's public key. Send the ciphertext and wrapped key to recipient where they unwrap the symmetric key with their private key and bulk decrypt the data.",
        "points": "0 points",
        "children": [
          {
            "comment": "Or encrypt with recipients pub key and send it. Way easier.",
            "points": "-1 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19aim97",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://github.com/henriqueinonhe/promises-training",
    "title": "JavaScript Promises Training",
    "points": null,
    "comments": [
      {
        "comment": "I hope you like the summary below:\n\nPractice working with promises through a curated collection of interactive challenges. This repository provides a platform to refine your skills, complete with automated tests to to give you instant feedback and validate your progress.\n\nIf you don't like the summary, just downvote and I'll try to delete the comment eventually 👍",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19ai3ab",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://jerkytreats.dev/blog/so-your-technical-debt-has-gone-to-collections",
    "title": "So Your Technical Debt Has Gone To Collections",
    "points": null,
    "comments": [
      {
        "comment": "We don’t really know what these servers do. Authored by people no longer with the company. Somehow also mission critical servers.\n\nThis reads as a company that has more problems than just tech debt.\n\nIf you have \"mission critical\" servers that are not owned by any team, it means you have \"mission critical\" business processes that are not owned by anyone. Either the company is in a known unhealthy state, and actively trying to resolve this, or management is asleep at the wheel.",
        "points": "57 points",
        "children": [
          {
            "comment": "I work in healthcare and almost every company/enterprise I've worked with has question marks on critical architecture. It's just the cycle in this business: big corp buys small corp, small corp expertise gradually leaves, remaining big corp personnel have incomplete knowledge of small corp tech... Name a large healthcare company and I promise they have tech that lives depend on and are in this place.",
            "points": "11 points",
            "children": [
              {
                "comment": "I spent time in healthcare, too. I saw a lot of stuff that IT didn't know about because the purchasing process had the IT signoff as optional. The poor frontline techs would get ambushed on the floor all the time with some clinical person who was having an issue with a bit of technology they'd never seen.",
                "points": "2 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "Not just in healthcare. Any SAAS company is going to have this problem eventually if they don't properly value knowledge retention.\n\n...and guess what...they don't and never, ever will because retention costs money.\n\nIt's just something you're going to have to learn how to live with regardless of what industry you're in if you're in tech.",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Churn happens and mediocre managers don't really know what the people they were managing built. Tacking the word enterprise on something usually means it is fraught with this shit. I would bet the the vast majority of fortune 500 companies have critical architecture that they are unable to replicate in the event it goes down, this is one of the better upsides of containerized/infrastructure as code environments.",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Is it unfair to call this technical debt that had gone to collection? You didn’t know you were relying on a legacy service until you were informed you had to take action, and then you took action.",
        "points": "28 points",
        "children": [
          {
            "comment": "Agree, doesn't really seem like technical debt going to collection unless you intentionally used a legacy/beta (not that google has anything else besides 'alpha, subject to change') just to ship something quickly that you knew you were going to have to fix later and then 'later' came sooner than you expected.",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Good that you're on top of your finances, but you'd be surprised how often the debt that goes to collections is debt the person doesn't remember they had.",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "The second article in the chain mentions that they were running on a deprecated IaaS version, which the IaaS provider had told them would break eventually.",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "It's not clear to me whether the issue was that the IaaS provider didn't upgrade their dependencies or the Author's company didn't upgrade the IaaS service. Either way, it is a bit surprising they got no help from their IaaS provider.\n\nI am a bit disappointed there aren't real lessons here for the rest of us, it is just a story. I remember when the log4shell exploit came out. We had 0 days to fix it and nearly every system we had was vulnerable. Thankfully, the maintainers created a drop-in replacement, so the hard part was mostly finding everything that was vulnerable.",
        "points": "10 points",
        "children": [
          {
            "comment": "I still find stories quite interesting even if don’t have explicit lessons. Also there will be a couple more parts to the story so maybe some lessons forthcoming.\n\nAlso there are some “lessons” listed. Maybe bit high level for you to consider actionable?",
            "points": "4 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Imagine we have an electric network, but the electric company is free to decide that they can change the voltage and/or phase and/or frequency of the electrical supply at will when they want, and it's your duty to adapt quickly all the electrical appliances you have at home. If you get it wrong, you can absolutely start a fire.\n\nThis is how it is to be a software developer. Except that these change occur more or less every few days.",
        "points": "1 point",
        "children": [
          {
            "comment": "Well, only if you don’t protect yourself from the thrash",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "My takeaway after browsing this while eating lunch is that they learned the wrong lessons. Know where in there did he touch on:\n\nHow they screwed the pooch with unmaintained servers being used in production. How do you not have at least a spreadsheet of servers/services/etc?\nHow they (essentially) ignored the initial warning, because they didn't think it fit them. (i.e. assuming Google was in the wrong, not that they were)\nApparently have no internal process to manage when an employee leaves/is reassigned. Unfortunately common in smaller companies, though by no means limited to them.\n\nI'm sure there are more big issues I missed, but lunch is over.",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19ahrby",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://youtu.be/Em6OzzcO9Xo",
    "title": "API pagination with FastAPI and SQLAlchemy",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19agspe",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://kapilg.hashnode.dev/time-series-aggregation-in-pandas",
    "title": "Exploring Pandas for Time Series...",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19agqf7",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://medium.com/techtofreedom/5-levels-of-using-context-managers-in-python-8a3c6c3531ba?sk=61faf77c88b732b1011f03a79d6c0df1",
    "title": "5 Levels of Using Context Managers in Python",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19agns9",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.youtube.com/watch?v=vcjOzcxIBdY",
    "title": "Programming the Web with HyperLANG & HyperCLI",
    "points": null,
    "comments": [
      {
        "comment": "Quick summary:\n\nMike introduces HyperCLI, a command-line tool serving as a generic client that can consume popular Hypermedia API media types such as Siren, HAL, Collection+JSON, etc.\n\nIf you don't like the summary, just downvote and I'll try to delete the comment eventually 👍",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19aghon",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://newsletter.eng-leadership.com/p/my-secret-for-growing-from-engineer",
    "title": "My secret for growing from engineer to CTO",
    "points": null,
    "comments": [
      {
        "comment": "Even after googling you, I have no idea what you are CTO of. Also, freelancing in no way prepares you for a CTO role. It's kinda the opposite of being a CTO in a lot of ways (no ownership, no need to make decisions with the long term in mind, etc).",
        "points": "35 points",
        "children": [
          {
            "comment": "You needn’t have to brutalise him like that. /s",
            "points": "14 points",
            "children": [
              {
                "comment": "Really unfair. It starts with a chart even! It's using science!",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "Well he did give us his secret. What did he thought? Now in two weeks tops all of us will be promoted and we’ll drown in a sea of CTO.",
                "points": "2 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Wake me when you have a “secret” that doesn’t require 12+ hour days.",
        "points": "9 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Money laundering",
        "points": "4 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I bet it was not definitive aspect. There are way too many freelancers who aren’t cto and ctill want to be. It’s like saying that eating cucumbers made me a cto only because I value cucumbers and did become a cto.\n\nIn practice it’s almost always about being in the right place in the right time and be ready to take a shot. Will freelance help harnessing those aspects? Maybe. Are there better ways that freelance to recreate those aspects? Most probably.",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Why would you want to",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "You get asked that question regularly? By who? Coworkers?",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19agahf",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://youtu.be/VT9Vuu5xXj8?si=z5MuRSQ-5LizPXpo",
    "title": "How to choose a programming language in 2024",
    "points": null,
    "comments": [
      {
        "comment": "Step 1: Use the one you like the most. Step 2: There is no step 2.",
        "points": "-1 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19afvqq",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.permit.io/blog/best-practices-for-api-authentication-and-authorization",
    "title": "Best Practices for Authentication and Authorization in API",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19afris",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://c3.handmade.network/blog/p/8852-how_bad_is_llvm_really",
    "title": "How bad is LLVM *really*?",
    "points": null,
    "comments": [
      {
        "comment": "So the bad thing is speed, the time it takes to compile. That doesnt make LLVM itself bad.\n\nIt is not like its full of bugs and stuff like that, or have weird behavior or undefined behavior that is really different to gcc.",
        "points": "39 points",
        "children": [
          {
            "comment": "Speed is needed for big projects. LLVM is heavy and memory intensive, this isn't great. What's needed is a lightweight alternative, which isn't going to be easy. Only successful people at it are GNU, Go and the upcoming Zig self hosted compiler.\n\nThe problem is that none of these (par GNU to a degree) solve the issue of language agnostic backend. They focus on their thing and that's it. What I'm excited about is actually Zig's compiler because based on its aims, it'll have to be a C and Zig compiler at the very least. And given that Uber already has a contract with them that specifies C and C++, it's expected that their compiler will be able to at least support these three languages. I hope the endeavour won't break them though since they're like less than 6 people.",
            "points": "4 points",
            "children": [
              {
                "comment": "Building a C++ compiler is basically an insurmountable task for any upstart team at this point. C is much more realistic.",
                "points": "0 points",
                "children": [
                  {
                    "comment": "I'm not sure how far they can get. The group are basically geniuses and each of them is his own kind of batman. I think half of them were core Linux kernel developers and throughout the way they keep solving issues that takes companies to solve in an elegant way, like how they solved function colouring without changing semantics or concepts because Zig tries to be as familiar as it gets (also they can't have a runtime like Go to multiplex and stuff on a low-level)",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "LLVM isn’t slow if you consider what you are getting with it.   In fact it is rather impressive and on modern hardware not a problem.   People that complain about LLVM should get off their Z80’s and run modern hardware.",
        "points": "5 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "The main issue is backend performance.\n\nHas anyone actually profiled it?",
        "points": "-2 points",
        "children": [
          {
            "comment": "No, we just go by gut feel.\n\n... sorry - I don't even know what to do with your question.",
            "points": "15 points",
            "children": [
              {
                "comment": "What’s the main performance bottleneck in LLVM?",
                "points": "-1 points",
                "children": [
                  {
                    "comment": "Codegen\n\nLLVM codegen and linking takes over 98% of the total compilation time for the C3 compiler when codegen is single threaded with no optimizations.\n\nWhich - as the article argues - is a structural problem, not a \"oh, look, we left a Sleep(100) in that one central loop\" thing.",
                    "points": "12 points",
                    "children": [
                      {
                        "comment": "Yes but where specifically in codegen? Instruction selection? Register allocation? Serializing LLVM IR to and from text?\n\nLike what exactly does “codegen” (aka the entire responsibility of the LLVM library) mean?",
                        "points": "2 points",
                        "children": [
                          {
                            "comment": "You might want to ask the people responsible for these graphs.",
                            "points": "6 points",
                            "children": [],
                            "isDeleted": false
                          },
                          {
                            "comment": "Of the top of my head I recall instruction selection taking a huge chunk of time.\n\nIf you then go into the isel code you can see it’s clean and polished, but the call chains go deep, so there is probably a lot of code happening for every instruction.",
                            "points": "1 point",
                            "children": [
                              {
                                "comment": "I wonder does it have to do with the sheer amount of hardware options available. Perhaps there is a noticeable difference between compiling for CISC machines vs RISC machines.",
                                "points": "0 points",
                                "children": [
                                  {
                                    "comment": "Just for fun I compared compiling for aarch64 and x64 for the same OS. Aarch64 was slower in that test.",
                                    "points": "1 point",
                                    "children": [],
                                    "isDeleted": false
                                  },
                                  {
                                    "comment": "Maybe they should have gone meta-meta and made it a code generator generator, which can spit out the code optimized for a given configuration. It could take an hours to work out the best solution if necessary, and the output wouldn't require any abstraction since each output is built for a single configuration (or maybe family of related ones.)\n\nKind of interesting that no one has actually done that.",
                                    "points": "0 points",
                                    "children": [],
                                    "isDeleted": false
                                  },
                                  {
                                    "comment": "I don’t think so, the LLVM commandline takes which hardware to compile for, I only compile the X86 backend and it’s still slow to compile.",
                                    "points": "0 points",
                                    "children": [],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "\"It's really focused on C/C++ and other languages may have problems if they want behavior that doesn't agree with C/C++ behavior. Here are some small examples.\"\n\nSaved you a click.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19afmwh",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.blackslate.io/articles/spring-boot-and-apache-camel-integration",
    "title": "Spring Boot and Apache Camel Integration",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19aeyas",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.youtube.com/watch?v=Jx7QFpmnSSY",
    "title": "Stop idolizing a small set of companies that have problems no one else actually has...",
    "points": null,
    "comments": [
      {
        "comment": "I joined a VC backed startup that had a bunch of ex Amazon engineers.\n\nThe system was so over built for what it was doing.  Running separate web services and key rotation on interservice API calls that could have just been 1 service.  Debugging was difficult because you had to run everything.\n\nIt was super complicated.  With the CTO's blessing, I squashed it down to one monolithic service and we never looked back.  \n\nTrying to solve every problem assuming Amazon, FB, Google, Netflix scale is the root cause of a lot of the useless complexity we see in software engineering today.",
        "points": "236 points",
        "children": [
          {
            "comment": "Modular Monolith, that's all non big tech monster needs.",
            "points": "81 points",
            "children": [
              {
                "comment": "100%; actually recently wrote a bit about it: A Practical Guide to Modular Monoliths with .NET and a GitHub project that shows roughly how we consolidated a lot of the separate standalone background services into one monolith that makes local development way easier.",
                "points": "50 points",
                "children": [
                  {
                    "comment": "Soon everyone will be using my new Monostributed technology, which holographically distributes the data and code throughout the internet.",
                    "points": "27 points",
                    "children": [
                      {
                        "comment": "Whatever that is, I have 5 years of experience with it.",
                        "points": "18 points",
                        "children": [
                          {
                            "comment": "I thought I recognized your name...",
                            "points": "5 points",
                            "children": [],
                            "isDeleted": false
                          },
                          {
                            "comment": "That's a shame, most job postings I've seen for it require at least 10.",
                            "points": "0 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "Microservoliths.",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "As long as you can assume that what you need can run on a single computer a modular monolith is great.\n\nAs soon as you can't, it's not. At all. And trying to get away from it is nearly impossible.\n\nThe company I work for started developing a program in 1992. Today, it is a monolith with over 10 million LoC, much of it in extremely dense languages like APL.\n\nThe monolith contains over 10,000 unique window screens. And the application also contains its own source control system.\n\nHow do you host this as a cloud service where people want to run tons of separate parts of the monolith? Maybe they want to use 20 out of those 10,000 windows. How do you do this efficiently? I mean it's not a problem with the architecture it has when running on a local machine because it's so modular, see, and there's gigabytes of memory and CPU cycles to spare, but when you want to cram as many installs as possible onto the same system as containers?\n\nWell, either you don't, or you spend literal YEARS untangling it all. Which we have done.\n\nBut of course we could afford to do it because the product is a success and we have customers who want this now. If we had tried to build it this way from the start, we might never have gotten to that market position in the first place and it would all have been for nothing.",
                "points": "-1 points",
                "children": [
                  {
                    "comment": "Today, it is a monolith with over 10 million LoC, much of it in extremely dense languages like APL.\n\n10mLoC of APL\n\nPress X to doubt.",
                    "points": "2 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Google and Facebook use monoliths. Especially the latter.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Ex-FAANG run startups can be a nightmare. It is very rare those people have any experience working in ambiguity and the cult like belief in the way things are supposed to be done (and often works for those companies) is actually harmful to a startup. I wish C-Suite people weren’t so obsessed with logos.\n\nThe last startup I was at had a ton of ex-Amazon people including the CTO. They were all smart people but often looked dumb in the startup context focusing on non issues or suggesting solutions that would take 6 months to get going, a lifetime in a startup where things change rapidly.\n\nThe CTO constantly whined about how things were done and actually “stole” one of my documents for a solution, passing it off as his own. IT was locked down so no one could get access to data or tools unless they put in a request that was often denied completely halting progress. This was a 150 person startup, really not necessary and actually very harmful.",
            "points": "25 points",
            "children": [
              {
                "comment": "Ex-FAANG run startups can be a nightmare.\n\nYou're operating at a level where employees are absolutely not a fungible resource, and it seems like they need to tank a few projects before they learn that fact.\n\nE.g. the idea of \"underperformers\" shouldn't be in your head. You can't afford to hire underperformers.",
                "points": "-1 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "You’re throwing entire FAANG into one basket. They are very different companies with different cultures.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I have some experience working with and/or interviewing with startups started by FAANG employees.\n\nOne startup I consulted with failed because they wanted to build a perfect technical system above all else - including making money. They had me come in on the side and build the system to make them money, which the CTO promptly took over and sidelined until it was built to his standards. They were dead 6 months later.\n\nTwo companies interviewed me for a leadership position, both had conversations with me early on about how to solve their hiring problems. They had difficulty hiring people. I told them that the biggest mistake I see companies making is trying to emulate FAANG hiring practices when they're nowhere near FAANG scale, and that not even FAANG companies operated in the same way when FAANG companies were the same size as a startup. And you also can't put people through that FAANG squeeze for a fraction of the comp. Both of those companies proceeded to put me through a process that looked identical to FAANG, because their co-founders were ex FAANG execs. Neither one worked out. Both of these companies have since failed, one of them never found anyone to fill the position before failing.",
            "points": "43 points",
            "children": [
              {
                "comment": "I was on a YCombinator virtual session where one of the principals had a whole slide on this and talking about how non-technical founders should be cautious about early hires from or co-founding with ex-FAANG.\n\nhttps://imgur.com/a/6X3ZxyX\n\nHarj Taggar basically said that he's seen and worked with hundreds of early stage startups and FAANG engineers can struggle with the nature of early stage startups before product-market fit since it demands a totally different mentality (build fast, build for simplicity, favor flexibility, take shortcuts to ship, be ready to throw it away, etc.)\n\nIt's 100% true.\n\nI'll nope out of an interview with early stage founders if they start talking about microservices and Helm charts.",
                "points": "19 points",
                "children": [
                  {
                    "comment": "Yeah it rings true to me. Different people have different skillsets, mentalities, preferences, etc. Not all of these are appropriate for startups. Some people don't have problems shifting their mindset, but lots of people do.\n\nAdditionally, as someone who has been in a leadership position in startups hiring many people, FAANG employees also tend to want to preserve/increase their comp level without risk. That of course just doesn't really work with startups. I always approach a FAANG candidate warily due to this. But this might be going a bit further off topic",
                    "points": "9 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "I know the circlejerk is already in motion but this is so dumb because it presupposes FAANG and early stage startup engineers are mutually exclusive . Although there are some people at FAANGs who spent there whole career within that small group of companies there are also a whole lot of people who worked at other size companies before joining a FAANG company",
                    "points": "-11 points",
                    "children": [
                      {
                        "comment": "I know the circlejerk is already in motion but this is so dumb because it presupposes FAANG and early stage startup engineers are mutually exclusive\n\nI don't see that. I see a recommendation to be cautious because it's hard to tell which is which. Both have technical chops, which is easy-ish enough to screen for. Beyond that, one is toxic to an early stage startup.",
                        "points": "1 point",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "FAANG programmers cost FAANG dollars and you can't run a business like that unless you have FAANG capital.\n\nGood businesses get by with worse programmers and good business ideas.",
                "points": "-1 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Been trying to explain this to a senior engineer lol. He wants to use tools that sacrifice maintainability but scale really well; however, our applications aren’t internet-facing. Our work is embedded and will probably have like 3 users max. In the worst case, it would run on an internal network and have like 10 users max. We don’t need to run a separate nginx server for our frontend when we could just serve our API and SPA app from a single process, which may sometimes run on underpowered hardware.",
            "points": "10 points",
            "children": [
              {
                "comment": "That sounds absolutely insane. A 3 user LOB app could easily run on the tiniest instance size any hosting provider offers.",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "If your startup of 20 people isn’t capable of handling millions of requests a second what are even doing",
            "points": "20 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "premature optimization something something...",
            "points": "12 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Yeah I don’t get this mentality. Microservices are meant to solve a problem. As long as you know what to look for, you will know when you need them, because deployments and general operability will become so painful that there is scant another way forward. If you aren’t feeling that pain then you don’t need them. Simple monoliths will take you a long, long way.",
            "points": "5 points",
            "children": [
              {
                "comment": "I just took a microservice course on Udemy. The instructor developed two micro services and then created a gateway service so that you communicate with the gateway to access the other two. The gateway had model classes for each of the models in the other two services. I haven’t done micro services from scratch but this seems like it wouldn’t scale.",
                "points": "1 point",
                "children": [
                  {
                    "comment": "To me it would be difficult to learn about microservices through something like Udemy. The subject material just doesn’t lend itself well to a 10 hour course. And yeah that design doesn’t sound like it makes much sense, likely the instructor just wanted a trivial example to illustrate the broad points. Duplicating model classes is odd, we typically distribute client libs as artifacts in addition to our deployment artifacts for this reason.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Where is another argument, which goes a bit in reverse. A lot of companies say, we do not have the scale of FAANG, so we do need to think about performance. Give it few years and company is running 10*16 core servers to maintain 200req/s :D The worst part everyone is happy, because hey, if we were to cut it, we would save 2 servers or something like that, so it makes no sense. RAM is cheap, developers are expensive and so on and so forth.\n\nIn reality it could have been done from the very begging with perf in mind (which by the way is a skill issue, and cost nothing in development time), and company would be running on 1 server with 16 cores if not less (resource wise, you would still need at least 3 machines for redundancy).\n\nSo I guess you can over trivialize things as well not only over complicate. Somehow big companies made efficiency their domain, and everyone else forgot that good code can also be efficient and takes the same amount (more or less) of time to code it.",
            "points": "-7 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Ok but remember that historical memo where Jeff bezos dictated web services for all products of Amazon? That made Amazon the big player they are after all! And we, too, want to be like that!",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "No wonder. I live in the Netherlands, which is relatively high on the list for software engineers in terms of skill and salary. Guess what you get taught at a Bachelors of Science in software development?\n\nDistributed software using microservices\nAgile/scrum (thats a good thing :))\nAPI's\nDocker\nA shit ton of research. I honestly think I have been researching for 80%. And that includes things like the fucking history of agile - who cares?\n\nWhat did we not learn? Well, how to actually make a good application. I honestly wasted my money because in the end, I practically learned nothing about programming at all, while knowing all these things that netflix and google use to maintain such high availability. Well, wooptidoo, when am I going to build Netflix 2? Never, that's right. When am I gonna make a distributed webshop for a small client with 100 visitors a day that uses 100 microservices? Well, probably tomorrow if it were up to the schools here.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Facebook built their infrastructure on the same principle. You are meant to move fast, not deliver some ultra complex and fancy solutions. It has to do the job, and just the job at hand.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "There used to be a group that was trying to push our entire company into a monorepo \"like Google\". Every codebase for every product/service, including ones that have nothing to do with each other from completely different industries/purposes.\n\nThey didn't seem to realize that Google (and other companies that do this) invest heavily in teams that just make and support the tools that make something like that actually work, and that our company (culturally and financially) would never find spending all that money on internal-only custom tools to be economical.\n\nThankfully, no one listened to them and they are all gone now.",
        "points": "10 points",
        "children": [
          {
            "comment": "What are the tools needed to make the mono repo work and how are they more expensive than effort needed to support the alternative?",
            "points": "0 points",
            "children": [
              {
                "comment": "Google has a large amount of custom internal tooling, created, enhanced, and maintained by internal teams.\n\nhttps://qeunit.com/blog/how-google-does-monorepo/\n\nPiper, CitC, CodeSearch, custom IDE plugins, Tri-Corder10, Critique, Pipe: all custom in-house tools.\n\nIt should be exceedingly obvious that writing and maintaining and supporting custom tooling with internal teams is way more expensive than just using GitHub or GitHub Enterprise and other open-source or commercial offerings.",
                "points": "1 point",
                "children": [
                  {
                    "comment": "I worked at Google :)\n\nHow are these tools necessary for monorepo and not really necessary with smaller repos? I understand code search - but at a smaller company monorepo should still scale with some very simple search solutions.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "How many more startups could be funded if VC understood that 80% of startups could be serviced by one of the following?\n\nGo api + react\nDjango + htmx\nBlazor app\n\nHook it up to Neon, Planetscale, or Mongo Atlas.\n\nA good product should be able to provide value with a very simple interface (it can look modern and be simple - you don't need to be geocities here).",
        "points": "34 points",
        "children": [
          {
            "comment": "Why would a VC fund a startup that obviously won't scale to the moon?",
            "points": "20 points",
            "children": [
              {
                "comment": "LAMP done right can scale up to non-giant company needs fine. Wait until you actually are approaching Amazon size to use high-end techniques, because such techniques slow initial growth via complexity and bloat. YAGNI and KISS still matter.",
                "points": "4 points",
                "children": [
                  {
                    "comment": "I want to steel-man his argument.\n\nI think they're saying VC will only invest in those that wish to hyper-scale.\n\nFair enough - but my counter argument to that is a startup wishing to find product/market fit will make a few smaller experiments and find where there's traction.\n\nOr perhaps I could have said - how many startups could have avoided VC altogether - been self funded - and made the founders fat stacks.",
                    "points": "4 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Facebook was written in PHP, because that’s what Zuck knew and he could write shit fast using it. It obviously worked out.\n\nInvestors won’t give a fuck about tech if product works and grows. You can figure it out later, as numerous examples have shown.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I have sold projects doing just that. spring react or more recently go react. Or if the usecase is simple enough just a Django app with HTMX.",
            "points": "4 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Not sure how this list (excluding React) of niche techologies is good. Looks like CV driven development to me. Go is way harder to use comparated to nodejs + react",
            "points": "4 points",
            "children": [
              {
                "comment": "How is it harder to use? What’s harder about it?",
                "points": "1 point",
                "children": [
                  {
                    "comment": "The commenter has less experience with it.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Not everyone can get VC money.\n\nWith a Blazor app/web flavor of the month you can take off Mom & Pop style and just get your revenues the old fashioned way. Combine it with a decent idea like...cannabis delivery service or something and you can just get money from customers.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I agree with the concept but I've worked with a lot of people who use it as a meme to avoid things that do make sense.\n\neg. one team I worked with refused to use containers, proper ci because 'we're not google' and near every deployment they made failed in a way that impacted customers\n\nlike yeah don't be a architecture astronaut or bandwagon concepts you don't need ( service mesh, microservices usually ) .. but you still have to solve for your problems",
        "points": "4 points",
        "children": [
          {
            "comment": "Well yeah. There's avoiding shit that's only good for large orgs and then being a shit programmer. I've been in plenty of places where they were afraid of version control.\n\nLike dude, version control is helpful for CS students in college lol.\n\nSame thing for cloud services. Of course you want to know Azure/AWS/Oracle. What are you gonna do, build a fucking clean room and buy a bunch of servers? With what capital? lol.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Talks for nearly four minutes without actually saying a single thing. That's some politician level shit.",
        "points": "64 points",
        "children": [
          {
            "comment": "I disagree, she said something quite important: the problems of the large FAANG tech companies are different from the problems of 99.999% of other companies and thus the solutions that FAANG develops for those problems are very often inappropriate or totally overblown for most use cases.\n\nFor example, we all know the \"correct\" reply when somebody says they are working on a product in PHP: we scoff superiorly and ask them if they've moved on from FTP'ing files for deployment. As enlightened software engineers, we obviously know what the the best practice for deployment is: have CI build Docker images of our projects, use Kubernetes to orchestrate containers into pods, usually in a hosted k8s cluster like GKE, rely on ever-changing SaaS services to do canaries, A/B testing, etc. We know this is obviously the right approach, because that's what the large tech companies in Silicon Valley do.\n\nBut if the PHP developer is working a site that receives 1000 hits per day, the complex orchestration is total overkill and going that route because \"it's the current best practices in software engineering\" is going to be a net negative.\n\nThat's the message she was conveying. It's a hard message to convey too, because this is going against the grain.",
            "points": "71 points",
            "children": [
              {
                "comment": "The cool thing is those of us who still find value with PHP manage to be able to still do cool things. My personal SaaS project is a Vue SPA with a PHP backend. It's deployed to an AWS Fargate cluster with an AWS load balancer using Bitbucket Pipelines. It's using MariaDB via Amazon RDS. It utilizes S3, SES, Route 53, Parameter Store, etc. All of my projects at work are deployed in even simpler ways to basic VPS stacks or some such (usually deployed via a basic rsync pipeline). I learned a long time ago to ignore lost Redditors who think everything needs to be done the same way a team with dozens of devs do it - they're just as out of touch with reality as I am.",
                "points": "14 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "By the same token, there are a lot of people working on \"1000 hits a day\" apps and thinking they need to be ready when theirs becomes the next billion-user app. Those people also need to be disabused of the notion that they need to be able to handle 10,000 rps out of the gate, and instead focus on maintainability and not falling into the more obvious traps that would make it difficult to scale later.",
                "points": "8 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "Refusing to learn/implement git and a CICD pipeline is bad, though, at any scale. It creates a lot of needless risk and stress.\n\nI’ll admit that PHP is fine as a language and can be implemented properly, but IME it tends to go hand in hand with a reluctance to improve any part of the process.",
                "points": "12 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "Right but a lot of people in this sub do handle more than 1000 hits a day. I’m not exactly FAANG but my system does a billion requests a day in 3 regions. Not exactly a drip.",
                "points": "7 points",
                "children": [
                  {
                    "comment": "a lot of people in this sub\n\nThis sub has 5.9m members. I don't believe it is true that a lot of those deal with the traffic you do. I find it much more likely that you are the exception.",
                    "points": "21 points",
                    "children": [
                      {
                        "comment": "The thing about \"a lot\" is that a total doesn't really matter. For instance, \"there are a lot of members in r/programming\" can be an accurate statement, even though \"the Earth has 8b humans\".",
                        "points": "1 point",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "[deleted]",
                        "points": "10 points",
                        "children": [
                          {
                            "comment": "If you're big enough to care, you're hopefully big enough to know how to ignore advice that isn't intended for you.\n\nI would hope there's no one on this sub who's responsible for building Google's search index who is watching a random YouTube video and going back to work like, \"we need to throw all this stuff away because I saw a podcast that said we don't need to worry about scalability\".\n\nIf you read a headline that says, \"The key to good health is to eat right and exercise regularly\", you aren't supposed to be like, \"What a stupid writer. I'm already vegan and I run 20 miles a day. What a fucking idiot.\"",
                            "points": "10 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "1000 hits a second is closer to what we do...",
                    "points": "-2 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "She could have said that in 30 seconds instead of 4 minutes.\n\nAnd I wouldn't say this is going against the grain, I've heard that POV for years now.",
                "points": "5 points",
                "children": [
                  {
                    "comment": "I blame this on the editors of the video - good editors will remove all the non words from a podcast.",
                    "points": "8 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "Perhaps, but it can be hard sometimes to articulate ideas. I don't know if this happens to other people, but often I have ideas in my head that seem clear, but when I try to speak them out for the first time, it becomes a jumbled mess—the thing is still clear in my head, but I struggle to string the right words together to create an explanation as clear and concise as the idea.\n\nI understand it can be annoying, but focus on her message and less on how she delivers her message—there's a really good piece of wisdom to be gained.",
                    "points": "4 points",
                    "children": [
                      {
                        "comment": "It's not an off the cuff conversation, it's a produced video. She absolutely edited the video, she could worked on the length as well. It's that YouTube incentives longer content, and bloating length for that shouldn't be encouraged IMO.",
                        "points": "1 point",
                        "children": [
                          {
                            "comment": "She appears to be a guest on the podcast The Changelog (the video is hosted on their Youtube channel), so I don't think she had anything to do with the editing.",
                            "points": "10 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "it can be hard sometimes to articulate ideas\n\nThis is why you plan, script and practise what you want to say instead of rambling off the cuff.",
                        "points": "-1 points",
                        "children": [
                          {
                            "comment": "This is obviously a podcast of some kind, you know...where things are generally unplanned and unscripted...",
                            "points": "8 points",
                            "children": [
                              {
                                "comment": "This is the internet, which was invented to allow people to judge without knowledge. It's so empowering, man.\n\nStill... people are clearly evil if they don't work harder to give us free stuff.",
                                "points": "7 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "\"If [she] had more time, [she] would have written a shorter letter Script\", I assume. Working on writing, setting it aside while your subconscious continues to ponder it, and getting inspiration on how to make it better in the shower, on the toilet, or some time the next day seems common enough. Too bad most of the time you already posted the comment, sent the email, participated in the conversation, shared the recording, etc. and it's too late to implement those improvements.",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "[deleted]",
                "points": "3 points",
                "children": [
                  {
                    "comment": "It's a lot easier to be concise in writing because you can take the time to think first, and edit if you change your mind. She's speaking off the cuff, so of course it's going to take more words and time.",
                    "points": "3 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Not everyone working for FAANG works on large scale problems. There’s a ton of people working on internal tooling where often times scale is not a factor.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "I mean...even in a startup context PHP is garbage. At least use react or something lol. That really is just Geocities level",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "You know... it's like... shit and stuff... or more like...",
            "points": "23 points",
            "children": [
              {
                "comment": "Plus the vocal fry to top it off.",
                "points": "-3 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "While she's not concise on delivering the message. She did send a good message, don't apply solution for moving mountain when you only need to move a box, it will just slow you down.",
            "points": "13 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "If you don't understand the message, I guess you can always resort to criticising how someone speaks, their mannerisms, their looks, etc. Now that's some politician level shit.",
            "points": "8 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "plus, very strong affectation that makes it a pain to listen to",
            "points": "-4 points",
            "children": [
              {
                "comment": "the \"vocal fry\" is the cherry on top.",
                "points": "-4 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "What are you talking about? She says everything in 4 minutes - this is so important for people to hear.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "This clip is trash just go read the transcript.\n\nhttps://changelog.com/podcast/564",
        "points": "8 points",
        "children": [
          {
            "comment": "If I'm mobile and get transport sickness I'd rather listen even if it's a YouTube video",
            "points": "-10 points",
            "children": [
              {
                "comment": "It's not the whole podcast it's just a poorly edited clip that makes the speaker seem ignorant which simply isn't true",
                "points": "5 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "nodejs",
                "points": "-1 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "The problem is that the \"trickle down of best practices\" only happens at the surface level, and the smaller companies don't understand the mounds of research and planning that happened before any code was written. There are very specific reasons that products from enterprise companies work a certain way, and if you don't share the same underlying needs and assumptions, mimicking another product doesn't make any sense.\n\nWhat should instead be taken from these companies is the amount of prep work that goes into understanding a problem and planning before any technical decisions are made. Once you understand the problem, then you can start to make decisions about how to solve it, which may or may not being as complex as a solution that a FAANG has come up with for their use case.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "So true. It's not just that those companies have unique problems it's also that many of them have cash printing machines or literal monopolies that make it possible to fuck around with research projects and see what works. I did have the problem of \"It would be nice to have a nice modular JS framework instead of this piecemeal jquery/backbone thing I'm doing now\" but even so the company didn't have the excess resources to let people fuck around writing their own, and so you get your React and Angular from Facebook and Google, who do have them.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "valid point, not very well articulated.",
        "points": "3 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "she looks drugged.",
        "points": "-18 points",
        "children": [
          {
            "comment": "Show us what you look like so we can make judgement on your face. Cheers!",
            "points": "5 points",
            "children": [
              {
                "comment": "nah. if you are interested do your face reveal and enjoy having a face.",
                "points": "-8 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "But unnecessary \"web scale\" fills up my resume with nice buzzwords.",
        "points": "0 points",
        "children": [
          {
            "comment": "MongoDB is web scale.",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I... guess? Architect what makes sense for your needs, but a reverse proxy is always a good idea? Google or not. I was at Google, we just ran a big monolithic application because that's what the product required. If you go out and build everything like youtube or something, then you're an idiot applying the pattern you know.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "A lot of strange assumptions.\n\nWe don’t teach and require understanding of algorithms just because you might use them. We do it to help you understand common techniques and patterns used in programming. People who don’t know basics just don’t turn out to be great engineers.\nMost engineers at Google or Facebook don’t deal with problems of scale on a daily basis. You use existing infrastructure which already scales very well. Small minority of very senior engineers will ever be a part of any serious scalability discussions while working on said infra.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "She’s correct 100%.\n\nI’d add to that unless you’re at a company dealing with scale similar to a FAANG, idolizing best practices as dictated by any of these companies is inappropriate.\n\nBest Practices for most companies needs to be determined by the company and its culture; not some external company that operates in an ivory tower with almost limitless resources.\n\nAs a principal engineer, I’ve worked across the scale with FAANG as well as SMB. I feel too many people read into some of these best practices as gospel without determining whether these practices even make sense. Unfortunately it shows that critical thinking and decision making skills are really lacking across the board in many companies; and instead they play a game of follow the leader. I feel there’s way too many people playing the “nobody got fired for using IBM” mentality instead of taking a hard look at their needs, and crafting the right solution themselves and being okay with making mistakes along the way. It’s those mistakes that make you an expert - learn by following the leader does nothing to establish credibility.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "It's because software engineers don't understand how fucking business works.\n\nMonoliths are efficient and quick to change. You need that when you're running on revenues of thousands vs millions. Being able to ghost image your whole business off one computer and make backups is an asset. You probably have 4 programmers, not 10 and definitely not 40.\n\nYou make a monolith to make your initial cash, and then when it comes time to expand, then you do it. That's what business is. It has several phases and each phase is different. Knowing when to scale is crucial.\n\nRunning Google/Amazon farms when your business is not even making 100k per month is just a fast way to burn out.\n\nThis is why video games are monoliths. They're not live services. It's one and done. The same applies to startups. You can scale AFTER you can afford to pay your staff at market rates",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Yea, when \"this is how Google does it\" is their argument , that is a clear indication that they have no real justification for the crap they're peddling.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19aevta",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://about.sourcegraph.com/blog/slow-to-simd",
    "title": "From Slow to SIMD: A Go Optimization Story",
    "points": null,
    "comments": [
      {
        "comment": "So basically if you want vectorize your code, Go is not going to help you much. You still need to resort to hardware specific assembly code.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19aeklo",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://jacobbartlett.substack.com/p/mobile-is-actually-pretty-hard",
    "title": "Mobile is actually pretty hard.",
    "points": null,
    "comments": [
      {
        "comment": "I tried web dev and mobile, I will stick with the backend.",
        "points": "252 points",
        "children": [
          {
            "comment": "same, i prefer my predictable docker containers vs the compatibility issues that frontend (web + mobile) face",
            "points": "81 points",
            "children": [
              {
                "comment": "Isn't docker unpredictable when it comes to different hosts or when a new docker version releases? I am not up-to-date but years ago I read that it's a mess.",
                "points": "-6 points",
                "children": [
                  {
                    "comment": "different cpu architectures are annoying, but the OCI standard is set in stone now so docker version bumps aren't as much of an issue anymore.\n\nbut overall its really not that bad.",
                    "points": "8 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "I have no artistic bone in my body, no one wants me to do front end. Let me do integrations and debugging thanks.",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I'm a backend engineer that's been learning frontend. I think it's kind of a fun challenge. First off it's pretty cool to be able to build full products and not just an API no one is going to use. Second the problem space and the \"hard\" parts of it are very different from backend.\n\nIn backend the hard parts are scale. Once you built an API how do you scale it to process lots of data? In frontend the hard parts are state management, handling errors, and making things look nice without putting in too much work. I've had a fun time thinking through or researching more elegant ways to do these things.",
            "points": "14 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Absolutely my opinion too",
            "points": "6 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Ya gotta use Bootstrap or you're gonna have a bad time.\n\nI could not imagine doing webdev for mobile without using a mobile first css framework. Bootstrap is pretty easy to learn, though it takes a while to learn, and to accept its way of doing things.\n\nEmbrace the bootstrap Luke!",
            "points": "4 points",
            "children": [
              {
                "comment": "Damn I didn't know it was 2012 all over again.",
                "points": "25 points",
                "children": [
                  {
                    "comment": "Time is a circle",
                    "points": "3 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "As someone else stuck in the last decade - what's the modern equivalent of Bootstrap?",
                    "points": "-1 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "I don't necessarily use bootstrap, but a lot of the philosophies stuck with me. I particularly remember being sold on it after building a responsive menu bar and managing to keep complexity low.\n\nThe bigger issue I find is designers still doing desktop first and having mobile be an afterthought. Desktop gives them more freedom and looks better in powerpoint slides, so a lot of designers prioritize desktop because it is more impressive to company leadership.\n\nI worked at a company where the lead designer enforced mobile first and it made development so much easier.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Why?",
            "points": "1 point",
            "children": [
              {
                "comment": "IMO far saner tools, far saner defaults. And most problems are already solved you just need to adapt it to your business usecases.",
                "points": "69 points",
                "children": [
                  {
                    "comment": "Yea. But what about having visual feedback and an app you can show your friends and family. Is always nice to share your work :P",
                    "points": "11 points",
                    "children": [
                      {
                        "comment": "Do it the old way, with pictures of your code in your wallet.",
                        "points": "72 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "You can show 'em your passing test suite!",
                        "points": "19 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "I don’t know why you’re being downvoted. I get what you’re saying",
                        "points": "3 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "You still take pride in your work? Everyone look at Eager Beaver over here!",
                        "points": "4 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "their opinion on my work is not really matter. I get money and i'm satisfied",
                        "points": "1 point",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "What about it?",
                        "points": "-1 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "I'm ok with taking a paycheck and not having to deal with insanity if I don't have to. I also respect others that take pride in their work even if they have to deal the craziness.",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Same lol",
            "points": "-1 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "More job stability on the backend as well",
            "points": "-1 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I've really enjoyed building apps for Android but I have a very narrow enterprise use case:\n\nMDM controller app installs, no need for public app stores\n2 devices with stable OS versions, known screens, known hardware\nlow level access to device hardware through OEM mobility hooks and just complete control over the entire app environment from start to finish\nfull admin on every client device, up to and including nuking it / starting over / sending it back for mfg punishment\n\nWithout these things it seems like kind of a shit show, I don't know that I would want to do it otherwise tbqh.\n\nThe public play stores seem to be 50% of the pain I see and hear from mobile folks with the OS version whiplash + hardware diaspora making up the rest.\n\nOtherwise it's pretty nice, highly recommend it.",
        "points": "21 points",
        "children": [
          {
            "comment": "MDM is heavenly when your department controls it.\n\nIt quickly turns into hell if you're trying to deploy something and aren't the gatekeeper.\n\n(I'm giving myself consulting flashbacks!)",
            "points": "12 points",
            "children": [
              {
                "comment": "Yeah I can see that. I basically have the unicorn - complete control. Of course that means complete responsibility, but frankly, better this than the other way.\n\nAfter our first app deployment I thought about switching 'careers' from enterprise IT generalist to pure dev but after reading about the daily experiences of narrowly focused devs of all sorts I think I'll just keep code as one more tool in the toolkit instead.",
                "points": "4 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "In my darkest days, I was once on the hook in App Review for over 50 days while a SEV-2 smouldered in the background.\n\nThis is insanity. Just pull the submission and resubmit if it takes more than three days for Apple to review the release. Like what the fuck?\n\nIt’s obviously not ideal but you’re not powerless; you have agency, you can toggle state.",
        "points": "218 points",
        "children": [
          {
            "comment": "We pulled it after 2 weeks; resubmitted; they took another month to respond to us. We threw the kitchen sink. Expedite review, app review board, contacting dev-rel, everything. They had a question which got thrown way up the chain internally and stuck in the process.",
            "points": "216 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "This is insanity. Just pull the submission and resubmit if it takes more than three days for Apple to review the release. Like what the fuck?\n\nIt is obviously mentioning the long wait times we had earlier. There was literally a website just to track app approval time, now it just states that approval times have been greatly improved. Some years ago, 10 - 15 days would be an average wait time.",
            "points": "80 points",
            "children": [
              {
                "comment": "I've only professionally developed a single iOS app almost a decade ago and heard the horrors and had the pleasant treat of it taking only a 2-3 days. It was pretty end-stage/fancy by the time we submitted but I felt lucky...\n\nI will say, while maintaining that app, the seemingly random and confusing changes to the web portal/certs/keys/everything-in-that-realm was worst part by far... XCode/ObjC was a comparative delight back then IMO, no idea how it is now.\n\nWebdev is still a million times more flexible and by extension easier IMO.",
                "points": "18 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "almost 10 years ago? i was pushing like my fifth update for my companies app.\n\nWe purposely didn't show off all the app could do in screenshots so our competitor couldn't copy it exactly (easily).\n\nour app was for existing medical clients only (useless to generic public).\n\nIts flagged from apple as breaking rule 'irrelevant screenshot'\n\nnothing was irrelivant, we just did a few basic pages (login page, settings page, help page).\n\ntried to resubmit/appeal/etc... some douche wouldn't budge and after 5mo of iphone being behind Android's version, CEO caved and we showed all screenshots and competitor copied it exactly.",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Ive done this and got a warning from app review :(",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "It’s obviously not ideal but you’re not powerless; you have agency, you can toggle state. \n\nIt's kind of silly that you assumed they didn't try other things.",
            "points": "1 point",
            "children": [
              {
                "comment": "If it's \"In Review\" for 50 consecutive days, then it is necessarily not pulled and resubmitted",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "tl;dr web dev is hard and mobile dev has some of the same issues.",
        "points": "145 points",
        "children": [
          {
            "comment": "and more*.\n\nWhile traditional web dev frontend has some browser compatibility to worry about, it is nothing compared to the woes of operating system compatibility. I’ve seen the weirdest stuff happen because of some ridiculously stupid OS-level behaviour.\n\nAdd on top the issues mentioned by others regarding the duopoly of the App Store and the Google Play Store and their atrocious attitudes toward developers.",
            "points": "129 points",
            "children": [
              {
                "comment": "While traditional web dev frontend has browser compatibility to worry about,\n\nNowadays it's a small concern, the lack of good tools and the abundance of other ones who leave most issues unresolved is the biggest problem.",
                "points": "3 points",
                "children": [
                  {
                    "comment": "I agree, my point was simply that while browser-based frontend has its own challenges, mobile brings many more problems with it.",
                    "points": "3 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "On the web you have the monopoly of Google Search, AdSense and basically also Chrome.",
                "points": "-9 points",
                "children": [
                  {
                    "comment": "Not even remotely comparable to being forced to deal with the app stores.",
                    "points": "26 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I am confused by this tldr. I am a web dev and by and large the issues mentioned in the article are unique to mobile platform. Did you read it?",
            "points": "9 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "The backend boys need to know",
            "points": "39 points",
            "children": [
              {
                "comment": "We do, that's why we leave it well alone.\n\nAlthough that goes more for web than mobile. I preferred doing Java 6 back in the old days of Android than the current web shittery.",
                "points": "68 points",
                "children": [
                  {
                    "comment": "That’s honestly concerning.",
                    "points": "9 points",
                    "children": [
                      {
                        "comment": "Eh, I was kind of the same with jumping into mobile more than FE. I think one big thing is that react wasn't that big, CSS scared me off, and jumping into Java was at least a typed language. Typescript is fine (some REALLY cool things like union types), but it's hard to leave C# or Kotlin level typed languages.\n\nCourse back then I was a C++ dev, and I was more opinionated on types for little reason.",
                        "points": "5 points",
                        "children": [
                          {
                            "comment": "Thing is, modern „webshittery“ is closer to modern C# or Kotlin than that backwards mess that Java was back then (and still is to some extent).",
                            "points": "-13 points",
                            "children": [
                              {
                                "comment": "Maybe I'm looking back with nostalgia but I remember the general experience being easier. Typescript is a nicer language than Java 6, but it's the rest of things that come with front end web development that grinds my gears. The annoying package management, the debugging experience, bad error messages with the build tools, a million options for everything.\n\nI'm generally just a C# guy these days and the experience for me is night and day.",
                                "points": "5 points",
                                "children": [
                                  {
                                    "comment": "Yes, I‘m talking about the language. Voluntarily writing Java 6 today seems like masochism to me.",
                                    "points": "-6 points",
                                    "children": [
                                      {
                                        "comment": "Well yes, that'd be insane. But I just meant I enjoyed doing that more and had less general issues way back when I was doing than I do when I'm doing modern web development.",
                                        "points": "4 points",
                                        "children": [],
                                        "isDeleted": false
                                      }
                                    ],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "I did a lot of web and it is the wrong type of complexity. I lost the will for it when ECMAScript 4 was scrapped. It always felt more like kicking something to death to get something working.",
                "points": "8 points",
                "children": [
                  {
                    "comment": "Well, good news! In the intervening 21 years the language has changed a little bit.",
                    "points": "16 points",
                    "children": [
                      {
                        "comment": "The last time I did it in any professional capacity was about 6 years ago with React, Redux and Bootstrap. It still wasn't very fun then. I put in FlowType, TypeScript was not allowed and cleaned up all the Object.assigns being done to hack stuff in random places (maybe actions?). Everyone was much happier after, but not an adventure I ever want to complete again. And I cannot help myself, I practice annoyance driven programming :)",
                        "points": "1 point",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Woof",
                "points": "-2 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "I love my backends.\n\nWait, that sounds...",
                "points": "-4 points",
                "children": [
                  {
                    "comment": "\"I like back ends and I cannot lie....\"",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Mobile dev is much harder, IMO.\n\nA web app written 2 years ago will still still be possible to build and release. It might be riddled with vulnerabilities in libraries, but it will still work.\n\nA web site written 10 years ago will probably still behave properly on modern browsers. Making a small change and re-deploying will likely be trivial.\n\nA mobile app that hasn't been touched for a year might not even compile anymore, and it's very likely not going to make it through an app store review.\n\nThe worst thing about mobile dev is keeping up with the breaking changes IMO.",
            "points": "23 points",
            "children": [
              {
                "comment": "This objectively NOT true. There are iOS examples on Apple's site from 2010 that still compile and run just fine. By comparison, I often can't even run Node apps from more than a year or two ago without ending up in dependency hell. Modern Javascript web applications sit atop a brittle mountain of interlinked dependencies against the backdrop of a rapidly changing landscape (browser standards). Likewise, let's avoid discussing hype cycles and the excessive time spent learning new paradigms and frameworks, only for the \"community\" to quickly sour on them in favor of the next shiny new thing... (so like, Next.JS is bad now?!)\n\nNative mobile devs who have done both will attest to this. It's not even a comparison how much more sane the development experience is. I have no idea of which \"breaking changes\" you speak.",
                "points": "4 points",
                "children": [
                  {
                    "comment": "Even with old Android code, you type ./gradlew build and it just works. The only dependency is java.\n\nI can spend hours trying to get old web code to work. It's an absolute nightmare.",
                    "points": "1 point",
                    "children": [
                      {
                        "comment": ">./gradlew\n\n>old",
                        "points": "4 points",
                        "children": [
                          {
                            "comment": "[sobs uncontrollably in 11 year old legacy Android]",
                            "points": "0 points",
                            "children": [],
                            "isDeleted": false
                          },
                          {
                            "comment": "When did android first start using gradle? I used it in 2015 and I'd class 9 years ago as pretty old in mobile software terms.",
                            "points": "0 points",
                            "children": [
                              {
                                "comment": "in 2015 I was 7 so I don't know :^)\n\nbut ant AFAIK",
                                "points": "0 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "This is a major issue with ‘web apps’ on the desktop too.\n\nMy old company hired a bunch of web devs to use Node JS to recreate its cross platform desktop licensing app, previously written in Qt and C++. Not a complicated app. Their reasoning was that they couldn’t find C++ devs but web devs were plentiful.\n\nAfter a year the new app started breaking, not running on user’s machines or refusing to render content correctly because the libraries it used were increasingly outdated or issues with certificates.\n\nI’m addition, the C++ devs had to write lots of little native helper tools to workaround bugs and limitations in the Node JS stack.\n\nIt became a MASSIVE support time sink and eventually had to be scrapped.\n\nBut the original Qt/C++ app from 2008, still works flawlessly to this day.",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "In my darkest days, I was once on the hook in App Review for over 50 days while a SEV-2 smouldered in the background.\n\nThat's why we need thirt party appstores. At least android has f-froid although it's a bit clunky.",
        "points": "57 points",
        "children": [
          {
            "comment": "We should push towards PWA. The tech is already there and it's de-centralized. However, it faces one big fundamental issue; it's against the benefits of Google/Apple. As such, the option to install PWA is often not promoted by the browsers we use, nor is it advertised to users even as an option.",
            "points": "28 points",
            "children": [
              {
                "comment": "We should push towards PWA.\n\nWe should not. I have absolutely no desire to work with JavaScript or any web tech.",
                "points": "14 points",
                "children": [
                  {
                    "comment": "The web developer urge to try and force everyone in the world to write goddamn Javascript",
                    "points": "13 points",
                    "children": [
                      {
                        "comment": "The joke's on me. I switched from web to app development to avoid javascript.",
                        "points": "5 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "Well don't write JavaScript? PWA doesn't dictate your tech stack.",
                    "points": "6 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "PWA works really well on Android though. Apple is doing a ton of shit-fuckery to prevent PWAs from working well on iOS, in the name of security and what not. Trying to get PWAs on Apple are mildly remenescent of the good old IE6 days and I have been strongly disabused of Apple's commitment to users while working on the same.",
                "points": "11 points",
                "children": [
                  {
                    "comment": "The Apple side of things has has changed significantly recently. Here's an article about it: https://world.hey.com/dhh/native-mobile-apps-are-optional-for-b2b-startups-in-2024-4c870d3e",
                    "points": "1 point",
                    "children": [
                      {
                        "comment": "I am building one now and the Apple side of things is still not very good. Much better than what they were a couple of years back, but still in the realm of poor.\n\nI am going all-in on PWAs presently and Apple has been consuming around 80% of our effort for honestly, a not-so-good experience. On Android, everything just works.",
                        "points": "2 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Doesn't F-Droid usually take longer to get new releases out than the Google Play Store?",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Except for the AppStore issue, this is how programming outside of very narrow field (backend/microservice) feels, I don't really see anything hard about it.",
        "points": "8 points",
        "children": [
          {
            "comment": "I enjoy mobile dev for the challenge.\n\nIt’s a battery powered computer with inherently unreliable internet and execution that can be interrupted at any point.\n\nIt’s like programming on hard mode.",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Mobile it's always a pain.. prefer to work on desktop stacks like C# / XAML (for the front part), especially on internal business software's where UI/UX don't care a lot. If I realy need to work on mobile, best thing to use toolkits like reactive native where you just need to copy / paste / adapt and survive...",
        "points": "4 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I don't mind web dev because you can build front ends that don't need maintenance. But iOS apps are a nightmare because they require so much maintenance year after year.",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I'm glad I never got into mobile dev",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "mobile wouldn't be this hard if they embraced the browser but apple and google realized they can't double dip with their \"app-stores\" operating like a mafia where they decide who can sell stuff on their turf , breaking the knees of anyone that doesn't pay the fees and potentially burning down the whole business if they don't comply with their made up rules.it's even worse because if your business is too successful they will straight up steal your shit and put you out of business.\n\nthe Mobile market is what Microsoft tried to pull during the 90's and they failed back then because the government was somewhat still functional but now these failed states can't even enforce basic anti competition laws\n\nOh one more thing it sound crazy but Android is a carcass like it's dead dead.it's so fucking sad how it went from might be viable option like linux to watered down iOs\n\nGoogle tried to revive it by doing 5 consecutive UIs overhauls but they failed miserably",
        "points": "1 point",
        "children": [
          {
            "comment": "That’s why Apple is so harsh with the App Store - they saw what happened to Microsoft’s monopoly in the 90s and will do anything to avoid the same fate",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "As somebody who has done a good amount of front-end and back-end dev, I’m always surprised by the attitude that back-end dev is fundamentally more challenging in some way. Writing user-facing application code typically involves a considerable amount of operations and context that are happening concurrently, in a way that you often don’t have a great idea how the user will approach it or in what order things will happen. It can be an extremely challenging and error-prone endeavor if you’re not pretty familiar with how to lay out your application code to deal with that level of asynchronicity. On the other hand, back-end code is often considerably more deterministic, with fairly distinct entry and exit points.\n\nI suppose there’s a feeling that front-end code is easier to crank out if you just do it poorly? I don’t know. There’s a lot of absolutely terrible front-end code out there.",
        "points": "3 points",
        "children": [
          {
            "comment": "There’s a saying “I tried to make it idiot proof but they just keep making better idiots”.\n\nAll that’s saying is with front end you really never know how someone will use your program. I’ve been a native iOS mobile developer for 10 years now and it’s really shocking the amount of edge cases you have to solve for. For instance, you have to test for all combinations of user actions BUT ALSO when the app is online, offline, coming back from the background, opening from a closed state etc.\n\nSyncing data between the phone and the server is an entirely different beast. And if the stake holders want a completely functional offline mode then you will mostly want some sort of “diffing” engine to determine what data is stale.\n\nAll that being said I’ve never had more fun or been more motivated to code than when I’m developing apps.",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I don’t think the dev portion is but the responsibility level is. You have to think about constraints and performance or the whole show goes down and people want to know why, now.\n\nIn the flip side you can get pretty far writing some serious garbage that barely works on front end. If you try to spend time on performance or consistency there’s always someone else around who doesn’t care and will look great to the bosses. I think this is why (at least in modern times) the backend devs are still considered more serious or whatever.",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Agreed. I love front end and back end, absolutely hate mobile dev. Tried my hand at Flutter (using two separate langs was not an option) and yes, while you can get a decent app going, the App/Play Store rules and processes are terrible, not to mention flutter is a clusterfck in terms of readability and overall use. NEVER again.\n\nEdit: pls don’t mention the awful thing called React Native. Frameworks/whatever are supposed to make life easier, not harder.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "i wonder when mobile devs just moves to electron like what's happening on desktop (except for when performance is integral),\n\ncause who really wants to deal with whateverthefuck is thought up by whosever ego is promoted to control of any particular part of the apple/google ecosystems?",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I'm not touching mobile because it's dominated by Apple and Google OSes, one of which is a closed garden (which I'm very much against) and another had trash development experience when I've researched it.",
        "points": "-3 points",
        "children": [
          {
            "comment": "Not sure why you got thumbed down.\n\nReleasing an iOS app without apple hardware is hard. You'll need an account. Same with Google.\n\nIt's prohibitive, even if the steps to get around are \"simple\" the app store model is fundamentally flawed.\n\nLook at the court battle for epic to get their game on an app store",
            "points": "10 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "the DX on both is pretty much on par with each other nowadays, as long as you use the new UI toolkits and both are great. the only thing that’s still trash IMO is resource management, especially in multiflavour apps",
            "points": "11 points",
            "children": [
              {
                "comment": "How's Compose nowadays? The last time I tried it, it was slower to develop for than XML because there was a compilation step",
                "points": "0 points",
                "children": [
                  {
                    "comment": "I haven’t had any issues with compilation times, but I always setup multiple modules for each feature so it’s just the initial build that might take long\n\nkotlin 2.0 is coming soon with a rewritten compiler (K2). haven’t seen any benchmarks of that yet but they promise improvements on the compiling speed part\n\ncompose, specifically material 3, is sometimes really annoying to work with. many basic components are in experimental stage and you’d expect to have stable implementations after 3 (?) years. otherwise it’s great and the ecosystem is evolving quite fast",
                    "points": "5 points",
                    "children": [
                      {
                        "comment": "Glad to hear it, thanks. I see what you mean about the experimental part. The joke at my old workplace was that Android code is either in alpha state or deprecated, no in-between",
                        "points": "2 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "It's pretty good. Have used it daily for the last 3 years and the progress has been great.\n\nHonestly I don't have any complaints other than some odd choices for navigation, but even that is fixable with libraries if you're so inclined.",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "They might be on par but it's still bad. Being forced to install their own custom IDEs on their custom hardware (for apple) or jumping though hoops to compile something is a good DX in your opinion?\n\nTell a developer not familiar with the tools to CLI compile an Android app (from a fresh Ubuntu install) vs a go backend, and then tell me the DX is good",
                "points": "-2 points",
                "children": [
                  {
                    "comment": "I develop KMM apps so I can do everything in AS/IJ. I just use xcode to edit SwiftUI layouts. all you need is the CLI toolkit (and macOS obviously) to do that\n\nyou’re neither forced to use AS or IJ, but those happen to have the best support for the ecosystem. you’re free to use, say, VSCode — download all the necessary plugins and toolkits, a template and you’ve got yourself a running android project\n\nbut I don’t see any reason to do that since this setup is inferior and will always stay that way until Google starts supporting it and there is a ton for reasons neither Google nor the community want that",
                    "points": "-1 points",
                    "children": [
                      {
                        "comment": "you’re neither forced to use AS or IJ\n\nI didn't say you were. Only if you don't you need to jump through hoops\n\ndownload all the necessary plugins and toolkits, a template and you’ve got yourself a running android project\n\nExactly, much more annoying that a typical setup. I think there's a value in being able to do things from the commandline directly, so you're able to automate any part of the process. Sonce every tutorial focuses on setting up everything for IDEs I find the experience when trying to compile something very lacking.\n\nAnd even if AS or IJ are a better fit in the long run, you can't deny it's bad experience to not natively support the most popular editor and force devs to either learn a new tool or have a subpar experience",
                        "points": "-2 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "the DX on both is pretty much on par with each other nowadays\n\nI'm not comparing Apple and Google DX, because I haven't seen Apple's (though I know that you can't effectively work with their products unless you buy in their devices).\n\nas long as you use the new UI toolkits and both are great\n\nI assume so, that's why I've left the \"when I've researched it\" disclaimer.",
                "points": "-8 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "skill issue",
            "points": "-7 points",
            "children": [
              {
                "comment": "Which skill? Fighting against convoluted development pipelines? Yeah, I'm not great with that, though I have some experience with embed.",
                "points": "10 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "PWA and webview with some extra native functionality for iOS and away you go...",
        "points": "-35 points",
        "children": [
          {
            "comment": "You never wrote an app, did you?",
            "points": "35 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "webview? Are you serious?",
            "points": "27 points",
            "children": [
              {
                "comment": "Some cross platform frameworks are experimenting with wasm using canvas to deliver experiences that are very app like and don’t have language limitations caused by transpiling to JS.",
                "points": "-15 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "There is absolutely no reason I would want to use JavaScript or any of it's ilk.",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Another clickbaity title saying that \"a part of programming is hard\". Everything is as hard until you learn it, we all know. git --gud",
        "points": "-39 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "reminder that substack is a nazi site, try to find a different platform\n\nedit: I said what I said, cowards",
        "points": "-25 points",
        "children": [
          {
            "comment": "I think \"nazi site\" is a little disingenuous; but if you don't mind paywalls I also cross-post to Medium - https://medium.com/@jacobmartinbartlett/mobile-is-actually-pretty-hard-1c86501ab647",
            "points": "14 points",
            "children": [
              {
                "comment": "the idea is to not support a nazi site by using it",
                "points": "-2 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "It actually doesn’t https://www.blockedandreported.org/p/episode-198-actually-substack-doesnt. Maybe try not to be so soft.",
            "points": "-1 points",
            "children": [
              {
                "comment": "So the part where you can actually subscribe through Substack to actual white supremacist newsletters, doesn't subscribe you to those newsletters?",
                "points": "-1 points",
                "children": [
                  {
                    "comment": "Any examples.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "So because I can go to a department store and buy all the ingredients to build a pipe bomb that I could accidentally detonate and hurt myself department stores are pipe-bomb supporters and we should just go somewhere else?\n\nOne of the core ideals of free speech is that you support speech from the people you disagree with; if the speech is truly bad it will be proven as such and get ignored.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "- Sent from Reddit\n\n      - Sent from iPhone",
            "points": "-2 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "meh",
        "points": "-21 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "React Native is now synchronous and seems a lot more performant than it used to be.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Cool",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19ad9ya",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.javatpoint.com/contiguous-memory-allocation-in-operating-system",
    "title": "Solving the Memory Puzzle: How Contiguous Memory Allocation Boosts Operating System Performance",
    "points": null,
    "comments": [
      {
        "comment": "Whoever wrote this article is a clueless crayon eater who has no idea how virtual memory works in any modern OS.",
        "points": "6 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Reads like gpt written. Lots of rephrasing with of the same two things. It conveys no new information but by using differently built sentences the reader often doesnt notice it. /s",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Well, it’s more about cache locality. Storing things contiguously in memory can help with that, unless you exceed cache lines.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19ac03a",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://medium.com/towardsdev/netty-source-code-analysis-bytebuf-ab279d9f082d?sk=fa2a4f9bbf72436d685db2793a04f940",
    "title": "Netty Source Code Analysis-ByteBuf",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19ab4rj",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://medium.com/airbnb-engineering/scaling-airbnbs-payment-platform-43ebfc99b324",
    "title": "Scaling Airbnb’s Payment Platform",
    "points": null,
    "comments": [
      {
        "comment": "Digest Version:\n\nThis post, written by Angela Zhu & Karen Kim from Airbnb Payments Engineering, delves into the evolution of Airbnb's payment platform. Initially, Airbnb's transactions were offline and cumbersome, leading to the decision to handle payments in-house. The early system was simple, using PayPal for guest payments and paper checks for hosts. As Airbnb grew internationally, the need for a more sophisticated, global payment system became evident. This led to innovations like integrating local payment methods, such as Boletos in Brazil, and addressing the complexities of currency conversion and regional payment preferences. The payment infrastructure underwent major changes, moving from ad-hoc integrations to a more structured system with a Billing Interface API, a unified Payments Gateway, and a scalable Financial Data Pipeline. These upgrades facilitated easier integration of new payment methods, improved financial reporting, and supported Airbnb's global expansion. The post highlights Airbnb's commitment to owning and continuously improving its payment system, which has been pivotal to its success as a global travel platform.\n\nIf you don't like the summary, just downvote and I'll try to delete the comment eventually 👍",
        "points": "3 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19a6un3",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://gabrielgambetta.com/remakes.html",
    "title": "Emulator-Backed Remakes",
    "points": null,
    "comments": [
      {
        "comment": "The idea is good, but not new. For example see this version of R-Type with the original graphics and new 3D.\n\nhttps://youtu.be/ppchIpOJxHs",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Isn't this basically the same thing as texture replacement, which is available in many emulators for 3d consoles?",
        "points": "1 point",
        "children": [
          {
            "comment": "No. This is equivalent to replacing drawObject() and such with entirely new implementations running on top of a modern 3D api using all new geometry, textures and shaders.",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Kind of feels like what RTX Remix will allow — or what Reshade presently does (injecting its own drawing calls)",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19a601u",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://wherobots.com/exploring-global-fishing-watch-public-data-sedonadb-geoparquet/",
    "title": "Exploring Global Fishing Watch Public Data With SedonaDB & GeoParquet",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19a55gl",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://github.blog/2023-10-30-the-architecture-of-todays-llm-applications/",
    "title": "The architecture of today’s LLM applications",
    "points": null,
    "comments": [
      {
        "comment": "Main Points:\n\nThis GitHub Blog post outlines the essentials for building Large Language Model (LLM) applications. It covers five critical steps: identifying a specific problem, selecting an appropriate pre-trained LLM, customizing the LLM for specific tasks, establishing the app's structure including user interface and prompt construction tools, and conducting real-time app evaluations. The article emphasizes the importance of each step, from the initial focus on a manageable problem to the customization and online evaluations critical for effective LLM app development. Additionally, it includes real-world examples like NASA's geospatial AI model and Johns Hopkins' conversational AI agent for medical guidance.\n\nIf you don't like the summary, just downvote and I'll try to delete the comment eventually 👍",
        "points": "-2 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19a4d4f",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://github.com/djmill0326/basic",
    "title": "[Release] basic-rust v1",
    "points": null,
    "comments": [
      {
        "comment": "I can’t figure out what this is supposed to be. It literally just prints hello world and has a bunch of unused structs for File and Log that don’t do anything while confidently declaring itself “negative cost”. What is v1 about this?",
        "points": "2 points",
        "children": [
          {
            "comment": "This repo isn't finished. You could check my other repos to get an idea of what I'm trying to build.",
            "points": "-3 points",
            "children": [
              {
                "comment": "This definitely wasn't release-worthy though. Not sure why I posted in this format",
                "points": "-1 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19a4921",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://bencane.com/short-read-code-for-tomorrow-balancing-timelines-and-maintainability-aa67b8b895ce?source=friends_link&sk=9aa9c8e9ba8095758883ba6e0011a91f",
    "title": "Short Read: Code for Tomorrow, Balancing Timelines and Maintainability",
    "points": null,
    "comments": [
      {
        "comment": "The first solution that works is often not the most maintainable solution. That's when it takes some discipline to not open a PR at that moment and instead do the refactoring work that'll make life easier for future-you. Thanks, I like this \"micro-blog\" style post.",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "\"Do good and slow, don't do bad and fast\"\n\nAdvice given by a guy who has never worked in startups and works in huge and slow monopolist enterprise that don't need to verify ideas or experiment coz it has a huge money pipe already.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19a3rlt",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://testing.googleblog.com/2021/06/how-much-testing-is-enough.html",
    "title": "How Much Testing is Enough?",
    "points": null,
    "comments": [
      {
        "comment": "As the codebase grows and reaches a point where numbers of functional units are available to test as a group, it’s time to have a solid base of integration tests. An integration test takes a small group of units, often only two units, and tests their behavior as a whole, verifying that they coherently work together. Often developers think that integration tests can be deprioritized or even skipped in favor of full end-to-end tests. After all, the latter really tests the product as the user would exercise it.\n\nI am of a firm opinion that integration tests have a bigger value for the software quality in general and especially over time - than unit tests.\n\nUnit tests are fine for algorithmically complex units and to expose the low-level software design, but oftentimes they are not very useful.\n\nTheir purpose simply is not to test many things that should be tested, like performance, threading, load, observability and the correctness of the interaction between the units and the other parts of the whole system which is where, IMO, most of friction is.",
        "points": "75 points",
        "children": [
          {
            "comment": "Unit tests establish trust to enable re-use. But testing each link individually never excludes testing any and all chains made up of them.\n\nWhen hunting down a bug I find unit tests valuable to guide me towards its most likely location. But I use integration tests to initially re-produce and subsequently ensure it stays fixed.",
            "points": "22 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "You use production observability for load, threading, performance, etc. that’s not tests that exercise the code are for.\n\nWhen we talk unit test and integration test or whatever, it’s in the context of testing the logic of the program and not necessarily the machine component operations. Again, use observability to monitor that instead with alarms to the devs cellphone (and convert some to automated load tests once you want to lock in a metric)",
            "points": "16 points",
            "children": [
              {
                "comment": "You use production observability for load, threading, performance, etc. that’s not tests that exercise the code are for.\n\nI have to disagree - or I don't understand what you are saying?!\n\nLeaving these aspects untested before code ends up in production is not enough IMO.\n\nFor example, take performance under load. However good the profiling data is in your production, it will be more difficult to get it out and interpret it than if that was done earlier, also because there's no prior data.\n\nAnd then, surely I want to be able to somehow assess the change in performance over the software lifetime before letting it put in production?\n\nI want to know more, and sooner, about how the software behaves. Production observability is too late.",
                "points": "10 points",
                "children": [
                  {
                    "comment": "Building a realistic load test for a large system is often impractical as so much of performance is data dependent in ways you can't control on even predict.\n\nThere are probably cases where certain important paths can be performance tested reliably but it's not a universal trait of systems.",
                    "points": "11 points",
                    "children": [
                      {
                        "comment": "Neither of the situations y'all outline are universal. Some products will run synthetic load tests in their delivery pipeline or before release, and those businesses don't find it impractical to build and maintain those processes. Some businesses only rely on product monitoring.\n\nJust as some businesses find it impractical (not cost effective) to build and maintain integration tests.\n\nIt's valuable to talk about how things are working in different environments, the tradeoffs, etc. But we shouldn't assume there is a universal right or wrong option that fits all products and environments.\n\nFor instance, relying on observability requires us to have enough data (people, activity) in a given time frame and a low enough risk that a given change in that time frame could violate an SLA (or whatever the business constraints are), which could also take into account the speed we can deploy a new change and other factors. Then there's situational factors, like the skills and experience of the people setting the strategy and implementing the bits, budget to bring in outside expertise or new tooling and services, etc.",
                        "points": "5 points",
                        "children": [
                          {
                            "comment": "Did people stop reading Fred Brooks (Mythical Man Month etc) at some point? https://en.wikipedia.org/wiki/No\\_Silver\\_Bullet",
                            "points": "1 point",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "Of course, for an E2E test, this is not trivial, and indeed I see our perf. test people struggling to find for representative data - but eventually they do obtain them.\n\nThere's also this: a bigger system will have enough pieces that can be perf. tested in isolation. There, one mostly looks for steadiness (or hopefully perf. increases 😉) across time.",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "That's what I meant. You can load test a desktop app offline but if we're talking about Web scale that's a whole different set of constraints.",
                        "points": "0 points",
                        "children": [
                          {
                            "comment": "You can load test anything, the problem is the range of inputs to many applications is essentially unbounded. e.g. There is no single performance test that is applicable to software such as Excel.",
                            "points": "2 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "There is a blend, I would say on totally new digital solutions replacing analog solutions you can't reasonably measure load... even a beta test isn't sufficient because it's biased.\n\nProduction \"is\" your first real load testing environment, afterwards you capture baselines and test again.\n\nThat said... you need to know capacity before reaching production and load testing should still be performed to know what X instances of Y solution can handle so you can do things like configure auto-scaling, etc.\n\nThe question isn't really \"how much load we are expecting\" it's more of an assertion of \"This is how much load on this hardware this software can handle\".\n\nWe refer to them more as stress tests, we baseline to memory and CPU capacity and simply report on how many requests we process; so long as we stay below the 70% watermark we a-okay the load test and ship.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "With testing it is good to let the numbers guide you. Most people who track the numbers stop using unit tests because the ROI is so low, integration test tend to be much better when it comes to automated tests. That said, if you track the numbers, by far the most impact results from combining several layers of reviews and tests. So depends on the project, but often requirements review, design review, code review, coverage tests. But not all projects are the same so is good to track defects found per hour and do root cause analysis to understand how well different methods of finding defects are working.\n\nFor most projects, quality is free. The cost of putting in good processes is less than the cost of dealing with bugs reported by users.",
                "points": "0 points",
                "children": [
                  {
                    "comment": "Who track the numbers? I thought we were all programmers tracking the numbers relevant to make sure our programs are running fine?",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "\"...but oftentimes they are not very useful\"\n\nI think you forgot about loosely typed languages, where you need unit tests for guarantees that a static type checker would provide out of the box... :)",
            "points": "2 points",
            "children": [
              {
                "comment": "Yep, I like to forget these! 😉",
                "points": "2 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "The purpose of unit tests is to write cleaner code. Nothing more useful than that.",
            "points": "3 points",
            "children": [
              {
                "comment": "I agree with this 100%. Integration/API tests are great for functional testing. But you can integration test the most horrendous code easily.\n\nYou can't unit test shitty code easily, you have to work really hard to do it. If you're going to work that hard anyway, might as well spend that time making your sut easier to test. That leads to awesome code quality.",
                "points": "5 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "How Much Testing is Enough?\n\nWhen you trust them. If you make changes in the code and green build means you immediately push the deployment, it means you have enough good tests. If you don't trust green builds and you still have rounds of manual testing of some sort, then you're clearly missing something.",
        "points": "3 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Unpopular opinion\n\nUnit tests imo is only for advanced business calculations or critical processes that has to be in a certain way.\n\nMoqing API contracts is borderline insane to me.\n\nIf you change an input/output and you don't know what it will effect you have bigger issues than failed tests in your software.\n\nTesting = time. Time is money, bussiness want to make money and thats why we should focus on delivering features.",
        "points": "4 points",
        "children": [
          {
            "comment": "I use TDD and unit tests to drive my implementation and assist in my software design efforts.\n\nI just paired with someone today who got stuck by trying to write the whole implementation by themselves. When they started with the tests using TDD to drive it it they didn't lose control.\n\nUnit tests are a tool used for various purposes, it's not \"only\" for anything can only see absolutism in the past few comments",
            "points": "4 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I don't think it's unpopular opinion. Unit tests are great for testing specific \"units\" like an algorithm, separated from everything else. But as such, they tell you absolutely nothing about the state of the system. You can have 100 green tests of an algorithm, and yet the system doesn't work because this algorithm is not used at all, or invoked with wrong parameters etc.\n\nWhat matters is if the system actually works as expected - for given inputs provides expected outputs. If this is achieved by calling one method or another, or using this class or that class, or calling some function 2 or 3 times (yes, people check stuff like that on mocks, and then a tiny refactor breaks hundreds of tests) is completely irrelevant.",
            "points": "6 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Yesterday I wrote unit tests for a front-end reducer because I had some complex page state that wasn't working correctly for a 6 step process. 100% UX and presentation logic, not business logic.\n\nA common set of tests I add for front-end input components is grabbing The Big List of Naughty Strings and wrapping a harness around them to verify the component logic.\n\nI have custom hooks (React) for making API calls, they're critical enough that I also write tests for each of them with mock service worker responses so I know they work exactly as expected with different responses and network conditions.\n\nI have a couple business service calls on the backend that have mocked calls to the Slack API because I'm not going to rely on artisinally testing them manually and assume they'll work forever, and I'm also not going to tie my delivery pipeline to Slack's uptime or deal with the concurrency issues of a shared external resource for those particular tests.\n\nOpinions are great, and no choices are universally good, but I'd advise not taking hard stances that assume large portions of the industry simply haven't seen the light yet on a particular topic.",
            "points": "3 points",
            "children": [
              {
                "comment": "Everything you mentioned are great used of unit tests. And also from my point of view are all the things you listed are \"advanced business calculations\" or \"critical processes\".",
                "points": "4 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "We always create integration tests for user stories. That way we don’t push out a change that breaks some old user story we forgot about. Unit tests are not good a catching those kinds of issues.\n\nWe make unit tests for units that have lots of branches in logic or can be described as complex. We typically test all branches in those cases.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Testing is a cost saving measure, where you try to find most of the bugs in as little time as possible. It's nice to have, because realistically, no one is going to rewrite their codebase to make it easy to prove, and then write 5x as much in a proof in Coq or Agda or any proof assistant.\n\nStatic typing is an attempt to mix formal verification with programming code. Ultimately, that leads to the programmer doing two things at once, simultaneously being forced to write and prove their code. The reason why static typing seems to be optional for most programmers is because the way we reason about our code is often not capturable in a typing relation.\n\nSo basically, static typing captures some bugs, and hopefully testing catches the rest. But often our users let us know what's wrong.",
        "points": "1 point",
        "children": [
          {
            "comment": "Test is <hundreds of comments stating something completely different from each other>",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Agree, testing is about ROI. Tracking defects found per hour and doing root cause analysis help pin down where to put resources. Not all projects are the same, and different projects benefit from targeting different areas.\n\nCaper Jones has some good research papers. This is a well researched topic, lots of good books and papers available.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I hope you like the summary:\n\nThe post addresses the perennial question in software development: \"How much testing is enough for a software release?\" Recognizing that the answer varies depending on software type, purpose, and target audience, it suggests a flexible approach rather than a one-size-fits-all answer. Key recommendations include documenting testing processes and strategies, establishing a solid foundation of unit tests, not overlooking integration testing, conducting end-to-end testing for critical user journeys, understanding and implementing various testing tiers, gauging code and functionality coverage, and using field feedback to refine testing processes.\n\nIf you don't like the summary, just downvote and I'll try to delete the comment eventually 👍",
        "points": "-31 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "That much testing that not a single bug can pass to the final project.",
        "points": "-12 points",
        "children": [
          {
            "comment": "This... is not how testing works.",
            "points": "7 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I find that unit tests and integration tests mean very different things to different ppl.\n\nSome ppl wil claim unit test should only cover a single class and all dependencies should be mocked. Iam not as I think this way you end up with many meaningless tests that just increases coupling to the code.\n\nIam of the opinion that you use the tool or tools best suited for the job.\n\nIs it a REST api? Just integration test it, it's the natural stable interface for it. You don't always need unit tests.\n\nDo you have some complex algorithms? Unit test them. Mock dependencies only when that gives value, for example you usually mock out IO as it makes unit tests slower, potentially flaky, harder to run etc. My point is mocking should have a purpose and if there isn't one dont mock. Iam pointing this out specifically as I have seen countless projects where tests had so many mocks to the point the whole test was worthless and unreadable.\n\nIn the end all that matters is having a good test and there isn't a single type of tests that's better or should take priority over the others. They are different tools and it's up to you to pick what's best depending on the situation.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Have found integration testing to be way more useful for the internal SPA I maintain",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19a3bfr",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.youtube.com/watch?v=VHHT6W-N0ak",
    "title": "Torvalds Speaks: Impact of Artificial Intelligence on Programming",
    "points": null,
    "comments": [
      {
        "comment": "This is incredibly refreshing to see.\n\nHe's just talking in a sensible way. He's not just shit-talking AI but he's also not uncritically raving about AI takeover of everything, he's just cautiously optimistic.\n\nHe outright says that it's not his area of his expertise, and he talks about what he thinks is a valid use-case and how it may help people.\n\nThe interviewer keeps trying to push the FUD aspects, and Torvalds doesn't feed that, it's just a steady and fair \"it's a tool that might help, tools can be flawed, people are also flawed\".\n\nEveryone should take a lesson from this. Torvalds might go off the chain when it comes to operating systems, his area of expertise, but he demonstrates excellent restraint when it's not his field (at least in this instance).",
        "points": "267 points",
        "children": [
          {
            "comment": "Everyone should take a lesson from this. Torvalds might go off the chain when it comes to operating systems, his area of expertise, but he demonstrates excellent restraint when it's not his field (at least in this instance).\n\nTo be fair he doesn't really do this anymore. His standards and expectations haven't changed but he doesn't really go on angry rants anymore and has apologized for doing so in the past.",
            "points": "15 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "It's so irritating how the discourse on Reddit, for anything really, is always so insanely extreme. Any topic about AI I've seen on reddit lately is full of extreme nuts, whether for or against AI, that have no fucking clue what they are talking about.",
            "points": "53 points",
            "children": [
              {
                "comment": "I guess that those who are restrained often don't take part in the argument. So you are left with experts and fools who think that they are experts.",
                "points": "31 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "Any topic about AI\n\nCould just be:\n\nAny topic",
                "points": "3 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "Not just AI, open any comment section and most comments are extremes. Sports, movies, games, tech, everything",
                "points": "2 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "I'm convinced the fastest way to get death threats in Reddit is to just post an innocent AI generated picture.\n\nPeople go absolutely batshit insane at making a picture of omelette sunflowers :(",
                "points": "2 points",
                "children": [
                  {
                    "comment": "The average, common outdoor variety of sunflower can grow to between 8 and 12 feet in the space of 5 or 6 months. This makes them one of the fastest growing plants.",
                    "points": "4 points",
                    "children": [
                      {
                        "comment": "",
                        "points": "",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I wish Torvalds was the mascot for “tech bros” instead of VCs like Musk, even if he can be a bit of an asshole at times. We’d probably be less hated.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Code reviews - Shines\n\nReview code - Shines\n\nFinding bugs - Shines\n\nSuggesting coding patterns you want and suggest to LLM - Shines\n\nExplaining error messages - Shines\n\nWriting code from scratch - Mediocre\n\nArchitecting a solution - Mediocre/Poor\n\nUnderstanding code or solutions it has no clue about - Poor\n\nContextual multi-file or multi-domain code understanding - poor\n\n-- We are all talking about ChatGPT here just in case anyone was wondering.",
        "points": "671 points",
        "children": [
          {
            "comment": "Exactly matches my experience with it. One other \"poor\" mark is code context. Getting it to give you suggestions on code that relies on code from multiple files can be annoying if not impossible.",
            "points": "214 points",
            "children": [
              {
                "comment": "Pretty sure copilot reads your other vs code tabs",
                "points": "25 points",
                "children": [
                  {
                    "comment": "I've been using it for a while now and when I use Copilot Chat it only will see the tab you have focused. Sometimes it acts like it doesn't even see that so I have to highlight the code I want it to consider. But it for sure doesn't see other files in the project when asking it questions.",
                    "points": "18 points",
                    "children": [
                      {
                        "comment": "In vscode you can now do @workspace to have it reference all files",
                        "points": "14 points",
                        "children": [
                          {
                            "comment": "Really?! Does that only work if you have a workspace saved? I usually don't bother to do that.",
                            "points": "1 point",
                            "children": [
                              {
                                "comment": "If you open a repo (which is 95% of the time), @workspace will analyse the entire project.",
                                "points": "6 points",
                                "children": [
                                  {
                                    "comment": "",
                                    "points": "",
                                    "children": [],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "I've been using Copilot in Rider until about a year ago (not allowed anymore at work), and it seemed like it read all my files.\n\nWe had an in-house framework used to generate some web components and pages from them, and it correctly recommended how it should be used. It even worked with empty files, I assume based on the directory and other files in similar places.",
                        "points": "2 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "",
                        "points": "",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "And yet it constantly produces code referencing non-existing fields.",
                    "points": "2 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Let's use it for what it is good at.\n\nIt's a tool, like a fire axe.\n\nIf it gets too smart, we can use the fire axe on it. 😸",
            "points": "92 points",
            "children": [
              {
                "comment": "If it gets too smart, we can use the fire axe on it. 😸\n\nFor now. Hehehe.",
                "points": "8 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "From my experience, it is way more prone to introducing subtle bugs rather than removing them. I'd also would need to watch the talk itself, because again from experience, it cannot do code review in any helpful capacity, but that really depends where you put emphasis on the cr process.\n\nAnd the worst of all, it gives you a false sense of correctness; in which it is even worse than stack overflow.\n\nAt the other hand, the most value I've seen from it is to reduce tedium if you know precisely what you wish to see as an output.",
            "points": "84 points",
            "children": [
              {
                "comment": "AI code review is full of suggestions like “your if condition doesn’t account for None”. Never “why are you writing binary search from scratch when it’s already in the standard library?” or “the third party library you’re about to make us dependent on has serious open issues with cases that matter to us and no active maintainers”.",
                "points": "97 points",
                "children": [
                  {
                    "comment": "I actually think your second point is something it might be great at in the future. Hopefully not worded as such! I could see it doing a decent job at researching the 150 dependencies pulled in when pulling in one random framework and telling me which ones are suspect based on a whole range of criteria (open issues, last commit, security issues, poor code, etc).",
                    "points": "9 points",
                    "children": [
                      {
                        "comment": "It's a tricky thing for an AI to evaluate I think. In my experience LLMs are great at doing things that have lots of representation in training material (e.g. coding in languages where every standard library function appears in thousands of github repositories). It's really bad at doing research into long tail things -- even if you could find a way for it to scan a github repo and read all of the indicators like open issues, last commit, etc. it can't keep enough context in its memory to not lose its train of thought before responding. You'd have much more luck coding up the rules for what make a reliable dependency yourself and exposing it to the AI as a service if you really think that's the best way to surface it to users. Trying to fine-tune an AI to do this directly is a fruitless task with the current token limits on LLM contexts.",
                        "points": "16 points",
                        "children": [
                          {
                            "comment": "I feel like multi-stage approaches could be helpful here. For each library summarize the context and the reason for inclusion. Then run the follow-up queries with that meta-context.\n\nAnd maybe eventually enough accepted suggestions might be generated to fold it into the training data for the model that you could do it without such a crutch.",
                            "points": "5 points",
                            "children": [],
                            "isDeleted": false
                          },
                          {
                            "comment": "",
                            "points": "",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "",
                        "points": "",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "your if condition doesn’t account for None”.\n\nHow helpful is that even when the compiler will check whether your patterns are refutable anyways? And you can absolutely rely on the compiler.",
                    "points": "9 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "I actually have seen it do the latter, but only when using the ChatGPT interface. I think most tools (including GitHub) are still on GPT3.5, a lot of these deeper reasoning things got way more impressive in 4.",
                    "points": "4 points",
                    "children": [
                      {
                        "comment": "It should be noted that dumping code you're reviewing in ChatGPTv4 is probably an IP violation and grounds for termination at larger tech companies.",
                        "points": "11 points",
                        "children": [
                          {
                            "comment": "This is why you use it only for personal projects or deploy a private version on azure.",
                            "points": "0 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "This kind of thing doesn't even need LLM AI tbh, there are already some tools that if they don't already, could do this",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "I'd also would need to watch the talk itself\n\nThe talk was quite brief (5 min) and touched more on possible future potential use cases like maybe spotting more subtle errors. Moderately interesting (to me).",
                "points": "2 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "Yeah following it blindly. AI is an heuristic. It is good at doing stuff like \"have you considered X?\" and then leaving you to make a decision.",
                "points": "2 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "You can feed it long convoluted nested sentences and it'll go 'ok here's your code'",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Constructing command line tool options - brilliant",
            "points": "13 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Explaining error messages - Shines",
            "points": "29 points",
            "children": [
              {
                "comment": "this is a good one",
                "points": "6 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I don't have much experience with it but I also imagine it's not great at using bleeding edge language or library features",
            "points": "6 points",
            "children": [
              {
                "comment": "It’s so good at it, that it will make up API calls not even existing yet!!",
                "points": "34 points",
                "children": [
                  {
                    "comment": "I am sorry, you are right that it does not exist. Here is the corrected version: *proceeds to write another hallucinated API call*",
                    "points": "9 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "You're spot on with that - but not only bleeding edge! Old but poorly documented things it's not great with either. Due to the lack of examples it can still hallucinate and make up functions in a 30 year old language.\n\nI think what makes it generally perform well is having lots of examples re-enforcing the same things. So sparse training data for any reason is a huge pitfall.",
                "points": "2 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "To me this is more nuanced. In a way you're right but it does a pretty good job of inferring the obvious. But, to your point, can be slightly misleading/hallucinating",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Writing code from scratch - Mediocre\n\nArchitecting a solution - Mediocre/Poor\n\nUnderstanding code or solutions it has no clue about - Poor\n\nContextual multi-file or multi-domain code understanding - poor\n\n​\n\nIt's almost like this is the developers real job..",
            "points": "18 points",
            "children": [
              {
                "comment": "lol you mean it sounds like a real developer. yea that's about right. I didn't catch that but yea that is totally true.",
                "points": "3 points",
                "children": [
                  {
                    "comment": "I mean our job is not to write code, its to solve business problems and we do that by code.\n\nThat's why coding is the \"easy\" part and something AI could help with because code is very often based on best practices. Business are unique and there is no recipe for how to manage it.",
                    "points": "8 points",
                    "children": [
                      {
                        "comment": "I mean our job is not to write code, its to solve business problems and we do that by code.\n\nAnd to figure out what the real requirements and logic are instead of what the customer / PM thinks they are.",
                        "points": "6 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "I like that as it's a good way to think about it. However, when you work on the bleeding edge it is very different than maintenance mode per se.",
                        "points": "1 point",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "",
                        "points": "",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Also doing something repetitive that its long. For example, I had to write a simple but stupidly long SQL query so I just pasted in the table definitions and told ChatGPT to make it.\n\nIronically, it tries not to write it all out. You have specifically ask it to write out the whole thing -- by default it's just as lazy as I am.",
            "points": "9 points",
            "children": [
              {
                "comment": "I don't know how true it is, but I read that there may have been an increase in laziness due to changes in how much processing power they gave the models and that they were set to prefer fewer output tokens when the service was under heavy load.\n\nSeems like one of those things that \"feels right\", but could be bullshit. That's the black box for you, you never really know what is going on, on the other side of any given web service. I'll be happy when we can all have our own quality LLMs running locally.",
                "points": "9 points",
                "children": [
                  {
                    "comment": "",
                    "points": "",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Have you tried adding \"or else.\" to your request?",
                "points": "1 point",
                "children": [
                  {
                    "comment": "",
                    "points": "",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Code reviews - Shines Review code - Shines Finding bugs - Shines\n\nNo, god, no, god please no.gif goes here As of now it's good for boilerplate no more. For other it's worse than useless",
            "points": "13 points",
            "children": [
              {
                "comment": "Yeah, I also thought about that story. LLMs have potential to, and thus likely will, massively pollute systems with fake bug/security reports, as long as there's any possibility of the spammer benefiting from it.",
                "points": "4 points",
                "children": [
                  {
                    "comment": "https://daniel.haxx.se/blog/2024/01/02/the-i-in-llm-stands-for-intelligence/\n\nAlready happened :)",
                    "points": "2 points",
                    "children": [
                      {
                        "comment": "That's the link in the comment I replied to :)",
                        "points": "2 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Understanding code or solutions it has no clue about - Poor\n\nI was actually pretty surprised with how well it performs here. I tested it on a bunch of pretty obscure examples (including some stuff that just doesn’t out of my own projects, such as programs written in fake assembly languages for fake architectures) and how much it could pick up on really surprised me. It wasn’t always able to get everything correct but some of the details it picked up on would blow my mind. I also showed the same examples to programmers I know and they did much worse, but in their defence they weren’t familiar with this.",
            "points": "4 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Contextual multi-file or multi-domain code understanding - poor\n\nI feel like this is pretty important for code review so that seems like a contradiction",
            "points": "5 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Code review? Like, it has zero code understanding for anything remotely complex - how on earth could it possibly do a proper review? Sure, it might tell you to not have random whitespacing, yeah, linters are again a thing!\n\nDon’t get me wrong, I do use GPT4 from time to time (mostly to generate repetitive-ish code, by giving it an example for a transformation, and than a list of items), but in my actual work, it is waaay too dumb to reason about anything, let alone stuff like “is it a race condition”? Let’s see it solve a sudoku first, on its own.",
            "points": "9 points",
            "children": [
              {
                "comment": "lol that's not my experience it's pretty good actually. what language are you using in your experience?",
                "points": "2 points",
                "children": [
                  {
                    "comment": "I used it to write a bittorrent client and AI was not really helpful at all. Sure it might be able to get you started and help with basic functions but anything a little outside the box and it just can't do what you want. If the code has too many moving parts, AI can't understand the bigger picture of what you're trying to do. Add in security and good luck getting it to do anything meaningful.\n\nPlus I sometimes spend more time debugging / trying to figure out what the AI is trying to than if I just wrote it myself.",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "Bunch of languages (not niche ones, e.g. java), but come on, it can’t reason about stuff - how could it actually understand code?",
                    "points": "2 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Writing code from scratch - Mediocre\n\nWriting code from scratch was in a way superior for me recently, because while I am a good programmer, there was something I wanted to do in a marginally unusual programming language I do not know. Having ChatGPT help me write my program was FAR faster than trying to learn from scratch all of the nuances I needed to know.\n\nSure I had to iterate with it. But that iteration cycle was way faster than searching and reading docs online. Really big win.",
            "points": "7 points",
            "children": [
              {
                "comment": "The problem is, as you yourself say, you don't know the programming language, therefore you cannot determine the quality of the code it's giving you. So it's fine for small things, but you have no idea what headaches you're creating for yourself if you use it for larger projects.",
                "points": "19 points",
                "children": [
                  {
                    "comment": "Aside from language specific-idiosincracies in idiomatic code, good engineers should be able to detect good code even if they're not able to write it (in an unfamiliar language). Perhaps footguns in a library are an exception, but that can always be mitigated by carefully reading the docs of the used functions, which every engineer always does",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "this is a good one. I would put it in the category of Language learning traversal. I wouldn't say writing code from scratch because you wouldn't necessarily know if that code was good or not. And I would imagine to what extent of a complex system it is still capable of writing.",
                "points": "4 points",
                "children": [
                  {
                    "comment": "you wouldn't necessarily know if that code was good or not\n\nPlenty of times it's much easier to check if something worked than to write it from scratch, and there's no practical difference between good and \"bad\" code as long as it gets the job done.\n\nJust one example I ran across today as a scientist: one-off parsing a table from a webpage into a CSV file. It wasn't provided in a friendly format, but ChatGPT wrote some code that got me what I needed. I could see at a glance that it worked. The end.",
                    "points": "3 points",
                    "children": [
                      {
                        "comment": "For one-off things I agree. For implementing long-lasting code in a language you don’t know? Meh. It can introduce subtle bugs that you will overlook because you don’t know the footguns of that language.\n\nI kinda fear there will be a relevant amount of C code written by beginners with ChatGPT in the future.",
                        "points": "2 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "easier to check if something worked than write it from scratch\n\nLiterally P vs NP lmao",
                        "points": "1 point",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "How can it really be good for language learning if\n\nit does work for you \nyou don’t even know at that point if the solutions given are good or even correct\n\nThe fastest way to learn something is to work with it yourself. ChatGPT just enables you to do some tasks to some extent without prior learning, that’s where you get faster.",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "I've been using it a lot for this as well.\n\nHowever, technically it is writing code from scratch, you're probably not really using it like that. You know the code you want, just not in the syntax and functions of that specific language.\n\nI find it is really good at writing out what I have roughly in my mind. I know the solution, just put it into code for me.",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "Let AI pump it out and deploy it to production, no need to understand it... future (or current) manager perspective.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I have also found it heavily biased towards \"conventional\" problems.\n\n If you need to do something, or already have code which does something closely related to a popular coding problem, like ranking 5 card poker hands, it will really excel creating code which ranks poker hands in the standard way.\n\nIf there's a twist on the problem, for example tie breakers between hands should be decided by highest initial card, instead of highest overall card, Ai will fumble really hard.\n\nIt can be a massive time waste as it seems conceptually like such a minor change, but the AI can be almost incapable of getting it right.\n\nSo even writing something from scratch or coming up with solutions it can do really well, if you're looking for bog-standard solutions. If you have a weird problem it can be better to not even try using AI as it can lead you down the wrong direction.",
            "points": "1 point",
            "children": [
              {
                "comment": "I have also found it heavily biased towards \"conventional\" problems.\n\nAnd scripting. More or less all examples I've seen are of the type \"write me a script to do boilerplate X\".",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "It does not at all shine at finding bugs. It gas an enormous false positive rate wasting lots of developer time by having them track down what often was a hallucination",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "How does AI do with advising test plan?",
            "points": "1 point",
            "children": [
              {
                "comment": "this it can do well but be very careful. Too many managers are out there doing \"create this\" and it comes off super annoying and not useful because there are no details or business thoughts transmitted through in the final output. I've seen this attempted with user stories and user features too. It can be good but the way people are doing is not good. Meaning, the understanding and business understanding (context from you) needs to go in rather than just do the create this with no context.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "As usual, new tools make great programmers better, help others people learn, and probably hamper everyone else if they depend on it.",
            "points": "1 point",
            "children": [
              {
                "comment": "This is a great statement. If you have a blank slate and try to just use as if you're some unicorn it won't help you much at all. The internal human knowledge base must be established and this will then be a powerful tool for those persons.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Though we should prepare for a future where most of these points are \"shines\" or \"mediocre\".",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Summed it up perfectly. I'm assuming you are talking about ChatGPT, because others are pretty garbage at the other stuff that it shines in.",
            "points": "1 point",
            "children": [
              {
                "comment": "lol there is only ChatGPT",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Having been testing it with a private model on internal code bases and it has been very useful for training people up/getting them up to speed on areas more quickly, as well as led to noticeable drops in defects being created. Keeping my eyes in it, but it's useful augmentation especially given context, but it's not a replacement for anyone in any way. Good tool.",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "It's like... it's like calling it \"intelligence\" was a mistake.",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I don't know how nobody has hooked up GPT Functions to an IntelliJ AST/PSI.\n\n\"Refactor this function\"\n\n\"Sure, let me just search your codebase for all usages of it first to determine the best way to do that for ya\".\n\nI thought of that like a year ago but didn't do it because I figured it would be like, the most obvious thing that everyone was gonna build.",
            "points": "-4 points",
            "children": [
              {
                "comment": "there is an obvious issue here. One, this doesn't require AI, and it already exists. Second, these LLMs are constrained by the number of tokens they can process at a given time. They SUCK at keeping more than a few dozen small to medium-small size files in \"memory\" at once.",
                "points": "13 points",
                "children": [
                  {
                    "comment": "I think he meant more complex refactors, not just renaming or fixing all instances of a signature changing or whatnot.\n\nSecond, these LLMs are constrained by the number of tokens they can process at a given time.\n\nYeah but consider a LLM hooked up to the IDE's \"buttons and levers\", just like it can search Bing and use other software, it could also use the IDE's code inspection capabilities. Less \"let's try fitting the entire codebase into the model's context\" and more \"let's teach it how to navigate the codebase using already existing tools\".\n\nThat's my \"I figured it would be obviously something people would try right away\".",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "Hmm, not sure I agree with you!\n\nIdk how familiar you are with the state of AI, I'll preface this by saying that I've been using it since GPT-3 was in private preview and have launched 3 products using various models and methods over the last year.\n\nOne, this doesn't require AI, and it already exists.\n\nWhat exists without AI? The example I shared where the user can write in plain language that they want to refactor code, and that it uses the context of other files? Because that's what me and the person I replied to were talking about.\n\nThey SUCK at keeping more than a few dozen small to medium-small size files in \"memory\" at once.\n\nYeah, that's a big challenge. Fortunately a lot of really smart people have been working on solutions and ways around that for the last year or so. Retrieval-Augmented Generation (RAG) is the leading method where it doesn't try to load everything at once. Instead, it only loads what is required and most relevant for the task at hand.\n\nThe GPT-4-Turbo model that was made available after OpenAI's Dev Day made a huge improvement in this area by upping the context window to 128k tokens.\n\nFeel free to ask anything if you'd like to learn more.",
                    "points": "-1 points",
                    "children": [
                      {
                        "comment": "I appreciate your enthusiam, but what you are suggesting is just NLP and existing refactor technology (in it's essence a find and replace). That's just ML, not \"AI\". I'm also working directly with OpenAI on testing their new models, including a custom one built from my companies internal code bases, so probably have more experience than most.",
                        "points": "8 points",
                        "children": [
                          {
                            "comment": "So let me ask you this: You don't see the value in being able to have a conversation with some LLM to carry out tasks across your codebase, where it maintains the important context?\n\nI'm having a hard time understanding where you're coming from. Sounds like you're saying there's no point because it's already been done without LLMs, but you also mentioned the context window being a limitation which is only true on the surface.",
                            "points": "-6 points",
                            "children": [
                              {
                                "comment": "now you are shifting what you claimed to say to put words in my mouth. have a nice day",
                                "points": "7 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Why did I read that as \"Shinese\" likes a Frenchman pronouncing \"Chinese\"?",
            "points": "-1 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Architecting a solution is not really mediocre or poor, for me it usually thinks of stuff I hadn't considered before.",
            "points": "-17 points",
            "children": [
              {
                "comment": "but who is the one you would consider is doing the architecting? For me, I will try to get it to architect sometimes or thought provoke and most times i'll be like nah I got this. What about this... At that point it's me",
                "points": "5 points",
                "children": [
                  {
                    "comment": "Yeah I suppose it won't do everything for you, it's just a tool to help you architect, same as any other LLM use case.",
                    "points": "3 points",
                    "children": [
                      {
                        "comment": "Yep I think that is fair. It's a great friend and assistant",
                        "points": "1 point",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "It is also really good at helping you find what you're looking for quickly in api documentation and suggesting things from it. Assuming the documentation is public and it hasn't changed much since 2022.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "In the original video starting at time 11:27, he stated clearly that code review takes practice and experience.\n\nThere is no AI, ChatGPT is slick Machine Learning. It's not a human, capable of internalizing mistakes and gaining true, sentient insights which is required for reviewing code.",
            "points": "0 points",
            "children": [
              {
                "comment": "hmmm. You don't need sentience here. That's a bit extreme. For example you could shot in coding standards and examples easily. Meaning, here are some standard coding standards/examples. Does this follow that. Yes, no. The agency comes from you in the design of the system. So no sentience needed. Are there any obvious mistakes or patterns not being followed. We are doing this right now very effectively. there are some pretty slick tools that this is being incorporated with right now too. You should check them out.",
                "points": "0 points",
                "children": [
                  {
                    "comment": "",
                    "points": "",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "As always, Linus is extremely pragmatic and does not shy away from new things as long as they provide value.",
        "points": "200 points",
        "children": [
          {
            "comment": "I really enjoyed his comments about bugs.\n\nHe's so right, most bugs are very obvious and often stupid. That don't mean we are stupid its just that we tend to forget or automate over parts that might need more thinking.\n\nThis is why having a third eye looking at the code from another angle catches bugs so often, we get too wrapped up in one angle often.\n\nThis is obviously something Ai can help with.",
            "points": "29 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Does anyone know the full source of this clip?",
        "points": "26 points",
        "children": [
          {
            "comment": "https://www.youtube.com/watch?v=OvuEYtkOH88",
            "points": "24 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "One of the most interesting things he said was \"...now we're moving from C to Rust.\" Does this portend an eventual move to Rust for the Linux kernel?",
        "points": "12 points",
        "children": [
          {
            "comment": "I think it was more of a statement on the changing landscape of high performance languages",
            "points": "24 points",
            "children": [
              {
                "comment": "It's coming to the kernel as well https://www.youtube.com/watch?v=YyRVOGxRKLg",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "The move is ongoing but it’s unclear how many decades it will take to complete. A lot of the stuff in drivers/ is unlikely to ever receive a Rust rewrite so those parts will live on for a long time alongside a more rustic core until there’s nobody left who’d object to their removal.",
            "points": "6 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Drivers, not the kernel itself. I think the \"we're moving\" refers to the low-level programming community in general, like it's an option now that we didn't have 20 years ago. In a similar way to Rust, AI brings in new tools.\n\nThere's no Rust rewrite going on in the kernel as a general movement.",
            "points": "5 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I doubt the kernel will ever be pure Rust. However Torvalds seems to believe Rust gives something that C doesn't. A lot of the foot in the water stuff is just necessary and sane caution on what is a disruptive change.",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I think it does portend such a move and automating the porting of lots of code like that is a good job for an LLM. Obviously some of it would be tricky but other parts would be very mechanical.",
            "points": "-1 points",
            "children": [
              {
                "comment": "Porting C to Rust is something that can already be done mechanically without a LLM. A LLM might be quite useful for analyzing context and beautifying the code, but there's still the small matter of being able to trust it.",
                "points": "0 points",
                "children": [
                  {
                    "comment": "",
                    "points": "",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "It was at this moment I knew he was trolling.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "This is a much more reasoned view on automation than you usually hear around here. We've been using automated tools to help code ever since the invention of the compiler.\n\nI'm tired of the \"it will never work, and if it did work it would be the end of the world\" from programmers who are obviously scared of losing their jobs.",
        "points": "102 points",
        "children": [
          {
            "comment": "I mean its not exactly unfair for people to be scared of having something taken away from them that they've spent their lives cultivating, whether they be artists, singers, actors or programmers.\n\nAs with all tools the implementations, the methodology and the operators matter. You can use a gun to hunt and stave off hunger, and you can use that same gun to commit atrocities. Its not unfair to be skeptical of that tool becoming a weapon especially when large corporations have far more means than any one person ever will, to use, develop and create that tool.\n\nA tool can quickly become a weapon, I believe that is also the case with AI, so I would think that some caution and analysis is more than warranted.",
            "points": "49 points",
            "children": [
              {
                "comment": "“Taking away our jobs” is just stupid, because it is absolutely nowhere near that.",
                "points": "2 points",
                "children": [
                  {
                    "comment": "I agree, not at all what I said though.",
                    "points": "4 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "I mean its not exactly unfair for people to be scared of having something taken away from them that they've spent their lives cultivating, whether they be artists, singers, actors or programmers.\n\nNothing of value is being taken away. LLMs still need to be told how to structure programs or at least supervised doing it. The only people who will lose their job are people who have memorized the spec of a language and don't know how to compose programs together.",
                "points": "2 points",
                "children": [
                  {
                    "comment": "I feel you, I think programming is going to be pretty safe for the foreseeable future as things stand, but thats not the case for a lot of things. Like it is extremely easy to look ahead and see that every company see's the value in doing something like taking a celebrity, cloning their voice and then using their voice to create a \"perfect\" artist that can infinitely pump out pop songs.\n\nThey wont get paid for it, just like how actors like Aaron Paul never got paid a dime for Breaking Bad blowing up when it came popular again a decade later on Netflix. There is an extremely unique abuse potential of AI and it needs to be addressed.\n\nThis is just an example, this will effect people scraping by as well infinitely more in the exact same ways. Its the same story over and over, create a new technology, skirt around regulations, lobby for laws that are beneficial to the corporation and clamp down on users and workers to everybodys detriment.",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Programmers only exist because we automated other jobs - otherwise we'd still be farmers, weavers, and blacksmiths. We've all benefited enormously from automation because it's one of the few \"free lunches\" that increases total wealth. \n\nIt's a little selfish to stamp your foot and say \"no! We stop automating when it's turn for my job.\"",
                "points": "-4 points",
                "children": [
                  {
                    "comment": "It's a little selfish to stamp your foot and say \"no! We stop automating when it's turn for my job.\"\n\nIs that what you think I said or are your reading comprehension skills a little rusty? Maybe toss my comment into chat gpt and have it summarize it for you lol\n\nProgrammers only exist because we automated other jobs - otherwise we'd still be farmers, weavers, and blacksmiths.\n\nAh, yes, if one thing human history is known for, its non-violent technological advancement and not trampling on the lives and rights of others with it /s\n\nWe've all benefited enormously from automation because it's one of the few \"free lunches\" that increases total wealth.\n\nIncreases the wealth for who again? lmao Im sure its at least somewhat equitable and fair... right?\n\nImo this is just delusion, you're not Nvidia, Google or the NSA brother... you may think you can get a leg up climbing on the backs of others but in reality you're no different than anybody else... and how dare I suggest that we try not to make the same mistakes as a species over and over and over.",
                    "points": "16 points",
                    "children": [
                      {
                        "comment": "Fundamentally, the reason we're not all subsistence farmers is increased worker efficiency. The problem is not the technology, it's the social mechanisms determining who benefits from the increased productivity.",
                        "points": "11 points",
                        "children": [
                          {
                            "comment": "How much would that help if your job were suddenly made obsolete though",
                            "points": "-1 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "Increases the wealth for who again?\n\nMe. Look at this car, iphone, modern medicine, running water, electricity, and internet I have - only possible because of automation.",
                        "points": "-1 points",
                        "children": [
                          {
                            "comment": "bruh the US has the most expensive medical care and the worst health outcomes of any other wealthy nation, the average speed to price for internet across america is also at the level of 3rd world countries, your phone is literally made with child labor... like cool bro, huge W.\n\nThis is why I and everyone hates tech bros, you're stupid, arrogant and selfish. My argument was never \"automation is bad\" in the first place",
                            "points": "9 points",
                            "children": [
                              {
                                "comment": "I think they just enjoy fantasizing about a technocracy that leaves people that are not \"in it\" behind\n\nThey are tech-adjacent and believe they will be at the forefront of the revolution, that they will be the people that took advantage of the loom and not the ones that were working on the loom 14 hours a day\n\nThey aren't cynical enough to think that maybe, just maybe, the profits of the labor saved (or produced, if you prefer) won't go to them\n\nSee how they only mention material things as positive things coming from this?\n\nThey were the same people that 300 years ago saw chemistry being developed and thought \"this is going to be good for agriculture\", while calling the ones that thought \"this will enable new kinds of warfare and diseases\" silly\n\nThey also mentioned that technology is not the problem, but societal mechanisms determining who gets the profits. This is a child's understanding, because it's not only about profits, but way of living itself. But since they don't usually suffer those consequences, or are the ones to benefit from them, or, worst case, they enjoy seeing the suffering of others, they don't care\n\nIt's a shame, really. Majority of AI talk seems to come from people who delight at the thought of people losing their jobs and being left behind",
                                "points": "6 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "Is that what you think I said or are your reading comprehension skills a little rusty?\n\nI guess my reading comprehension skills are rusty too, because that's what I thought you were saying as well. And are continuing to say in this reply, after having just denied saying it. Maybe not explicitly, but you're clearly making a case against the automation of jobs.",
                        "points": "-2 points",
                        "children": [
                          {
                            "comment": "Clearly not since you can't even say what \"it\" is. I literally cannot be clearer. AI is a tool, tools can be helpful or destructive depending on who uses them, corporations shouldn't go unchecked and we should caution and analysis to prevent abuses. Like, god damn.",
                            "points": "3 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "My thoughts are usually \"training one generally requires a large amount of theft so using one makes me feel bad ethically\".",
            "points": "18 points",
            "children": [
              {
                "comment": "Nah. Learning isn't theft.  \n\nAnd the benefit of having a magic box that writes code (or makes images, or whatever) is more than worth rewriting copyright law if necessary.",
                "points": "-5 points",
                "children": [
                  {
                    "comment": "Learning\n\nThat's the problem, though. It's not learning. Like every other \"AI\" currently in existence, it is just a model trained off exist data sets, and all the model does is recognize patterns, then spit out the most likely outcome.",
                    "points": "4 points",
                    "children": [
                      {
                        "comment": "How do you define \"learning\", though? Our school systems, for example, often want to test that students have \"learned\" something. And the way they test the students is by giving them an assignment where the students have to either choose the most likely correct choice, or generate text about a topic.\nAnother way to define learning is to say that the learner must be able to apply the learned information in a novel situation. LLM:s show this ability, as do other large generative neural nets. So what is your definition for the word?",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "Cool, you literally just described humans.\n\nTurns out everything is dumb if you dumb it down to ridiculous levels.",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "",
                        "points": "",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "I asked a group of artists once what the difference was between an AI being trained on freely available public art, and a human learning to draw from the same materials.\n\nThe answer was \"One is a computer\".",
                    "points": "-4 points",
                    "children": [
                      {
                        "comment": "The 'group of artists' collectively gave you a one sentence response to this subtle and nuanced issue? I'm going to file this one under 'things that didn't happen'.",
                        "points": "11 points",
                        "children": [
                          {
                            "comment": "To be more specific, I posted a pixel art tool in a pixel art community and there were various comments attacking it and labeling it as theft.\n\nI engaged with several people in the thread, trying to understand how they got to that conclusion.\n\nThe only answer I got, which was then upvoted by the others, was \"One is a computer\".\n\nHope that clears up any confusion for you.",
                            "points": "-3 points",
                            "children": [
                              {
                                "comment": "Yes. That does clear it up. It sounds like you were seen as hostile in their community, and they didn't want to talk to you.\n\nI guess if you wanted a more detailed answer you might want to read some of the articles and blog posts about it. I mean, it's a widely held view that it is theft, so I'm sure if you look you'll find a range of unrelated authors independently voicing their views on it. And that often works better than questioning the view of a group as an outsider, because such questioning is often seen as an attack. People tend to put questions like that not help inform their own understanding, but to try to provoke an argument.",
                                "points": "7 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "I think a key question is what do you mean by freely available public art. If it is anything other than public domain, MIT or CC BY/SA/NC (or equivalent) than in my view it is absolutely copyright infringement and is theft. I think that it is reasonable to draw a clear line in the sand that an algorithm cannot be transformative in a creative sense.\n\nI think how the courts answer this question will determine how the next few years look in terms of LLMs and other generative AI systems. https://www.vox.com/technology/2024/1/18/24041598/openai-new-york-times-copyright-lawsuit-napster-google-sony",
                        "points": "-1 points",
                        "children": [
                          {
                            "comment": "I looked at those licenses but I only see them mentioning using the images for commercial use.\n\nI don't see them restricting you from learning to draw by viewing the images.\n\nMaybe you could point to where it specifically prohibits learning to help me understand.",
                            "points": "-1 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "The difference is that in one case, some person is getting inspired by your work and joins the community, giving back in various social ways and potentially creating a feedback loop of great ideas.\n\nIn the other case, a tool serves to distance people by axing previously big avenues of social exchange, all for the profit of a few companies.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "If you think looking at pictures and learning from them, while not saving a single pixel, is theft, you're absolute insane.",
                "points": "0 points",
                "children": [
                  {
                    "comment": "",
                    "points": "",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "The whole issue is people, usually non-tech people, are presenting it as if programmers will lose their job over this. Linus is presenting AI from a pro-programmer perspective. As a tool that maybe will give you a 5% efficiency bump. That is miles away from what most idiots are suggesting AI will do.",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Is there a danger that eventually, the new human-contributed material that these models are trained on could dry up once we hit Peak Code?\n\nIt would probably take a while before all of the open source developers give up though.\n\nPresumably proprietary code would remain off-limits to legal LLMs.\n\nIf that ever happened, would the LLMs begin cannibalising themselves, resulting in a strange kind of stagnation?\n\nI suppose that the sensible thing would be for AI companies to invest like fuck in creating proper artificial minds that possess creative imaginations, in order to move past that kind of barrier.\n\nHm, this makes me wonder if this might all be some sort of long term plan by proprietary software companies to crush the open source movement at its roots; thereby allowing them to charge the customers who are left a fuckton again, like in the old days.",
            "points": "0 points",
            "children": [
              {
                "comment": "Is there a danger that eventually, the new human-contributed material that these models are trained on could dry up once we hit Peak Code?\n\nNo.\n\nIf the models stop producing good code then human programmers will be in more demand. And then the models would have something to learn from.\n\nBut anyhow, learning by copying is only one technique. There are also self-training techniques as the other person described.\n\nEssentially an AI could do trial and error and learn from successes. That's how they learned to play Go. Not from reading human games.",
                "points": "3 points",
                "children": [
                  {
                    "comment": "That's how they learned to play Go. Not from reading human games.\n\nIt's a poor example because the search space for go games and for a turing complete programming language are drastically different.",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "",
                    "points": "",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Is there a danger that eventually, the new human-contributed material that these models are trained on could dry up once we hit Peak Code? \n\nThe solution there is reinforcement learning. It's a little behind unsupervised learning right now, but would allow computers to create their own material without being limited to human-created examples.\n\nAlphaDev is one example of a code-generating system trained entirely with RL.",
                "points": "2 points",
                "children": [
                  {
                    "comment": "Where does the reinforcement training come from?\n\nObviously it would probably take years, but if everyone gives up writing and releasing code themselves, would this not eventually mean that fresh code more or less comes from a couple of guys who are still employed to train the newest LLM?\n\nA pretty basic picture, but you understand the concern.\n\nTL;DR: For programming, where does the LLM get new inspiration from?",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "",
                        "points": "",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Is there a danger that eventually, the new human-contributed material that these models are trained on could dry up once we hit Peak Code?\n\nIt's already happening in a way.",
                "points": "4 points",
                "children": [
                  {
                    "comment": "Yup, that’s already a bit of a fucker when searching for something in particular, and it’s just a plethora of robotext bollocks that comes back. It’s simple enough to recognise unnatural filler content at the moment, but I expect that that’s going to become more cumbersome later.\n\nI understand why they do it, to flood the market with shit that adverts can be slapped on. But even so…\n\nWhat worries me though with the cannibalism, is that where actual new stuff is occasionally required, where will that spring from?\n\nAre there any examples at all right now, where the machine can actually develop an entirely new piece of software that does something that a human has not solved before? Maybe one of those really difficult maths problems that people get paid prizes for.\n\nI really don’t know myself. But it would be interesting to see that in action.\n\nShit, people have no doubt said it before, but obviously it ought to be possible to use the LLM to bootstrap a better LLM n times, until weird shit starts to happen. Not consciousness, obviously, but perhaps the mathematics thus revealed may yield truly imaginative results. Assuming the magic smoke doesn’t escape.",
                    "points": "1 point",
                    "children": [
                      {
                        "comment": "Shit, people have no doubt said it before, but obviously it ought to be possible to use the LLM to bootstrap a better LLM n times, until weird shit starts to happen. Not consciousness, obviously, but perhaps the mathematics thus revealed may yield truly imaginative results. Assuming the magic smoke doesn’t escape.\n\nLLMs are dumber than you think. It can't do math or programming. What you're seeing is an emergent property from the vast amount of data it has ingested and the results are just good enough to fool people.\n\nWhen you ask it 20+4= and it responds 24 it is not independently evaluating the expression 20+4 and arriving at an answer. It is looking at the token 20+4= and seeing that a lot of people typed 24 after. If you give it an exceptionally large or unique number, something that no one is likely to have ever typed before it won't know what to do with it and just give you the best answer it can come up with and it will likely be wrong. It has to let plugins take over and cover some of those areas (e.g. WolfamAlpha for math).\n\nSame deal for code. It doesn't actually understand any rules or syntax. It's just really good at predicting patterns. I sigh every time someone says coding will be replaced by general LLMs, it's just not possible. This is just not a problem that LLMs were built to solve. The day will come, but it will be by virtue of a completely different algorithm.",
                        "points": "6 points",
                        "children": [
                          {
                            "comment": "Yeah but sometimes the suggestion is very good it felt like magic.",
                            "points": "2 points",
                            "children": [],
                            "isDeleted": false
                          },
                          {
                            "comment": "When you ask it 20+4= and it responds 24 it is not independently evaluating the expression 20+4 and arriving at an answer. It is looking at the token 20+4= and seeing that a lot of people typed 24 after.\n\nThis is an oversimplification. General-purpose LLMs like GPT-4 are capable of correctly solving math problems that don't appear in their training set, indicating they've learned something about the structure of numerals and math operations just by seeing how humans lay them out.\n\nLLMs also appear to be quite receptive to fine-tuning to become better at math and can learn the kinds of structural logic that math requires:\n\nGoogle Minerva: https://arxiv.org/abs/2206.14858\n\nLlemma: https://arxiv.org/abs/2310.10631\n\nSo while it's true that OpenAI is enhancing ChatGPT by teaching it to use external tools rather than to do everything itself, that doesn't mean LLMs are incapable of mathematical reasoning.",
                            "points": "2 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "All my life I have done coding and robotics. I’ve loved the programming part the most. I started out with a robot rover that used the simplest commands to move. From there I got into block coding and such. As I’ve gotten older my interest has only grown, but one day right before I had a structured programming class, I found out about chat gpt. All my life I had planned to go into some sort of programming job, but after that I got depressed and felt like my entire life had been wasted. Because who would want to hire a programmer when they could just type what they want and get the answer. It wasn’t until i had decided to really get to the truth and figure it out for myself that I found how it wasn’t so bad as I had thought. I realized how good of a tool it could be. I kind of went deeper into how prompts worked and how I could better design prompts to help me with tasks. I still love straight coding, but I use stuff like copilot or ChatGPT for many of the things that I do now and I still love it as much as I did when I was little. This isn’t something to be scared of, but something you should use. This is just my experience.",
        "points": "16 points",
        "children": [
          {
            "comment": "That's a good attitude.",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I'm currently applying for a job as a chatbot code trainer.\n\nThe idea is you create projects using the chatbot code app, then critique/ review the solutions it creates.\n\nYou must be the one to create the prompts, and they want to see original / interesting prompts.",
        "points": "3 points",
        "children": [
          {
            "comment": "Sounds kind of fun, actually.",
            "points": "2 points",
            "children": [
              {
                "comment": "I'm hoping so. I haven't had a reply yet.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Tell me you know nothing about training algorithms by telling me how you would train an algorithm",
            "points": "-5 points",
            "children": [
              {
                "comment": "You know this is an actual job application, right?\n\nLLM (large language models) are trained by using lots of input.\n\nThis appears to be similar. The application is open, they're not looking for one programmer, but many. So they're soliciting lots of input, from many different programmers, across five languages.\n\nI'm pretty sure they know more about this than you do.\n\nedit: I forgot to add the job is also being advertised for applicants in multiple countries. They actually have a list of countries they are asking for applicants from. So..this is not a small enterprise.",
                "points": "3 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Is it me or does Linus looks each day more like Palpatine 🤔",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Nice to hear him have a mature answer balanced view of the place of LLMs in coding.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "while everyone are distracted by LLMs Linus mentioned that rust will have a big push this year ! slow and steady boys we are taking over the kernel 🦀",
        "points": "-1 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "This technology is evolving so rapidly, that his observations about GPT as a tool are only valid, like, in this exact moment. GPT has only been mainstream for a year and how look quickly it has taken over so many aspects of programming and other language-based tasks.\n\nThere's no way in 10-15 years our jobs aren't almost entirely obsolete. \"Rewrite the Linux kernel in Go\" will be like an overnight task for the models at the big tech companies. If you think otherwise, I think you're in denial.",
        "points": "-22 points",
        "children": [
          {
            "comment": "The AI has been under development way longer than it has been available. I think you grossly overestimate how much smarter it can get in a short time.",
            "points": "18 points",
            "children": [
              {
                "comment": "To people who aren't involved in the (extremely mature and large) world of research and development into AI, the release of ChatGPT seemed like a huge leap that came out of nowhere.\n\nI don't have any reason to believe that these LLM AI products will be getting exponentially more powerful in the near future, and I definitely don't think that AGI is around the corner.\n\nSide point but we also seem to misunderstand how incredibly expensive it is to run a service like ChatGPT. They are burning money and electricity\n\nAs of April 2023 it was costing OpenAI an estimated $700,000 per day.",
                "points": "10 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "You really think 28 million lines of code will be rewritten to a different language without introducing an absurd amount of incorrect assumptions resulting in a myriad of hard-to-tackle bugs, while maintaining performance optimizations, and magically the entire enterprise software world will adopt it for production business-critical applications? The code is going to require tests, the tests need to be trusted, the product fully or tested and hardened. SOC is not going to magically accept that a software system was written by, tested by, bug fixed by and pentested by entirely non-humans. Good luck throwing some engineers at a fresh 28 million line piece of software and hoping to make sense of it all to fix the problems in any simple way or time-sensitive scope.\n\nThat’s not to say they won’t perhaps reduce headcount or increase productivity; using ChatGPT, GitHub Copilot, and Copilot Chat has already dramatically increased my own performance but they’re just tools. Like Knowing how to search Google effectively to find your answers, these new tools require knowing how to initiate the right prompts and queries.\n\nI can give it a large set of data and ask it to map-reduce or otherwise format it to a given interface and have those results in seconds\n\nI can inquire about some task or data I’d like to gather from some APIs in a given language - e.g. “how can I get all VM instance types for flexible database servers with Azure SDK in Golang”. I’m not going to use the code generated, but it rapidly points out the particular Azure Golang SDK modules that I need to go look at (if you’re familiar with Azure SDK Go mods, you will understand why this is not easier done by merely searching Google or trying to search Microsoft’s own documentation directly)",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "No freaking way.\n\nJust because ChatGPT can crib some code from stack overflow doesn't mean it actually understands what it's doing.",
            "points": "8 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Is it possible to try that right now?\n\nPerhaps with a “smaller” operating system, such as FreeDOS.",
            "points": "-3 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "A Linux-kernel in Go is probably not a great idea. :)\n\nI don't know whether what you are saying is true or not, but I don't think it needs to be downvoted into oblivion. These models are prone to surprising leaps forward in capability and nobody knows what the next 15 years holds. I find it astonishing that people who could NEVER have predicted ChatGPT are very confident about what 15 more years of development will (not) achieve.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "[deleted]",
        "points": "5 points",
        "children": [
          {
            "comment": "“The large language model” meaning the high-level abstract concept of Large Language Models (complex neural networks with transformer workflow design). Whereas there are many different specific implementations of LLMs - e.g. OpenAI’s GPT-3 and GPT-4.",
            "points": "5 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "\"History of the automobile\"\n\nNot a history of a single automobile.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Here is a better question, do you trust artificial foods in your body?",
        "points": "-144 points",
        "children": [
          {
            "comment": "That was not, in fact, a better question",
            "points": "111 points",
            "children": [
              {
                "comment": "Indeed, it was the opposite",
                "points": "5 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "That’s just like, your opinion man",
                "points": "-24 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Artificial foods like cheese? Wine? Yogurt? Bread?\n\nYes, yes, I do.",
            "points": "51 points",
            "children": [
              {
                "comment": "No, no, I'm sure he meant stuff like plants, where we distorted the stuff found in nature and came up with our own manmade plants. You know: cabbage, broccoli, cauliflower, kale, brussels sprouts, kohlrabi.",
                "points": "23 points",
                "children": [
                  {
                    "comment": "Like corn, wheat, apples, and lemons?",
                    "points": "10 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "Don't forget bananas",
                    "points": "4 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "friggen' Brassica rules the world",
                    "points": "2 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "What’s an artificial food? And what does it have to do with anything? Do you trust artificial vaccines?",
            "points": "25 points",
            "children": [
              {
                "comment": "What's an artificial food\n\nAll food that has been processed by disgusing, disgusing humans. I feed exclusively by opening my mouth and letting pollen particles deposit inside",
                "points": "18 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "McDonald's, bioengineered foods, man made foods (think lab grown chicken) , anywho I believe we all use ai (i do) but we all can agree it isn't 100%.. thats all",
                "points": "-55 points",
                "children": [
                  {
                    "comment": "Oh so this is just vibes",
                    "points": "36 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "We've been \"bioengineering\" foods for hundreds of years. A modern tomato is about as natural as a pop tart.",
                    "points": "4 points",
                    "children": [
                      {
                        "comment": "",
                        "points": "",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "Is lab grown chicken even on US store shelves yet? It just got FDA approved back in June. Point me at it please, I wanna try it.",
                    "points": "2 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Thank you for this post. You have been the most positive addition to Reddit today by creating a context for endlessly entertaining shitposts to reply.",
            "points": "-5 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Always accepted and approved, no code review needed, nor QA. Or QA by AI, why not. Of course. Straight in production. A true boss/CTO dream isn’t? Well… sorry boss, still doesn’t work like that. Apparently you still need me! Very sorry about that! 🤭",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "There is a huge and extreme difference between what people think LLM is and what LLM is.\n\nIt works only as long as code is only syntactically complex. At the moment you introduce logical complexity it fails. It is not a reasoning machine outside of direct patterns obvious from the literal code itself.",
        "points": "0 points",
        "children": [
          {
            "comment": "The video was discussing how the tools will develop over the next several years. LLMs are simply the first step in AI code analysis and creation tools.",
            "points": "0 points",
            "children": [
              {
                "comment": "In context of programming, LLMs are already a dead end for various reasons. Something else, maybe...",
                "points": "0 points",
                "children": [
                  {
                    "comment": "",
                    "points": "",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I see the bugs that happen without them everyday.... I think we're doing those just fine on our own\n\nSick burn lol",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I find the analogy between AI and the use of higher-level languages a bit naive (and surprising for an experienced programmer like Linus).\n\nThe success of higher-level languages rests on the shoulders of compiler science and technology which are some of best results to come out of computer science. Unlike LLMs, compilers are based on rigorous mathematical algorithms to process and transform code. And they are predictable, i.e. you can rely on their behavior in new situations. Expecting anywhere near the same level of reliability from LLMs is IMHO wishful thinking.\n\nLinus' remarks about Rust the reviewing of \"simple bugs\" is also interesting: I'm not sure what kind of bugs he specifically had in mind, but Rust should be able to prevent a lot of common bugs in C/C++ because of the stronger type ML/Haskell-like type system and the borrow checker. I'd put more faith into the latter (type systems) than AI automatic code reviews.",
        "points": "0 points",
        "children": [
          {
            "comment": "The success of higher-level languages rests on the shoulders of compiler science and technology which are some of best results to come out of computer science. Unlike LLMs, compilers are based on rigorous mathematical algorithms to process and transform code. And they are predictable, i.e. you can rely on their behavior in new situations. Expecting anywhere near the same level of reliability from LLMs is IMHO wishful thinking.\n\nI agree more with Linus than with you.\n\nThe lesser reliability of LLMs is paired with a strength: an ability to handle ambiguity and complexity. As Linus says, humans also make mistakes, and yet we have a role to play in the software development process.\n\nLLMs and other coding AIs are in the middle: they can handle more ambiguity/complexity than traditional programming language-technologies tools, but less than humans.\n\nThose who are open minded can take advantage of their strengths and manage their weaknesses, just as we do for humans on one end of the spectrum and procedural tools on the other end of the spectrum.\n\nThe reason that Linus uses the analogy of high-level-languages is because there were once doubters of those languages as well. \"The compilers will never produce sufficiently optimized code to be useful.\"\n\nI'd put more faith into the latter (type systems) than AI automatic code reviews.\n\nThe great thing is that there is no reason whatsoever to choose between these two complimentary technologies.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "AI is the Auto-Tune of software development.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "\"because all a large language model does is it predicts the most likely next word\"\n\nTbh, I find this view pretty ignorant. We aren't even so sure if humans themselves don't operate like this as well. It could also be that LLM don't just predict the next word, but much more, it's only that the final output is just one token. But a model that can predict much more that just the next word, will likely be better than a model which tries to only predict the very next word.\n\n\"Not very intelligent\", lol LLMs are already better than most human beings at proving geometry theorems or some other formal proofs. They can write better texts that most humans. They can write (small scale) code that probably runs better than what most developers would write without access to a compiler and other tools.\n\nAs if humans don't write bugs. At some point the bug-per-line measure will be lower for some LLM system than the average developer, and it'll probably happen sooner than we think.",
        "points": "0 points",
        "children": [
          {
            "comment": ". It could also be that LLM don't just predict the next word, but much more, it's only that the final output is just one token.\n\nI think it's indisputable that models \"just\" predict the next word. But I think it's a misunderstanding to think that that's a trivial function. Predicting the next word in the transcript of a Magnus Carlson chess game means that you can play chess like Magnus Carlson. Predicting the next word in a scientific paper means you understand the science enough to finish equations. And so forth.\n\nPredicting the next word is an excellent proxy test for intelligence because it is so general and so difficult.\n\nWhen people say \"LLMs aren't very intelligent\" what they are really saying is that they aren't as good at predicting the next word as I want them to be.",
            "points": "0 points",
            "children": [
              {
                "comment": "I think it's indisputable that models \"just\" predict the next word.\n\nHow is that indisputable? How do you know that the last layer doesn't \"contain\" a prediction for the next 30 tokens, because at some point that may just be necessary to improve the loss? For all we know, a black box that's predicting tokens could contain an entire simulation of a human to get very accurate predictions.\n\nYou could say a human speaking also just predicts the next word, because that's the output we hear. But most people already have a rough prediction what meaning the entire sentence will have, and what stuff they're gonna say after than.\n\nI read your comment again (because I noticed that I only really read the first sentence, lol), and I guess I don't disagree with you, except that either \"because all a large language model does is it predicts the most likely next word\" is wrong, or a tautology. If it's meant as a tautology then it's not really worth saying, so I assumed that the interviewer wanted to communicate something by saying that.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "\"LLMs are just auto correct on steroids, they don't have real intelligence\" - that's not a very useful thing to say. Do we have proofs that our brains are any different? We also make stupid mistakes. I'd argue that ChatGPT is possibly a better programmer than the average programmer.\n\nIn the hands of a skilled programmer it's an incredible tool.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  }
]