[
  {
    "id": "t3_199l9ta",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.code4it.dev/blog/kill-the-process-blocking-a-port-windows/",
    "title": "How to kill a process running on a local port in Windows",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_199kfsi",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.theguardian.com/uk-news/2024/jan/17/post-office-inquiry-fixing-horizon-bugs-fujitsu-developer-gerald-barnes",
    "title": "Fixing Horizon bugs would have been too costly, Post Office inquiry told",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_199jyzm",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://blog.polybdenum.com/2024/01/17/identifying-the-collect-vec-memory-leak-footgun.html",
    "title": "Identifying Rust’s collect::<Vec>() memory leak footgun",
    "points": null,
    "comments": [
      {
        "comment": "This is not a memory leak.\n\nDynamic structures should not be using 200x memory though. It would be at most 4x memory worst case assuming you shrink at 25%.",
        "points": "3 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Am I dumb or is this not a memory leak? Wouldn't it be more closely related to space leaks?",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "That’s not a leak. That’s the standard behavior of dynamic arrays in almost any language.",
        "points": "2 points",
        "children": [
          {
            "comment": "Maybe I'm missing something. Doesn't every dynamic array structure either size itself to requested size or has a default so low that you'll always use it up anyway? e.g. Java's List has a default internal size of 10.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Down voted for click bait title. There’s no leak here, even if there is some underlying sub-optimal situation with the complete program.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I’m able to see no memory leak there.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Nice investigation but a debugger and a memory profiler are better tools for this kind of work.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "This seems more like \"not writing loops\" footgun.\n\nJust write the loop and the allocation is very transparent.\n\nIt would have been very clear where the issue was and it would have been much more obvious how to alleviate the problem.\n\nBut if you hide things behind map(), collect() you are at the mercy of however that is implemented which won't always be optimal.\n\nThe cost was 18gb for 300k nodes which is insanity.\n\nReturn to loops. Loop hatred has gone on for too long.\n\nRust seems annoying though because its severely limiting your options here.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_199jwrk",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.codeproject.com//Articles/5375803/Smart-Home-Controlling-Shelly-Devices-Part-4-Prope",
    "title": "Smart Home – Controlling Shelly® Devices (Part 4) - Property-Manipulation with the PropertyDescriptor",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_199jp3a",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://learncplusplus.org/learn-c-optimization-with-a-genetic-algorithms-example/",
    "title": "Learn C++ Optimization With A Genetic Algorithms Example",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_199il0d",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.javatpoint.com/java-hashset",
    "title": "HashSet Harmony Unleashing Java's Distinctive Elegance in Collections",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_199ijk5",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.doliver.org/articles/hot-take-typescript-is-the-best-language",
    "title": "Hot Take: TypeScript is the Best App Language",
    "points": null,
    "comments": [
      {
        "comment": "The \"hot take\" is using only Javascript as the comparison language.\n\nIOW, the headline would be more accurate as \"Typescript is the Best App Language if your only other option is Javascript\".\n\nHard to disagree with that.",
        "points": "19 points",
        "children": [
          {
            "comment": "Yeah it's otherwise basically trash-tier when compared to other compiled* languages.\n\nBut the browser is a mono-runtime ecosystem so shrug.\n\nWhat I don't understand is why people put themselves through writing it on the server, that is just masochistic. The lengths people go through to try justify it are very amusing but having worked at places with large amounts of TS backend code I can say I wouldn't do it again. I find most of the people that enjoy it/proclaim it's good have zero professional background in anything else, which makes sense I guess. You don't know how bad you have it if you never saw anything else and everyone around you is telling you how awesome Typescript is and why adding the 5th tool to your typechecking/bundling/minification/whatever-the-fuck-babel-bullshit stack is actually the best thing since sliced bread.\n\nTypescript isn't compiled, it's type-checked and striped. Apart from enums there are no constructs that require translation.",
            "points": "8 points",
            "children": [
              {
                "comment": "tsc --help outputs, \"Compiles the current project (tsconfig.json in the working directory.)\" (it's compiled)\n\nYou are mostly correct that Typescript is stripped out during the compilation process, however there are some other things which are actually compiled out a bit differently (like classes).\n\nI find most of the people that enjoy it/proclaim it's good have zero professional background in anything else, which makes sense I guess\n\nFor reference, I'm a Senior Engineer with twelve years of professional experience and twenty one years of experience total. Professionally I have used Ruby, Elm, PHP, Ruby, PureScript, Haskell, Go, and Typescript. In my personal projects I have used many more.\n\nYeah it's otherwise basically trash-tier when compared to other compiled* languages.\n\nCan you give an example of why you think this?",
                "points": "-6 points",
                "children": [
                  {
                    "comment": "tsc --help outputs, \"Compiles the current project (tsconfig.json in the working directory.)\" (it's compiled)\n\nWhat it says and what it does are two very different things. At best it could be called transpilation but it's really just stripping. This is why say for instance Bun is able to execute .ts files directly. FWIW I'm familar with both the architecture of tsc and the runtime stripper used in Bun.\n\nCan you give an example of why you think this?\n\nMany:\n\nTooling. tsc itself is dog slow and has a crazy number of options that can very quickly lead to pain. Want to actually ship code that is somewhat reasonable in size? Well you also need a bundler, which one? esbuild, swc, webpack? Ok but you are using some strange ass Babel shit so you are basically stuck with Webpack which is also, drumroll, dog slow. You want to debug or profile code? I hope you like Chrome web inspector and all the fun times of wiring that up yourself. IDE support, VS Code is the most usable but it's a poor IDE compared to something like IntelliJ, there is Webstorm which helps but then you are off the \"beaten path\". Speaking of VS Code run configs are crap, I don't want to configure a bunch of JSON nonsense to get tests to run properly, I want to hit something in the gutter and get an individual test to run etc.\n\nFrameworks. Obviously there are no first-class frameworks for Typescript for web backend work, everything is a bespoke pile of crap hacked together on Express (which itself sucks). Nest.js is basiically poor mans Spring. Test frameworks are an even more dire situation. Jest is by far the most popular but isn't remotely TS compatible, you either end up with ts-jest (eww, run tsc on every invocation) or some bullshit where you compile to JS first and then run tests and hope the sourcemaps make everything ok (they don't).\n\nModule systems. Related to Jest again, it will -never- support ESM. So if you want to use Jest you are producing CommonJS even if that is all it will be used for. Whoever thought it was a good idea to introduce an incompatible module system with no reasonable migration path was insane.\n\nRuntime. These aren't really Typescript problems but Node.js problems but whatever. async/await is pretty ass compared to alternatives like with Java and C# offer. Consider the case:\n\nlet promise = myAsyncFunction(); let value = await myOtherAsyncFunction(); let value2 = await promise;\n\nOn the outside that seems fine, but it's not. Because you didn't immediately await myAsyncFunction if it fails before you await the promise object you will get an UnhandledPromiseRejection that by default will blow up the runtime. Great. (this particular case can be handled with Promise.all() but if you add any work in between that doesn't work) Not to mention generally terrible APIs like fetch, (like why the fuck doesn't it take AbortController in a more reasonable and discoverable way?). Also it's single threaded. Who wants a single threaded runtime in 2024?\n\nSo what would I compare it to and find it fares poorly?\n\nKotlin - has JVM runtime, rock solid type system (even contra/covariance on generics! and reified generics!), modern syntax, null safety.\n\nC# - CLR runtime, again very good. pretty good typesystem (amazing access to primitives for writing memory efficient/allocation free code), amazing standard library and rock solid framework in ASP.NET Core. World class tooling, everything from debugging, profiling to MSIL inspection, etc.\n\nJava - JVM naturally, stood the test of time, rapidly improving (Java 21 just out with Virtual Threads) despite being old. Top tier frameworks like Spring Boot, Micronaut, etc. World class tooling, the best IDEs, debuggers, profilers, runtime diagnostics and monitoring, etc. Supported SDK for literally everything and first class language of the cloud providers.\n\nGo - definitely no my favourite but... wicked fast compilation times, a pretty decent latency tuned GC good for webby things. Still a better choice than Typescript.\n\nRust - amazing typesystem, great ecosystem of low level libraries unmatched for certain tasks. Maybe not a great competitor to TypeScript compared to the above options though due to it's high learning curve, slow compilation speed and small hiring pool.",
                    "points": "4 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "Tsc doesnt actually compile typescript, it transpiles it into js, which can then be run as js, not a compiled language (technically you could argue it is compiled by definition, but its still just js and run by a js engine, not a binary, so its misleading)\n\nI do personally like ts for its ease of development for POC or low load backend projects, but I do agree with other people that its inadequate for most professional projects.",
                    "points": "3 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "There are features in TS I like that I miss when using other languages. Type narrowing is probably the best example. I also like tagged unions. I find the type system makes it so much easier to refactor code when compared to Python. I like that it lends itself well to functional-style programming when compared to Java. There's also a nifty technique that allows you to make type-safe finite state machines. I wish some of these features could make it to other mainstream languages.\n\nI worked on large backend apps written in TS. Some parts of the app were very elegant and resistant to bugs due to masterful usage of the type system. Other parts were horrible abominations that violated all principals of good engineering. The horrible parts could have been written in any other language and been just as bad, so I don't really fault TS for their existence. Overall I enjoy writing TS. I also have experience with Python, Java, and C++. There are pros and cons to all of these and I wouldn't really say one is decisively superior over the others in all areas.",
                "points": "0 points",
                "children": [
                  {
                    "comment": "tagged/discriminated unions are indeed a very good feature. Other languages have equivalents though, Kotlin/Scala have sealed, Rust's enum type is powerful enough to do most of what you would want with TS union types, etc.\n\nType narrowing/type guards I'm a bit more split on. They are features necessary because of the design of the rest of Typescript but I am not convinced would be as useful in more constrained type systems.",
                    "points": "1 point",
                    "children": [
                      {
                        "comment": "Definitely want to use Kotlin/Scala more. Rust is cool, but I never really have a good reason to use it.\n\nOther languages have alternatives to type narrowing, but nothing is as concise. I appreciate that you can reduce nesting when paired with early returns.",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "While I didn't compare apples to apples with any other languages, I did discuss the features available in other languages in general. However, part of the point is that doing a feature-by-feature comparison of different languages is not useful if you can't deploy your app in your language of choice.",
            "points": "-7 points",
            "children": [
              {
                "comment": "While I didn't compare apples to apples with any other languages, I did discuss the features available in other languages in general. However, part of the point is that doing a feature-by-feature comparison of different languages is not useful if you can't deploy your app in your language of choice.\n\nI totally get all of that, and I'm not trying to shitpost you.\n\nI'm just saying that using the word \"best\" when thereis only one other alternative is a bit misleading.\n\nKinda like, if someone told you that they are the best spouse ever, you'd be completely surprised if, when questioned, they say \"well, compared to my spouse, I am!\".\n\nThere's a word you are looking for when comparing only two things, and it's not \"best\", it's \"better\".\n\nUsing the word \"best\" means that you are taking everything in that category into account. Using \"better\" means that you are taking only one other option into account.",
                "points": "3 points",
                "children": [
                  {
                    "comment": "I think that by that reasoning I should have titled the post, \"JavaScript is the Only App Language and It's Better With Types\". But, there are many application development languages. There's stuff like https://haskell-miso.org/; there are a ton of options for mobile including native development and widely used platforms like Xamarin; web apps can be built in Python, PureScript, Elm, Ruby or even C++ (https://www.webtoolkit.eu/wt) directly. You can also go fully native and build for each codebase directly and bypass the browser entirely. You can also build stuff almost entirely on the server like Kagi. While I did not enumerate these explicitly, they are all options for app development (and of course there are many more). But, I believe that if you take all of those options collectively they share a lot of common pitfalls and it's not necessary to discuss them in the post individually.",
                    "points": "-6 points",
                    "children": [
                      {
                        "comment": "But, there are many application development languages.\n\nIn the context that your post restricts itself to, namely web apps, there is literally only Javascript being used for the front-end, with TS as a popular alternative.\n\nAll those others are used so little that they're not even rounding errors. You have a larger chance of winning significant money in a national lottery than picking a random web application and finding it using Haskell.\n\nYou can also go fully native and build for each codebase directly and bypass the browser entirely.\n\nSure, but that's not in context of what your post was, was it? I've built fully native apps, and still do, without touching JS, but when I am talking specifically about web apps I'm not going to make any claims about how those other languages, like C++, are relevant, am I?\n\nAfter all, TS and JS are truly awful if you are building a native application. Good luck trying to make a call to epoll or WaitForMultipleObjects from your TS/JS code.\n\nIf you're making an APP where JS is possible, then sure, TS looks better. If you're making a native app, say an Android lifecycle event handler, or a local filesystem watcher, or a network packet capture ... well, then TS is not even in the running.\n\nYour post is only for apps that make sense to be written in JS, in which case TS is not the best language for app development, it's the best alternative to JS.",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Sure, if you insist on running on a JavaScript runtime, but there is obviously a world of options out there if you don't have that limitation.\n\nTypeScript is nice, but saying the \"best app language\" sounds like the author hasn't really used much else.",
        "points": "3 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Nah. But it’s great on frontend. Although, the latest JavaScript is very close to TypeScript and doesn’t require compilation. For backend, C# with generated client-side code for js/ts gives the best of both worlds.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_199hqcc",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://medium.com/@tigerasks/git-gud-b29c11ab2c60",
    "title": "Ok, so you can code. But maintaining your git history is also part of the job. Can you?",
    "points": null,
    "comments": [
      {
        "comment": "I mean, yeah. Getting a good enough working understanding of git to maintain a clean commit should take maybe a day or two at best. There are thousands of excellent existing tutorials. Why is this something we need YADBP* about?\n\n*Yet another derivative blog post",
        "points": "-1 points",
        "children": [
          {
            "comment": "Well, the article isn't about git commits, it's primarily about the commit history. I.e. branches and rebase.\n\nWhich in my experience is something people tend to misunderstand because they spend \"a day or two at best\" trying to figure out how git works, then toss the manual in the corner and later get frustrated when Git doesn't work the way they thought it did.",
            "points": "-1 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "What is wrong with another article/tutorial?",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I would love to maintain my git history, but the design of git prohibits it.\n\nFor example, I saw someone's commit message from a few months ago that references the wrong issue number. Very misleading. Totally impossible to fix.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_199ggty",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://github.com/manifold-systems/manifold/blob/master/manifold-deps-parent/manifold-sql/readme.md",
    "title": "Type-safe native SQL directly in yer code",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_199ea0g",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://youtu.be/ClVyDMbGwh8?si=DvdoUj_hr8Igv6AT",
    "title": "Java Reflection Use Case - Finding Instance Methods and Class Methods",
    "points": null,
    "comments": [
      {
        "comment": "Or you could read documentation?",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_199arwo",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://youtu.be/aD7rOQSrXl8?si=3kbiIArJTkpKAhKL",
    "title": "Made a video explaining the design and compilation of my programming language",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1998l6n",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://blog.peerdb.io/ssh-tunneling-for-secure-postgres-replication",
    "title": "SSH Tunneling for Secure Postgres Replication",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1998aeg",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://github.com/jkool702/forkrun",
    "title": "Presenting 'forkrun': the fastest pure-bash loop parallelizer ever written",
    "points": null,
    "comments": [
      {
        "comment": "how lucky, i was just thinking about how slow all of the currently available pure-bash loop parallelizers are.",
        "points": "24 points",
        "children": [
          {
            "comment": "I know you are trying to make a joke, but all the other codes written in bash to parallelize loops are at least a couple orders of magnitude slower. This is because forking is slow as shit in bash, and they all rely on forking individual calls to whatever you are parallelizing. Somewhat ironically, forkrun doesnt do this - it forks persistent coproc workers, distributes stdin to them and they run without any additional forking.\n\nPerhaps more impressive though is that you can interpret the post title as \"the fastest loop parallelizer ever written, which just so happens to be written in bash\" and it is still basically correct.\n\nforkrun is faster than xargs (which is compiled C) on basically all the problems that you care about run time....In my testing for all problems that take more than 50-60 ms to run forkrun is faster than xargs (often twice as fast). On sufficiently quick problems xargs's lower \"no-load run time\" (~2-4 ms for xargs vs ~20-25 ms for forkrun) gives it an advantage\nforkrun runs circles around gnu parallel (which is written in many languages, but is ~3/4 perl).\n\nNote that these are the fastest xargs and parallel methods im comparing against...they are not being crippled by forcing them to, say, only use 1 argument per function call.",
            "points": "14 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "source <(curl https://raw.githubusercontent.com/jkool702/forkrun/main/forkrun.bash)\n\nSigh. I'm getting really fed up with people recommending this sort of thing. It's just a massive security problem waiting to happen. Download something at random from the Internet and automatically run it? No thanks.",
        "points": "-20 points",
        "children": [
          {
            "comment": "You can of course download it, browse the code to make sure its not malicious, and then source it if you prefer. You can replace curl with wget. You can clone the git repo. You can copy and paste the function definition into the terminal (or even manually re-type all 1000 lines verbatim) if you really want.\n\nThat said, unless you are willing to take the time to actually look through the code yourself (which im sure everyone does for everything they ever install on their computer) then Im not sure this offers much more protection than just running (as a standard non-root user)\n\nsource <(curl ...)\n\n\nAnd since the post really didnt need 2 more paragraphs explaining all this I went with the one-liner that gets it done and ensures future readers get a version with bug-fixes already incorporated. But, ya know, you do you..feel free to source the code however youd like. But you do need to source the forkrun function somehow if you want to use it.",
            "points": "27 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I mean, is a brew formula that does that exact same thing really that different?",
            "points": "15 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "At random? You can look at exactly what you’re downloading.",
            "points": "4 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1997xyq",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://testing-tips.sarvendev.com/",
    "title": "Unit testing tips",
    "points": null,
    "comments": [
      {
        "comment": "This is fantastic.\nI don't use PHP, but since it covers topics related to testing, it was worth reading",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19979xg",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://a0.to/reddit-webauthn",
    "title": "WebAuthn - A Short Introduction",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1994tf2",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://medium.com/@bhattarai.alex402/distributed-data-done-right-a-golang-journey-with-consistent-hashing-49125707165b",
    "title": "Distributed Data Done Right: A Golang Journey with Consistent Hashing",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_199439a",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://donno2048.github.io/HTML-PDF-JPEG/",
    "title": "An HTML page which is also a valid PDF file and JPEG image",
    "points": null,
    "comments": [
      {
        "comment": "These are known as \"polyglot\" files in some circles, and are a real thorn in the side for some security mechanisms that need to validate and sanitize files and their contents.",
        "points": "144 points",
        "children": [
          {
            "comment": "I know, I like this one in particular because, first, it's easy to see the effects because it's online, secondly, because you can embed PDFs and JPEGs in HTML (as in this one), and thirdly, because it combines binary and non-binary formats",
            "points": "51 points",
            "children": [
              {
                "comment": "There was a research project at Georgia Tech a few years back (2018-2019?) to study these. I don't know whether you're familiar with that (or can find it). They were looking for reliable ways to find all the types.",
                "points": "25 points",
                "children": [
                  {
                    "comment": "I'm not familiar with it, can you link it?",
                    "points": "5 points",
                    "children": [
                      {
                        "comment": "Sadly, no. I'd be Googling just like you.",
                        "points": "4 points",
                        "children": [
                          {
                            "comment": "K thanks anyways",
                            "points": "4 points",
                            "children": [
                              {
                                "comment": "I found this research paper on polyglot files\n\nhttps://arxiv.org/pdf/2203.07561.pdf",
                                "points": "7 points",
                                "children": [
                                  {
                                    "comment": "JPEG alert",
                                    "points": "17 points",
                                    "children": [
                                      {
                                        "comment": "This is a golden joke",
                                        "points": "6 points",
                                        "children": [],
                                        "isDeleted": false
                                      }
                                    ],
                                    "isDeleted": false
                                  },
                                  {
                                    "comment": "Thanks! Will definitely check it out when I'll have time",
                                    "points": "0 points",
                                    "children": [],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Why are they a security issue? This looks super interesting",
            "points": "7 points",
            "children": [
              {
                "comment": "Secure boundary devices need to examine the contents of the files that are coming and going. If a file can fool the software that's checking the contents, it has a better chance of hiding malware or exfiltrating confidential information.\n\n20 years ago, many email servers started denying attachments that had certain file suffixes, like \".exe\". The countermeasure was simply to rename your file \".exe.txt\", telling the recipient that they'd need to rename the file to use it.\n\nThese days, many servers are smarter. \"Oho! You say that's a '.txt' file? Well, maybe it is, and maybe it isn't. Let's have a look, shall we?\"\n\nPolyglot files can be used to fool these sorts of security measures.",
                "points": "38 points",
                "children": [
                  {
                    "comment": "Sneaky",
                    "points": "5 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "You see stuff like this the CSP hacks where the browser interprets mime types automatically and so can literally execute a file with no extension in some cases. They're getting better but it was a big problem. Browser trying to be helpful ends up really messing with your file extension based security.",
                    "points": "2 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "Some attachments are still in the form \"image.jpg - www.totallynotevilsite.com\"",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Say Acrobat Reader has a security vulnerability. You want to exploit that by tricking someone into downloading a PDF and opening it. However, people don't trust download links from sketchy websites.\n\nSolution: Create a JPEG of a cute cat, that is also a malicious PDF, and show it on your web site. When people right-click on the image and select \"save image as...\" they now get the file with a PDF extension. If they double-click on the file it opens in Acrobat Reader and take advantage of the vulnerability.",
                "points": "11 points",
                "children": [
                  {
                    "comment": "But why would acrobat open a jpeg",
                    "points": "-6 points",
                    "children": [
                      {
                        "comment": "File gets downloaded as pdf, double clicking a pdf would open acrobat",
                        "points": "4 points",
                        "children": [
                          {
                            "comment": "If the file is in pdf in the server the browser wont display if its set as image source for the bait tho.",
                            "points": "1 point",
                            "children": [
                              {
                                "comment": "It should if you set the content type to image/jpeg.",
                                "points": "4 points",
                                "children": [],
                                "isDeleted": false
                              },
                              {
                                "comment": "You’re making a lot of assumptions! Security is only as good as the weakest link",
                                "points": "0 points",
                                "children": [
                                  {
                                    "comment": "For the file to be downloaded as pdf it has to be hosted as pdf.\n\nIf you put a pdf file as your src in your img, neither webkit nor chromium browsers will display it as an image.\n\nAre any of those statements incorrect?",
                                    "points": "3 points",
                                    "children": [
                                      {
                                        "comment": "Browsers will base the image type off the content-type http headers. Once saved, the OS can go off the file suffix.",
                                        "points": "4 points",
                                        "children": [],
                                        "isDeleted": false
                                      },
                                      {
                                        "comment": "Yes.\n\nYou can set content-type:image/jpeg to have the browser ignore the file name and display as an image anyway.\n\nYou can set content-disposition: filename=\"whatever.pdf\" to specify the default download filename regardless of the filename in the address",
                                        "points": "3 points",
                                        "children": [],
                                        "isDeleted": false
                                      }
                                    ],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              },
                              {
                                "comment": "Not necessarily, some may check the header to determine what kind of file it is, some may check it's name, or some may check the contents to look for something which identifies what the file is. Pretty much every binary format uses something called a magic which is a few bytes that are special to that format which identifies what it is.",
                                "points": "0 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "More like a \"Look how browsers and tools ignore errors in formats\" file than other thing",
        "points": "20 points",
        "children": [
          {
            "comment": "Touche",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "<img src=.>",
        "points": "17 points",
        "children": [
          {
            "comment": "Yeah, I like that very much...",
            "points": "6 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Source: https://github.com/donno2048/HTML-PDF-JPEG",
        "points": "12 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "This is fantastic, opens so many possibilities!",
        "points": "35 points",
        "children": [
          {
            "comment": "Like what? More scams?",
            "points": "12 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "The source just uses the same URL for the image and the PDF embedding, I first thought about posting it and asking if anyone knows how it is even possible... lol",
            "points": "9 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Except it doesn't open up any such thing, because it isn't a valid PDF file (lots of software won't render it) nor is it valid HTML but does tend to render by leaning on permissive browser behaviour from the Bad Old Days of broken HTML everywhere.",
            "points": "9 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Next level - make it render as the identical image in all formats!",
        "points": "26 points",
        "children": [
          {
            "comment": "I thought it would look less reliable. Because you could think the PDF reader just realized it's a JPEG and rendered it as one.",
            "points": "12 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "AKA: A binary blob which some web browsers can be convinced to render as HTML (although it is invalid as such), a JPEG (with a valid header and ignored meta, might actually be technically valid) or a not valid PDF file, which many readers such as Skim won't render due to the junk preamble before the %PDF signature (and so online validators such as pdfen reject it).",
        "points": "20 points",
        "children": [
          {
            "comment": "I might stretched the definition of \"valid\" a little",
            "points": "13 points",
            "children": [
              {
                "comment": "LOL yes, that's very much an understatement!\n\nThe concept of validity in software is not a woolly thing.",
                "points": "3 points",
                "children": [
                  {
                    "comment": "The concept of validity in software is not a woolly thing.\n\nI'm sorry but this is just not true. You should of course strive to adhere to the published standard (if one exists and is sufficiently explicit), but when you work with a global format you do have to be aware of other implementations.\n\nThe standards for animated GIFs, for example, are a mess:\n\nThe official GIF89a standard supports four \"disposal\" methods for frames: 0) unspecified, 1) leave the frame in place, 2) replace the frame with the background color, 3) replace the frame with whatever was there before. In practice, barely anything supports method 3 because it's harder than the other ones. You can put it in your GIF and it will conform to the standard, but nothing will render it correctly.\n\nThe official GIF89a standard stores delays between frames as an unsigned 16-bit integer representing hundredths of a second. So according to the standard you could have a GIF with 100 FPS, or use zero-delay frames to build up an image with more than 256 colors. In practice, early browsers capped GIFs at 10 FPS, so a lot of early GIF creation software would just set the frame delay to 0 or 1, so now every piece of software that displays GIFs has to still cap them at 10 FPS or they won't display correctly.\n\nThe official GIF89a standard doesn't mention looping at all. Looping GIFs don't have a standard! Netscape Navigator implemented looping as a non-standard extension to GIFs in the 90s and every implementation since is just copying what they did.\n\nWhat is and is not a valid animated GIF, and how that GIF should be displayed, is a woolly thing that relies on folklore and convention as much as it does on the official standard—and that's just for one file format. Validity is almost always going to be woolly, despite our best efforts, because people can be lazy in their implementations (and in their specifications, for that matter) and at the end of the day it doesn't matter whether you adhered to the spec if your file doesn't work.",
                    "points": "6 points",
                    "children": [
                      {
                        "comment": "It's a strange interplay imo. We obviously strive for validity because we have standards documents. But implementations still decide to go their own way, ignoring the standards, choosing to be invalid in favor of.. convenience?",
                        "points": "1 point",
                        "children": [
                          {
                            "comment": "Yes. Validity and implementation are orthogonal.",
                            "points": "1 point",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "[deleted]",
            "points": "1 point",
            "children": [
              {
                "comment": "No. It does not. It contains a binary JFIF sequence at the start of the file before any declaration of content type.\n\nThat's why the W3C validator rejects it.\n\nSpecifications for all these formats are old, widely available and easy to understand. It is a strong confirmation of my biased assessment of the dreadful state of the software industry that I should find myself explaining something so totally elementary in a programming forum!",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Indeed, macOS Preview.app says:\n\n⚠️ The file “HTML-PDF-JPEG.pdf” could not be opened.\nIt may be damaged or use a file format that Preview doesn’t recognize.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I got inspired by this and made a polyglot which browsers consider to be valid HTML, CSS, JavaScript, and JPEG https://p.cat.ax/polyglot/index.html",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "According to file on Mac it is a jpeg (regardless of extension). If you try to open it without extension it opens it as a (garbled) text file. It refuses to open it as a pdf in Preview. Safari will open the pdf but show a blank page.",
        "points": "2 points",
        "children": [
          {
            "comment": "Safari won't show the PDF? That's weird... About the file yeah, it makes sense, the HTML and the PDF are \"parasites\" in the JPEG file (it could go in another way but I chose this method because it's the easiest to implement)",
            "points": "1 point",
            "children": [
              {
                "comment": "I don’t know the details but Apple has run into issues with permissions elevation and arbitrary code execution by PDFs for a while now. Something to do with a part of the OS’s Core Image processing library running as kernel extension so then flaws in the pdf processing library could use overflows to get permissions it shouldn’t. There were a few PDF based iOS jailbreaks back in the day like this. Comex is the nickname of a developer who was brilliant at finding these exploits.\n\nhttps://arstechnica.com/gadgets/2010/08/apple-patches-ios-pdf-flaw-that-allowed-web-based-jailbreak/",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "See my other post. It is unsurprising. It is neither valid HTML nor a valid PDF file. If either render, it's by luck not judgment. It might be a valid JPEG.\n\n(Edited: PDF 32000:2008 / v1.7 ISO, section 7.5.2 \"file header\", says \"The first line of a PDF file shall be a header consisting of the 5 characters PDF%-)",
                "points": "1 point",
                "children": [
                  {
                    "comment": "You're all correct I just thought it's cool you can do that...",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Nice, another exemple of this is K. Lange's resume which is both a PDF and a CDROM ISO for his hobby OS. However I doubt that they work in the same way.",
        "points": "1 point",
        "children": [
          {
            "comment": "Wow! That's actually amazing",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "looks legit\n\nhttps://i.imgur.com/TDR4p2R.png",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Ange Albertini, is that you?",
        "points": "-1 points",
        "children": [
          {
            "comment": "Who is that?",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Okay? That's easily done by just creating multiple versions of the file in the appropriate server directory.",
        "points": "-35 points",
        "children": [
          {
            "comment": "No, it's not... Download the file to your PC and change the extension, it has nothing to do with the server.",
            "points": "26 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "That's not what's happening.\n\nWhat's happening is the PDF and JPEG elements are stored via html comment (and I assume a cleverly placed bracket) that are in the source code, so when you rename the file to PDF or JPEG, only the relevent bits are displayed because the program running it doesn't care about the stored HTML code.\n\nI ran it in Windows 11's Gallery Program and in Firefox (with PDF.JS) and can confirm it works.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Acrobat won't open it.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": ":|",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I can hear the screams of anti malware software.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Reminds me of this: https://github.com/johnjohnsp1/gb-nes-pdf-html-zip",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1993d7m",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://thecontextwindow.ai/p/rich-hickeys-glossary-and-decision-matrix",
    "title": "Rich Hickey's glossary and decision matrix",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19933sa",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://github.com/cxli233/FriendsDontLetFriends",
    "title": "Friends Don't Let Friends Make Bad Graphs",
    "points": null,
    "comments": [
      {
        "comment": "As if I have any choice. If the designer and management want a pie chart, they're going to get a pie chart no matter what I say.",
        "points": "12 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Thanks, this was helpful! I was going to use pie charts for something I've typically seen represented with pie charts, but you've convinced me that stacked bar charts instead.\n\nI assume there is nothing wrong with flipping the axis, so that the % is on the x axis? Something vertical doesn't fit the where I want to put it",
        "points": "7 points",
        "children": [
          {
            "comment": "Stacked columns/bars suck, too. If you have a group comparison as shown in the sample, try a bumps chart instead (there is an R package, I don't remember what they call it). If you really only want to compare categories within a single group just use unstacked columns.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Trying to be helpful with a summary:\n\nThis GitHub project is a comprehensive guide that discusses various common mistakes in data visualization and provides insights into better practices. It emphasizes avoiding the use of bar plots for means separation, violin plots for small sample sizes, bidirectional color scales for unidirectional data, and the pitfalls of not reordering rows and columns in heatmaps. The project also warns against using certain types of visualizations like pie charts, concentric donuts, and misusing color scales such as red/green and rainbow scales. Additionally, it stresses the importance of considering different layouts for network graphs and the necessity of reordering stacked bar plots for clarity. The guide aims to improve data visualization by highlighting these often-overlooked aspects and providing solutions.\n\nIf you don't like the summary, just downvote and I'll try to delete the comment eventually 👍",
        "points": "6 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "All violin plots are bad.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Check out Tufte’s books. The Visual Display of Quantitative Information is excellent and covers many ways data is manipulated improperly.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "In pie charts, area does not represent data; area is incidental. Only the arc length, which is proportional to angle, matters. This is one of the numerous pitfalls of pie charts.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1992ote",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://medium.com/@ktuusj/parallels-of-programming-and-writing-5e051bf447d",
    "title": "Parallels of programming and writing",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1992n40",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://medium.com/nerd-for-tech/five-tips-for-the-beginner-programmer-25bde40d5aee",
    "title": "Five tips for the beginner programmer",
    "points": null,
    "comments": [
      {
        "comment": "Can't we just block that nonsensical medium blog spam in this subreddit?",
        "points": "6 points",
        "children": [
          {
            "comment": "Should be a rule that article posts without a corresponding discussion are banned.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Focus on learning the logic part of programming first. Like how loops work, why we find the modulus of something.\n\nMain difference between most programming languages is the syntax, not the logic( for basics obviously)\n\nKeep checking out the other solutions after finding the solution you've found, in order to optimize your methods.\n\nDon't be afraid to use AI to explain code snippets, meanings.\n\nKeep your learning self paced. Do not lose valuable concepts for finishing your journey early as possible.\n\nLastly, bugs and issues will always be annoying . Don't be discouraged to learn and overcome those hurdles in your journey.\n\nGoodluck ^_^",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "What a shit article.\n\nIf you get stuck, you need to learn more.\n\nGee, thanks for the tip, dipshit.",
        "points": "1 point",
        "children": [
          {
            "comment": "And I got banninated for 3 days from Reddit for pointing out dangerous challenges—- errm bringing a bad vibe to OC …",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1992lzd",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://medium.com/@ktuusj/dart-parsing-rss-153497e686f5",
    "title": "Dart parsing RSS",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19925c5",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.dolthub.com/blog/2024-01-17-writing-mysql-procedures/",
    "title": "MySQL Stored Procedures: How and why with examples",
    "points": null,
    "comments": [
      {
        "comment": "The number one reason for SPs (and views!) is to explicitly declare and define the operations your database supports, in a way that allows you to refactor your table layout should you be required to for whatever reason - maintenance, scalability, perf, etc.)",
        "points": "7 points",
        "children": [
          {
            "comment": "This heavily depends on what your application does. If its primarily a UI/API on database, then in makes sense to protect the database. If database is where because RAM is too small and can loose data (hence you need non volatile storage), when it makes sense to keep DB dumb and easily replaceable.\n\nMost applications I worked on where in the second category. I also noticed that sometimes people protect the DB because it struggles, but usually it struggles because row storage is used to store factual/document type data. Once you move that into something else, most of the problems tends to go away (most of the data by volume and velocity as well).",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I think these days, web services fill this niche more often and people treat their DBs as dumb data stores as much as possible. There are tradeoffs to this approach obviously.",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Blog author here. This is a tutorial on how to write stored procedures in MySQL, with examples of all the major parts of the language and a discussion of use cases, such as:\n\nSystem maintenance\nGDPR compliance\nData integrity checks",
        "points": "4 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "BEGIN...END blocks do not start transactions\n\nBEGIN...COMMIT/ROLLBACK do work for transactions. This is an extremely important point.\n\nFrom MySQL docs:\n\n\"BEGIN and BEGIN WORK are supported as aliases of START TRANSACTION for initiating a transaction. START TRANSACTION is standard SQL syntax, is the recommended way to start an ad-hoc transaction, and permits modifiers that BEGIN does not.\n\nThe BEGIN statement differs from the use of the BEGIN keyword that starts a BEGIN ... END compound statement. The latter does not begin a transaction. See Section 13.6.1, “BEGIN ... END Compound Statement”.\"\n\nYou should always explicitly BEGIN and either, COMMIT or ROLLBACK transactions.\n\nJust look at the current scandal with Fujitsu and the UK Post Office. It looks like poor transaction handling was likely the cause.\n\nEdit: missed the important bit!",
        "points": "3 points",
        "children": [
          {
            "comment": "to be fair when you're running a query (yes. calling an sp is a query) you are already in a transaction.",
            "points": "2 points",
            "children": [
              {
                "comment": "Autocommit is enabled by default, but so are many other things.\n\nI always set our systems to autocommit = 0 and explicitly start commit/rollback transactions. However, I work in financial services and deal with £10,000,000,000 worth of trades a day. I have seen the fuckups that occur with autocommit and it results in long weekends and people being fired LOL.",
                "points": "6 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "There were a LOT of causes for separate issues in the UK Post Office thing, but managing transactions over batch processes from a distributed system is several orders of magnitude harder than in a centralized DB.\n\nIf you want to dig in further, there's a lot of (quite terrifying) detail in some of the transcripts\n\nhttps://www.judiciary.uk/wp-content/uploads/2022/07/bates-v-post-office-appendix-1-1.pdf",
            "points": "1 point",
            "children": [
              {
                "comment": "I was watching the inquest live on the BBC yesterday. One of the developers was being questioned. Some of the revelations were shocking.\n\nThanks for the link.",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Now that you know what store procedures in mysql are here is when you should use them: never.\n\nShout out to cursors at the end as well, something else you should never use.\n\nJust my opinion though. You guys do what you want.",
        "points": "5 points",
        "children": [
          {
            "comment": "I've never used them in a production system",
            "points": "0 points",
            "children": [
              {
                "comment": "They work better in Sql Server but MySql they are just hard to manage. Not to mention you have to go out of your way to source control them. Also the idea of putting business logic into your data layer is not ideal.\n\nThey have their place but I would avoid them if at possible unless you really know what you are doing.",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1991ve9",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.preethamrn.com/posts/who-actually-uses-is-odd",
    "title": "Who actually uses is-even and is-odd?",
    "points": null,
    "comments": [
      {
        "comment": "I did a deep dive a while back and it seems like the guy who created them also created hundreds of similar packages around the same time.\n\nTypically the actual code is just a few lines that do something simple (e.g. pascalcase, is-number, falsey) and then there's tons of scaffolding like CI/CD, ESLint configs, testing, benchmarks, a detailed readme, etc. that might give the impression that it's a more substantial library at first glance.\n\nThese tiny packages will often pull each other in as dependencies. He also has a few more substantial projects that pull in some of these small ones.\n\nIt doesn't look like he creates packages like that anymore, although he actively maintains all the old ones. I got the impression (or maybe he actually said this somewhere, I forget) that he was trying to get into the industry in the early-mid 2010s and created this constellation of interconnected packages to get tons of NPM downloads to list on his resume.",
        "points": "632 points",
        "children": [
          {
            "comment": "I got the impression\n\nthat was obviously the issue- in addition, the community advocated small do-one-thing type packages (at the time. Is this still the case?)",
            "points": "217 points",
            "children": [
              {
                "comment": "It's important to understand the tooling landscape back then.\n\nMicro-packages were preferred because bundling systems didn't really support tree-shaking so if you included that 256kb library with a bunch of useful functions you shipped that 256kb library.\n\nSo folks went \"Okay, let's just package and test singular functions and focus on addressing all potential concerns for that one particular function\".\n\nNowadays it's usually just an ES6 compatible library and we just tree-shake the hell out of it using a proper bundler; though all of these micro-packages still exist and folks still use them.\n\nIt's just a big ole cry that there needs to be an expanded standard library, the current one has improved significantly but folks generally still reach for things like underscore/lodash.\n\nMobile bandwidth has generally improved enough in markets that businesses care about to not care too much about fussing over site sizes anymore either... usually imagery and video blow past all the script / css / html sizes by an order of magnitude.",
                "points": "147 points",
                "children": [
                  {
                    "comment": "It's just a big ole cry that there needs to be an expanded standard library, the current one has improved significantly but folks generally still reach for things like underscore/lodash.\n\nI'm really working on my tendency to just answer these types of questions with \"because the JS/Node is a dogshit ecosystem where the amateurs run the asylum\", so:\n\nWhy on Earth does JS not have a stdlib? It's been so many years, and there are so many enormous, well-capitalized parties for whom the health of the ecosystem is valuable.\n\nHell, they created an entire new language to deal with JS's pathologically bad typing design. What's the story behind the continued lack of a basic stdlib that does the type of handling that the blogpost mentions?\n\nI am sincerely asking here. The JS ecosystem mystifies me. Eg, I've been using Typescript, which is an okay language[1], but JS is so horrific that I can't imagine why anyone is still using it when TS exists (other than having to deal with another tooling layer).\n\n[1] I even miss certain TS things when I write Python, in the same way I miss certain Pythonic things when I write C++. I never miss Javascript.",
                    "points": "55 points",
                    "children": [
                      {
                        "comment": "I mean isn't ecmascript the standard lib? It is very bare bones, but I think functionally there is nothing stopping someone from filling out the js standard with more color; isEven, isOdd, ect..\n\nI highly doubt any feature request to tc39 for most of these types of functions will make it past stage 0 or 1 but the path is open for people to try.\n\nWhen calling out the need for a standard lib what functions are you begging for?",
                        "points": "17 points",
                        "children": [
                          {
                            "comment": "Anything that a sane language has. Golang, python, etc. Where you don't need people to bundle a bunch of random crap to flesh out a lib.\n\nNow, golang is minimalistic when it comes to stdlib, it doesn't even have sets, for example. But its miles better than what JS used to be, and significantly better than even ES6.\n\nAnd yes, someone is stopping from fleshing out the standard. TC39 will tell you to go f yourself with any kind of propsal, as they've done in the past.\n\nhttps://github.com/tc39/proposal-built-in-modules/issues/19\n\nLots of \"yeah, but we don't need that\" in that discussion post.",
                            "points": "8 points",
                            "children": [
                              {
                                "comment": "The sheer amount of times I've seen (including in that discussion) people say \"but I like JS because it doesn't have a stdlib!\" astounds me. I do not understand how lacking basic functionality to make developers' lives easier makes a language better. If you don't like the way the standard library does something, you don't have to use it (see: C and C++ for a long time, and even still today for some parts of their standard libraries or in fields like embedded development). On the other hand, entirely lacking the standard library guarantees that you either do it yourself or find a third-party library for it, which comes with its own risks and potential downsides in comparisons to a standard library.",
                                "points": "10 points",
                                "children": [
                                  {
                                    "comment": "but I like JS because it doesn't have a stdlib!\n\nWere they a JS runtime maintainer?",
                                    "points": "3 points",
                                    "children": [
                                      {
                                        "comment": "Yeah, kinder sounds like \"it's less work for me the js maintainer.\"",
                                        "points": "-1 points",
                                        "children": [],
                                        "isDeleted": false
                                      }
                                    ],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          },
                          {
                            "comment": "",
                            "points": "",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "What's sad is there were pretty decent attempts at \"batteries included\" libraries like jquery, lodash, and backbone, but those became uncool because reasons.",
                        "points": "10 points",
                        "children": [
                          {
                            "comment": "Because each became too bloated. I've always wished that JS had something like Java's Apache Commons - a group that comes together to build standard, focused utility libraries around common functions (strings, io, collections, etc.).",
                            "points": "15 points",
                            "children": [],
                            "isDeleted": false
                          },
                          {
                            "comment": "I think there's legitimate reasons to find jquery bloated, especially if you are not targeting IE8. jQuery's Sizzle library powers the famous $(\".selector\") function, parses and resolves lots of selectors in pure JS, dozens of feature-tests to guard against buggy browser behavior, a remarkable piece of engineering. But applications today can easily swap it with the standardized querySelectorAll and won't even notice the difference save for cutting 20kb of mostly-dead-code polyfill. It's a victim of its own success; qSA was standardized in the first place because $() was an extremely popular reason to use jQuery.\n\nI remember AJAX stuff being a big selling point of jQuery too, but now we have Promises and fetch covering mostly the same area. CSS transitions have obviated the need for stuff like .fadeOut.",
                            "points": "5 points",
                            "children": [],
                            "isDeleted": false
                          },
                          {
                            "comment": "I still remember fighting to get jQuery to work with angular js when I was starting in web dev.\n\nLodash was mostly deprecated when the majority of it's functionality became available in ecmascript 6.\n\nI don't think backbone ever really had a problem, just like rails it didn't win the mass to stay super relevant.",
                            "points": "3 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "In many cases the culprit to missing functionality is backwards-compatibility and the fact prototyping exists. The policy is avoid breaking changes to web, and mixed with the possibility of prototyping it is very difficult to add functionality to existing types.\n\nOther languages can easily introduce breaking changes since code is compiled or targets a specific runtime, but to my knowledge JS is different as all browsers ship with a runtime that needs to support all versions of the language simultaneously.",
                        "points": "2 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "There is a strong belief that \"we musn't break the web\", i.e. we can't have a Python 2 to 3 situation. Many people were unhappy about Java--one of the most backwards-compatible languages out there--making breaking changes to their Unsafe APIs. No wonder why the governing bodies are so hesitant to add features. We don't want to end up with a broken standard like C++ <regex> or std::vector<bool>.",
                        "points": "1 point",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "I'm really working on my tendency to just answer these types of questions with \"because the JS/Node is a dogshit ecosystem where the amateurs run the asylum\"\n\nIf I did that, I'd just never post about javascript. But people keep blaming the users for the deficiencies of the language. It's a toxic mentality that is almost always tied to some sort of weird, self-aggrandizing argument: \"I would never use these libraries because I can program all by myself.\"",
                        "points": "2 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "Micro-packages were preferred because bundling systems didn't really support tree-shaking so if you included that 256kb library with a bunch of useful functions you shipped that 256kb library.\n\nTangent, but imo this this also an issue in other spaces, like plug-in vendors. I was recently trying to find a good text editing plugin for Paint.NET (none of them were that good, I ended up writing my own, lol), and found the community there very annoyingly bundle-focused. Each post for a simple multi-line text editing tool with word wrapping linked to the creator's bundle of basically all their projects. Some were themed (here are all my text rending tools), some were just essentially random (here's just all the shit I've made), and some were excessive (here's my modpack with a fuckton of who cares). Not having the option to pick and choose specifically what I wanted from the get go was very, very tedious and annoying.\n\nI feel the same way with libraries sometimes, especially when there's a mix of libraries that do certain things better than others. Tree shaking is important, but doesn't cover the whole issue at dev-time.",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "",
                    "points": "",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "That’s still the case, but there’s a difference between “do one thing” and “write a single if statement” that I think was missed along the way",
                "points": "97 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "If I see those in a PR they’re instant rejections",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "he actively maintains all the old ones\n\nLook, that's all I can really ask for.",
            "points": "38 points",
            "children": [
              {
                "comment": "Keeps him busy and away from writing new ones",
                "points": "30 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "That is the most stereotypical JS dev story. I remember trying to break into the industry myself and trying to find open issues on FOSS repos that I might be able to fix.\n\nBefore y'all try to get all high-and-mighty because you program in C++ or whatever, there is also this story: https://www.theverge.com/2021/4/30/22410164/linux-kernel-university-of-minnesota-banned-open-source",
            "points": "87 points",
            "children": [
              {
                "comment": "What's the point of that story?",
                "points": "29 points",
                "children": [
                  {
                    "comment": "Indeed… that’s an interesting story by itself but no link to the actual subject.",
                    "points": "2 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "As a C++ dev I'd have to come down quite a lot to be high and mighty. Just kidding :P",
                "points": "15 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "I remember trying to break into the industry myself and trying to find open issues on FOSS repos that I might be able to fix.\n\nHow did you, in the end?",
                "points": "2 points",
                "children": [
                  {
                    "comment": "I ended up working a bit on one (r opensci), but honestly, it didn't help and wasn't worth it.\n\nEdit: it wasn't worth it because I didn't actually care about the software. By all means, work on FOSS, just do it because you either need it for something or because you want to work on that software. Don't do it to pad a resume (or to test putting vulnerabilities on the Linux Kernel)",
                    "points": "6 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "This was a very interesting read. Thank you! I’m shocked by the Linux’s community reaction. I mean, if you’re leaving already reviewing commits and confirming that they’re good to merge into the main project, shouldn’t cybersecurity implications be part of that? This seems more like Linux’s fault than the university of Minnesotas.",
                "points": "-2 points",
                "children": [
                  {
                    "comment": "Linux maintainers have standards, U of Minn researchers purposely inserted security vulnerabilities. Of course thats a ban",
                    "points": "31 points",
                    "children": [
                      {
                        "comment": "Yes I agree on that 100%. But why were these issues making it through in the first place? IMO there should have been maintainers looking at every commit for security issues (in addition to everything else). The article even calls out the fact that quite a few vulnerabilities made it through their reviews and they only found it later. What’s to stop anyone else who has lower ethical standards to exploit it further?",
                        "points": "8 points",
                        "children": [
                          {
                            "comment": "he article even calls out the fact that quite a few vulnerabilities made it through their reviews\n\n?? Did I read the article wrong? I didn't find a mention of any vulnerability making it through. It mentioned that quite a number of patches were accepted (most of them being \"great\"), and some were reverted, but it didn't mention a single vulnerability among them.",
                            "points": "2 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "This seems more like Linux’s fault than the university of Minnesotas.\n\nImagine some security researchers go into a random shop and steal items as part of their experiment on shoplifting. Would you be surprise if the shop owner was upset and banned the researchers from coming back, even if they promised to not steal again?\n\nIt would have been very different if they had gone to the kernel developers and collaborated on a project to test the review process and improve scrutiny.",
                    "points": "19 points",
                    "children": [
                      {
                        "comment": "What if they stole things and then returned them to demonstrate security holes? Theft makes things more expensive for everyone so they’re doing a public good.\n\nThat’s the analogy to this story, because they removed all the vulnerabilities before they got released.",
                        "points": "2 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "",
                "points": "",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Micro packages were a fad for a while. Downside of having easy packaging tools, I guess.",
            "points": "26 points",
            "children": [
              {
                "comment": "It was a combination of in the past having easy packaging tools and being a royal pain in the ass to set up tree-shaking for production. People always could download lodash and get all of those functions in one package, but thought it would either add to the script download size. Having really small packages with a single function got around this by only having dependencies with the micro-packages you need. Thankfully javascript build tools are slightly less horrifying and you can get tree shaking for free without 10,000 lines of gulp or webpack configuration.",
                "points": "14 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Jon Schlinkert is (was?) a notorious self-promoter who used his massive dumb npm contributions as a badge of talent and importance in the community.\n\nSindre Sorhus has also created massive amounts of bullshit packages.",
            "points": "22 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Typically the actual code is just a few lines that do something simple (e.g. pascalcase, is-number, falsey) and then there's tons of scaffolding like CI/CD, ESLint configs, testing, benchmarks, a detailed readme, etc. that might give the impression that it's a more substantial library at first glance.\n\nIIRC Redux-Thunk is really just one asynchronous function that is barely more than 20 lines long",
            "points": "4 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Then there is this guy:\n\nhttps://github.com/samuelmarina/is-odd\n\nNo dependency, no magic trick hidden behind mysterious symbols. Plain simple packages.",
            "points": "7 points",
            "children": [
              {
                "comment": "",
                "points": "",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I got the impression (or maybe he actually said this somewhere, I forget) that he was trying to get into the industry in the early-mid 2010s and created this constellation of interconnected packages to get tons of NPM downloads to list on his resume.\n\nIt probably worked, too, the cheeky bastard.",
            "points": "6 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I gave up on Perl entirely because of this bullshit in CPAN (and a FEW OTHER ISSUES WITH THAT HORRIFIC FUCKSTAIN OF AN ALLEGED LANGUAGE) 25 years ago, and the JavaScript community is worse. I’ve never seen horrors of this magnitude in Python.",
            "points": "5 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I got the impression (or maybe he actually said this somewhere, I forget) that he was trying to get into the industry in the early-mid 2010s and created this constellation of interconnected packages to get tons of NPM downloads to list on his resume.\n\nI don't think this is a fair assessment at all. You have to realize that Javascript does not have a standard library. These are tools that are part of any other language and are missing from Javascript. Is it a bit absurd to pull in dependencies for something so simple? Yes, but people do it anyway, because JS is a deficient language.",
            "points": "1 point",
            "children": [
              {
                "comment": "",
                "points": "",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I use Ruby a lot, and `even?` and `odd?` are methods of the Integer class (number are objects!). I have used it a lot.\n\n​\n\nI get the point from the article, but you don't really need a super safe is-even method (at least not most of the time)",
        "points": "71 points",
        "children": [
          {
            "comment": "i only develop rails api-only projects at work, but since morphs were revealed for hotwire i've been really tempted to try it out.\n\ni see people calling Ruby a dead language all the time, so it's kinda nice seeing someone mentioning it in a positive way haha.\n\nit's a nice language for sure",
            "points": "24 points",
            "children": [
              {
                "comment": "Ruby definitely seems to have one of the best stdlibs out there. I wish it were more widely adopted past the 2010s",
                "points": "6 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "I still see new projects being made with Ruby. It's not close to the number of Python and NodeJS being used in new projects, but its still far away from being dead.",
                "points": "5 points",
                "children": [
                  {
                    "comment": "Yeah, it's the only thing we start new backend projects in at work. I know people say it's slow and the trendy thing is typed languages, but there are definitely a lot of things that help productivity in Rails.",
                    "points": "1 point",
                    "children": [
                      {
                        "comment": "I think Rails was specifically intended to help developer velocity? (Aka productivity)",
                        "points": "1 point",
                        "children": [
                          {
                            "comment": "Yeah it's definitely one of the main goals of the framework. It comes with most of what you need out of the box and even though people criticize it for being slow and having \"too much magic\" it does a good job imo.",
                            "points": "1 point",
                            "children": [
                              {
                                "comment": "A lot of magic in rails and while learning it irked the shit out of me.\n\nI now really appreciate the dx and how flexible ruby is",
                                "points": "0 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "I do miss types in Ruby. If had something like Pydantic on Python with FastAPI, then it would be perfect for me.",
                        "points": "0 points",
                        "children": [
                          {
                            "comment": "Shopify uses Sorbet for static typing. There’s another lib, Steep, that’s less popular.\n\nRuby 3.0 introduced RBS - new library that allows you to test types & integrates w/ other typing libs. But 3.0 remains dynamically typed.",
                            "points": "0 points",
                            "children": [
                              {
                                "comment": "Oh nice. Didn't know about that. If I work again with Ruby, I will use it",
                                "points": "0 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "We started in 2017 and use rails 🫡",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "I have used Laravel (php), Rails (ruby) and Django (python) all in different companies for at least 2 years each one.\n\nRails is by far superior to the others. I also have worked with the typical node+react stack.\n\nBy far, my best experience as a developer was developing tools using Rails + ERB + intercooler (which now was forked as htmx), this was before Turbo existed. My meatballGuy, please test turbo, the experience of dropping frontend code and making everything on the backend with Rails is so great.",
                "points": "2 points",
                "children": [
                  {
                    "comment": "I actually have plans to try out proper fullstack with Rails I just haven't gotten around to it, I tend to have too many things I wanna look into haha",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "I am using Django for most of my projects but have been following rails for a while. What do you think is the main benefit of rails Vs Django?",
                    "points": "2 points",
                    "children": [
                      {
                        "comment": "If you're using \"plain django\", Rails has a lot more features baked into the framework to build webapps as fast as possible.\n\nFor example, in Django you probably end up mixing all the recomendations from \"two scoops of django\" to build webapps, Rails already have all of that.\n\nIMO, django has been made to build API's, Rails on the other side is for every kind of apps, APIs, Webapps, microservices, whatever you want.\n\nI could talk a lot about how Rails is cooler, but to much text haha",
                        "points": "3 points",
                        "children": [
                          {
                            "comment": "My people",
                            "points": "0 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Ruby is nice. Rails and its community are a hostile garbage fire.",
                "points": "1 point",
                "children": [
                  {
                    "comment": "",
                    "points": "",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "",
                "points": "",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "The \"it's tested and battle hardened with a dedicated dev, unlike your own x % 2 == 0\" is a copout, so-called micropackages were a fad in the Javascript community and nothing more.\n\nThere was the argument that it meant reducing download size in comparison with downloading a larger utility library, if you only include the functions you use this way.\n\nSure bud, saving 2KB of string, collections and numeric functions, that could be cached on the client side if downloaded from a CDN and if there's no superfluous releases every day invalidating the cache, in your page with dozens of MB in assets.",
            "points": "22 points",
            "children": [
              {
                "comment": "I agree with your point - what do you mean by CDN caching?",
                "points": "2 points",
                "children": [
                  {
                    "comment": "If most websites download it from what's for the browser the same location, from a CDN network, the file would be cached in your browser for all of them; of course as long as the devs aren't clowns making a trillion releases to bulk up the commits log, lots of the shitty micropackages had long commit histories of minute, trivial changes spread out across as many commits as possible to show that they're lively projects from prolific open source developers.",
                    "points": "-1 points",
                    "children": [
                      {
                        "comment": "Beyond the shitty dev practices, sadly cross-resource caching has been killed by the platform itself.\n\nusers will redownload the resources no matter if they downloaded and cached them for other sites already.",
                        "points": "11 points",
                        "children": [
                          {
                            "comment": "Ah bugger, well efficiency is just not a thing here",
                            "points": "1 point",
                            "children": [
                              {
                                "comment": "",
                                "points": "",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I remember what a mess leftpad created. Whoever uses packages for such trivial things are introducing entropy in their code for no reason.",
        "points": "380 points",
        "children": [
          {
            "comment": "In my team, production code is restricted from using any third-party packages, except for major framework libraries and essential community plugins or de-facto standards. We don't permit the inclusion of randoms GitHub packages due to security and maintenance concerns. This policy has proven significantly beneficial for us in the long run and I recommend anyone to follow it. Just don't use 3rd party packages. Period.",
            "points": "217 points",
            "children": [
              {
                "comment": "I would be interested in hearing the criteria your team came up with for determining what is an “essential” community plugin",
                "points": "60 points",
                "children": [
                  {
                    "comment": "is-even, is-odd",
                    "points": "86 points",
                    "children": [
                      {
                        "comment": "is-essential-community-plugin",
                        "points": "10 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "or de-facto standards\n\nMy experience is that everyone thinks that whatever library they're used to is a \"de-facto standard\" or \"industry standard\"",
                "points": "32 points",
                "children": [
                  {
                    "comment": "If it comes with the compiler, then it’s standard. I’m only slightly joking.\n\nSeriously though, standard libraries don’t break user space in general. You expect the methods to work 10 years from now without you having to modify your code.",
                    "points": "7 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Yep. I wrote secure code for government customers for 15 years, then took a job in industry.\n\nThe difference is stunning.\n\nAt my previous job, every library was carefully vetted (by the government). At one company I've worked for since (that was trying to market to US DOD) I discovered that some of the libraries they were using were Russian.\n\nCan you imagine trying to get through RMF and get an ATO with Russian libs?",
                "points": "108 points",
                "children": [
                  {
                    "comment": "",
                    "points": "",
                    "children": [
                      {
                        "comment": "I have no clue what kind of idiots upvote you\n\nPeople who know what they're talking about. Literally no one in the government is using black boxed Russian software.",
                        "points": "4 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "Not every project is held to the same standards. A public-facing site is whatever. If it's a project in a secret-level network they're not pulling in packages from the internet without authorization.",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": true
                  },
                  {
                    "comment": "",
                    "points": "",
                    "children": [
                      {
                        "comment": "Sorry if I wasn't clear.\n\nThis Russian lib was being used by a place I worked where the libs clearly were not vetted - it was not used by the place that was vetting packages.\n\nDOD is very careful about the provenance of the hardware and software it uses. This is sometimes called \"supply chain security\".",
                        "points": "40 points",
                        "children": [
                          {
                            "comment": "",
                            "points": "",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "Let’s ignore the nationality for a moment. Most people take a look at a package and decide to use it or not. Even fewer actually read into the source code. Even fewer still go back during their upgrade cycle to review the codebase changes during that time. They just do “yarn upgrade” or what have you. A compromised library can easily have had its code updated between vetting and upgrading to become a security or licensing issue, and dependencies of your dependencies could be ways to hide malicious code. It’s actually really common.\n\nAnyway. Dependency management, security, and resolution is a very real concern. And the United States will even check if you, yourself, as an American have ties to certain countries. Friend of mine had to give up his Ukrainian passport just due to relationship to Russia at the time. Because family could be compromised and leveraged against him.\n\nSo, they don’t particularly care about your nationality per se they just see a relationship to it as a possible vector, even as an American. You’re not allowed to have an even questionable relationship to a non American ally.",
                        "points": "2 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "Never heard of ITAR? ITAR also covers technologies, including software, being sent to certain countries. Similarly, the US Government and many companies do not allow or restrict using software from Russia and China (and many other countries).\n\nTypically it is not recommended to install software developed in countries known to install Trojan horses, viruses, malware etc. Especially countries that are adversaries. Kind of surprised you had to ask.",
                        "points": "7 points",
                        "children": [
                          {
                            "comment": "",
                            "points": "",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "I'm sorry you're being downvoted for asking the obvious question.\n\nIf a library written by someone from the US (which is probably the country doing most of the illegal hacking around the world) is not a problem, why would the nationality of any other developer matter?\n\nWhat if it's a Russian guy living in the US? Or someone from the US living in Russia? Where to draw the line and why?",
                        "points": "-4 points",
                        "children": [
                          {
                            "comment": "What if it's a Russian guy living in the US?\n\nThe DoD also does not utilize software by random guys living in the US, so your question is moot.",
                            "points": "2 points",
                            "children": [
                              {
                                "comment": "So if the nationality of the person is not relevant... why discard specifically a russian guy?",
                                "points": "-1 points",
                                "children": [
                                  {
                                    "comment": "why discard specifically a russian guy?\n\nWell, the original statement was just that it was found that some of the libraries were Russian. The nationality of a supposed individual contributor to the library wasn't mentioned until the guy complaining about that statement - they brought the idea into the conversation out of nowhere in bad faith and then got mad about it. That's why they're getting downvoted: complaining about additional context they completely made up.\n\n\"Russian software\" = software made in Russia, not just anything someone who happens to ethnically Russian worked on at some point.",
                                    "points": "0 points",
                                    "children": [],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          },
                          {
                            "comment": "It's about alliances, like it or not, other countries do train spies who then attend a US college and get a US job, with the goal of writing defense SW, reporting vulnerabilities back to their home country, and writing new vulnerabilities into the SW.\n\nSo part of a security clearance is looking at where a person's alliances lay, who their friends and family are, etc. The DoD DOES require you to renounce your foreign citizenship as part of getting a job there. These lines are well defined. Depending on clearance level and how many checks are being done on it, they may reduce the requirements for some things to just US citizens only, etc.",
                            "points": "1 point",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": true
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "for major framework libraries and essential community plugins\n\nThe problem is that many of these libraries have dependencies on these micro libs. You might not use leftPad, but a dependency of a dependency of a dependency does.",
                "points": "5 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "Makes sense for sure. Probably slows a few things down though. Like something that could be done in a day now requires a week because you need to write it yourself?\n\nI get it though. Certainly not critical of this, I support it! My last place was cowboy coding all over the place and ridiculously insecure.",
                "points": "15 points",
                "children": [
                  {
                    "comment": "Also some things may be a security risk to write yourself. Some things are better to let an expert with 20 years of specialized experience write than someone who just found some cool idea online.",
                    "points": "7 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "I’d say writing everything is overkill, but at the very least, every developer should thoroughly vet their third-party libraries. You should be able to vet the publisher and see whether they can be held accountable if one of their libraries is malicious. At the very least, you should be able to call someone and scream at them. If a package is made by some nameless, faceless username and has 1,000 downloads and 1 contributor, it’s probably not safe.",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "We don't permit the inclusion of randoms GitHub packages due to security and maintenance concerns.\n\nWe just code review our dependencies. It's extra up-front work, but it lets us see what's going on. We keep a copy of the dependencies in the repository (just squash them when merging updated dependencies) so we know we always have a clean and safe copy. It may seam silly, but it's the only way to REALLY know what the dependencies code is doing. I haven't seen a better way to do it other than just blindly trusting that the code is safe.",
                "points": "9 points",
                "children": [
                  {
                    "comment": "Yeah, that's not silly, it's planning ahead. We do the same thing as best as possible.\n\nI was burned by one project that I would have never used had I previously read it's awful code. Ever since then, I code review everything that comes in. I often hear objections that it will be very time consuming but it's really not as low quality code usually jumps out very quickly.",
                    "points": "6 points",
                    "children": [
                      {
                        "comment": "I often hear objections that it will be very time consuming\n\nSame. Gets old explaining that it's only time consuming ONCE. It's not like we're throwing in new dependencies every single day, lol. Once the main bulk is reviewed it's just a matter of reviewing the diffs when we do update the dependencies.",
                        "points": "2 points",
                        "children": [
                          {
                            "comment": "Repetition is the soul of education.\n\nThat motto is how I stay sane repeating the same simple things over and over.\n\nAnd P.S. you’re more diligent than me if you’re reviewing updates. I mainly treat it as a high pass filter.\n\nI’ve also noticed a nice side benefit in that it incentivizes small, focused dependencies. No one wants to code review all of boost (for example) so they figure out a way to bring in only what they need.",
                            "points": "1 point",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "I haven't seen a better way to do it other than just blindly trusting that the code is safe.\n\nI interned at a place that used a proxy (Artifactory IIRC) with only pre-approved packages. No repository pollution, and you can use the same vetted packages across repositories.",
                    "points": "4 points",
                    "children": [
                      {
                        "comment": "We more or less do the same. The packages are kept in a separate repository and pulled in during build pipelines.",
                        "points": "1 point",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "So what happens if there is a requirement for a drag and drop library. There are already good solutions available and writing one from scratch is time consuming and resource wasting.",
                "points": "8 points",
                "children": [
                  {
                    "comment": "You would develop it yourself. It's a short term vs long term tradeoff. Many projects don't have the luxury of making the long term investment but if you can, having code that you understand and only solves your specific problem does lead to less complexity and a deeper understanding of the codebase overall.\n\nI've done both ways and it can be really nice that every problem is within your control. You end up spending more time problem solving and less time on overhead doing package / release / vendor management.",
                    "points": "2 points",
                    "children": [
                      {
                        "comment": "Good luck having enough developers to maintain a codebase where you've developed every widget yourself that's worse than open source alternatives.",
                        "points": "20 points",
                        "children": [
                          {
                            "comment": "Keeping dependencies up to date also requires maintenance, it often more maintenance for micro libraries with no strong backwards compatibility than code you write yourself.",
                            "points": "6 points",
                            "children": [],
                            "isDeleted": false
                          },
                          {
                            "comment": "It absolutely can be done and you don’t need that many people. It’s amazing what you can accomplish when you have full control over the libraries.\n\nYou only need to write the code once for most of the libraries. You can also target your specific application and not the general user.",
                            "points": "4 points",
                            "children": [
                              {
                                "comment": "How do you ensure your libraries are secure?",
                                "points": "-1 points",
                                "children": [
                                  {
                                    "comment": "same way you ensure any of your code is secure?",
                                    "points": "6 points",
                                    "children": [
                                      {
                                        "comment": "",
                                        "points": "",
                                        "children": [],
                                        "isDeleted": false
                                      }
                                    ],
                                    "isDeleted": false
                                  },
                                  {
                                    "comment": "You have your code audited. That's one of the main benefits of minimizing your dependencies: fewer sources of bugs. Your total code footprint will be much, much smaller and you have total control over when and if you upgrade.\n\nIt can't be done by an individual but if your organization has dedicated security resources, OSS generally make security's life harder, not easier.",
                                    "points": "3 points",
                                    "children": [],
                                    "isDeleted": false
                                  },
                                  {
                                    "comment": "How do you ensure third-party libraries are secure? 'Trust someone on the internet to ensure it' is the wrong answer, by the way.",
                                    "points": "2 points",
                                    "children": [],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          },
                          {
                            "comment": "It's usually better and always much less code than the open source alternatives because you don't have to generalize anything or worry about anyone's requirements but your own.\n\nThe open source glue approach is better most of the time but DIY is more viable than you think. OSS is not free either; dependencies are a huge source of maintenance overhead over time",
                            "points": "0 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Inpossible for Rust users",
                "points": "14 points",
                "children": [
                  {
                    "comment": "No idea about Rust, but I find it absolutely crazy how easy NodeJS community publishes and uses 3rd-party packages on anything. I've only seen this in node and nothing remotely similar on other platforms (Java, Python, etc). The culture is significantly different. To me, this is an anti-pattern and I've always been extreme at discouraging using random packages for no reason.",
                    "points": "41 points",
                    "children": [
                      {
                        "comment": "The mention of Rust is related to the fact that Rust's std lib is thin but deep - a lot of stuff is in the libraries, like everything related to JSON, HTTP, random number generation, logging, regex, etc etc etc, so the \"purist\" approach of never using 3rd party libs wouldn't work. But then again, you have to draw the lines depending on the situation so yeah",
                        "points": "20 points",
                        "children": [
                          {
                            "comment": "I would think the \"de-facto standards\" bit would cover most of the things in question here",
                            "points": "17 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "Right. I started following a tutorial to create basically a single page CRUD app and I had to install like 9GB of dependencies from NPM. Like, it is ridiculous.",
                        "points": "4 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "Easy(ish) enough to develop an allow list for the usual suspects (tokio, serde)",
                    "points": "6 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "Luckily 90% of crates are total crap so even if you find one that looks like it does what you need, it probably doesn't.",
                    "points": "10 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "This is my biggest gripe with rust tbh\n\nJust feels bad to be doing low-ish level stuff and be almost forced to use 200+ dependencies.\n\n(admittedly I am also much more productive than I would be in c, but with the c i'd know it will compile in 20 years no problem, in rust I am glad if a minor version update doesn't require some adjustments twice a year)",
                    "points": "8 points",
                    "children": [
                      {
                        "comment": "",
                        "points": "",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "Is there no way to self host a locally selected set of validated crates?",
                    "points": "1 point",
                    "children": [
                      {
                        "comment": "There definitely is. You can download the crate and overrides it with path in your Cargo config. However, you can also just rely on the Cargo.lock to ensure packages don't change their code since you've reviewed it.",
                        "points": "2 points",
                        "children": [
                          {
                            "comment": "",
                            "points": "",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Just don't use 3rd party packages. Period.\n\nexcept for major framework libraries and essential community plugins or de-facto standards\n\nWhat is your criteria for what is allowed or not? Do you keep an \"allow list\"?\n\nCan you describe your process for vetting a 3rd party package, i.e. Is it a Tech Lead job or done by committee or is it all automated?",
                "points": "5 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "That sort or responsible programming use to be common practice. It is only the really ignorant behavior of a lot of web programmers that changed this, with maybe the release early and often crowd. In the past nobody in their right mind would build a production app around version 0.2 libs.\n\nI actually don't see releasing early as a problem as long as everybody understands that it is an early release and the details of what is included is clearly known. This isn't what we are seeing especially with web programming these days.",
                "points": "5 points",
                "children": [
                  {
                    "comment": "It is only the really ignorant behavior of a lot of web programmers that changed this\n\nYou mean it was impossible before because linking headers or external resources in C/C++ was a nightmare. Technology advanced. Sharing code is better.",
                    "points": "10 points",
                    "children": [
                      {
                        "comment": "Sharing stable well tested code is better. My problem is the wide use of libs that barely work or are not even out of Alpha, based on what their own developers consider for code status. Beyond that using quality C++ libs is not that difficult.\n\nAs for technology advancing, that is one reason I like Python so much, lots of innovation there. However I will still avoid alpha and beta quality software.",
                        "points": "2 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "I avoid introducing packages for anything that is trivial, so I too prefer avoiding 3rd party packages. This gives me more control over the implementation, and the code is often simpler than something that tries to cater to everyone's needs at the same time. Still, you mentioned security, so I'm curious about this hypothetical issue.\n\nIt's often said that open-source is reviewed by many eyes. I suspect most people would be like \"eh, it was already reviewed by somebody\", but that somebody luckily still exists, as evidenced by tons of libraries being regularly reported in all those dependency version scan tools (checkmarx, snyk etc). The security reports come from security experts or hackers, who search for vulnerabilities as their daily job. An in-house feature would not get looked upon by those experts.\n\nDid you have such experts amongst the people screening your packages? Did the same people also review your own code for vulnerabilities? I mean, our own code would certainly require such an inspection, if we decide to re-implement something that was already implemented and inspected somewhere else. How high is the risk for a team to follow the advice of avoiding 3rd party libraries, if they don't have such experts?",
                "points": "0 points",
                "children": [
                  {
                    "comment": "and the code is often simpler than something that tries to cater to everyone’s needs at the same time\n\nAnd likely ignores the bugs and edge cases and tests that were already accounted for in the 3rd party package.",
                    "points": "1 point",
                    "children": [
                      {
                        "comment": "",
                        "points": "",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "How's this enforced?",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "except for major framework libraries and essential community plugins or de-facto standards\n\n...\n\nJust don't use 3rd party packages. Period.\n\nBut you said you use 3rd party packages.",
                "points": "-1 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "",
                "points": "",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Plus it’s not secure. There’s this article about malicious packages that try to look like real, popular packages to try to gain admin privileges on a developer’s system. The more dependencies a project has, the more of a risk that the devs accidentally left some useless or malicious package in there. Sure, you can usually inspect the source but WILL you?",
            "points": "21 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I remember what a mess leftpad created\n\nWe got hit by it. Was a busy.. afternoon? Then YEARS of blog posts on how the ecosystem of JavaScript is broken and npm sucks! Hilarious.",
            "points": "9 points",
            "children": [
              {
                "comment": "",
                "points": "",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "NPM is the mess.",
            "points": "4 points",
            "children": [
              {
                "comment": "The anemic Javascript standard library is one cause, the amateurishness of Javascript devs is another, there's no reason to build your company's or client's software as if the tens to hundreds of dollars of investment it represents won't be used form more than a month.",
                "points": "18 points",
                "children": [
                  {
                    "comment": "All correct. NPM is:\n\nOne part \"package\" \"manager\" (for very loose definitions of both)\nOne part languages fixes\nOne part code snippet landfill\n\nExactly what JS deserves.",
                    "points": "11 points",
                    "children": [
                      {
                        "comment": "Can you explain why it is \"package\" \"manager\"",
                        "points": "1 point",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "",
                        "points": "",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I remember what a mess leftpad created. Whoever uses packages for such trivial things are introducing entropy in their code for no reason.\n\nLeftpad wasn't trivial. It was there to make up for a deficiency in the language. Stop blaming users for the failings of the language.",
            "points": "-1 points",
            "children": [
              {
                "comment": "Respectfully disagree. Padding functions are very trivial for anyone programming longer than a couple weeks at most.\n\nI get your point about JavaScript not having a proper standard library, but one should be using something like lodash or underscore for that - both of which were popular at that time. Using a different package for every single function is asking for trouble - which was evident by that fiasco. It just adds more points of npm version related failures.",
                "points": "1 point",
                "children": [
                  {
                    "comment": "",
                    "points": "",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "You don't think a simple 11 line function is trivial?",
                "points": "1 point",
                "children": [
                  {
                    "comment": "Most functions are small. Suppose all your functions are under 11 lines. I guess the whole software is trivial and you don't deserve money for your work?",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "When the entire package is just that one function, yeah, that's trivial.",
                        "points": "-1 points",
                        "children": [
                          {
                            "comment": "",
                            "points": "",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Bro what. Left pad should be trivial for anyone who has been programming for longer than a month. Also the implementation of the package was ass too",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "",
            "points": "",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Writing it yourself is faster than opening the terminal, running npm install and importing the package.",
        "points": "141 points",
        "children": [
          {
            "comment": "Only if you know how to write it yourself.",
            "points": "50 points",
            "children": [
              {
                "comment": "that is true but if you don’t know how to write a percent sign there are bigger issues at hand",
                "points": "90 points",
                "children": [
                  {
                    "comment": "You’d be surprised the people I’ve talked with that don’t know what modulo is.",
                    "points": "34 points",
                    "children": [
                      {
                        "comment": "don’t know what modulo is.\n\nWeren't they in Motown?",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "There's actually type checks in it too",
                    "points": "6 points",
                    "children": [
                      {
                        "comment": "But are those necessary in real code? You really shouldn’t be asking if a value is odd before knowing it’s a number. Better yet, use typescript.",
                        "points": "26 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "Read the article, it does more than use a percent sign.\n\nThis is the reason these libraries exist. There are non-obvious issues with seemingly extremely simple tasks. And when your language is JavaScript, even more so.",
                    "points": "12 points",
                    "children": [
                      {
                        "comment": "This is the reason these libraries exist\n\nPeople like to say this often, but it's really not \"why they exist.\" It's post-facto rationalization that people use for why we shouldn't immediately delete these barnacles on the ecosystem.",
                        "points": "6 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "it does but in the majority of cases those things are not things you need",
                        "points": "4 points",
                        "children": [
                          {
                            "comment": "But you don't know what the edge cases are and if they're important to you or not, until you carefully examine the seemingly simple problem. And someone else has already done the careful examination for you, in fact a whole ecosystem of programmers who can submit pull requests.",
                            "points": "7 points",
                            "children": [
                              {
                                "comment": "Most of the edge cases obscure bugs elsewhere in the code, what should be an error is \"handled gracefully\".",
                                "points": "2 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "",
                        "points": "",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "I would hope you’re using a bitwise operation, not a division operation.",
                    "points": "-17 points",
                    "children": [
                      {
                        "comment": "i got bad news for you",
                        "points": "17 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "🙄\n\nThe difference between the two will never matter for most people.",
                        "points": "15 points",
                        "children": [
                          {
                            "comment": "Yeah... Pretty sure this is the lowest level of concern when it comes to optimizing JS.",
                            "points": "15 points",
                            "children": [],
                            "isDeleted": false
                          },
                          {
                            "comment": "",
                            "points": "",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "I challenge you to show me a programming language where you divide by 2 (or modulus 2) and at the end of the line it doesn't instruct the CPU to do a bitwise operation.",
                        "points": "4 points",
                        "children": [
                          {
                            "comment": "It’s great that optimizing compilers can fix this, but why not just write it correctly from the start?",
                            "points": "0 points",
                            "children": [
                              {
                                "comment": "",
                                "points": "",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "If you're doing something where any improvement of the bitwise version might realistically become important your compiler is essentially guaranteed to do the conversion for you - and if you're writing the kind of stuff where you actually need this kind of speed in a language where you can't expect the optimization you're probably already doing something very wrong.\n\nI just timed it out of interest: even in something like python it's a sub-nanosecond gain (that is: if you implement it correctly. A naive implementation is actually quite a bit slower than the ordinary modulo version). A single call to a function that takes no arguments and does nothing in python costs about 250 times as much as the optimization gains.",
                        "points": "9 points",
                        "children": [
                          {
                            "comment": "",
                            "points": "",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Um if you can't write is-even good luck with the 'application' you're writing.",
                "points": "2 points",
                "children": [
                  {
                    "comment": "Yet somehow they get hired.",
                    "points": "3 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Even Github Copilot could help you write it.",
                "points": "-4 points",
                "children": [
                  {
                    "comment": "Github copilot.\n\nI don't understand the downvotes tho, its the perfect tool for this use case.",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "The suggestion that a developer could compensate for ignorance by leaning on AI enrages people.",
                        "points": "2 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "",
                "points": "",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "except that most people didn't intentionally import that junk. got imported by some other library, probably 10 levels deep in the stack.\n\nThat time was an idiotic period in the JS-world (web frontend in general). I left that world about 7 years now and I don't miss it at all.\n\nNot that C++ doesn't give me gray hair ... haha.",
            "points": "6 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "And as a lot of the comments in this thread show, many people aren't able to do so correctly. Including some who are adamant that it is such a trivial problem that only an idiot would use a library for it.\n\nCould I write it myself? Sure. Would I be 100% sure that I've hit all the weird edge cases in the language I'm using? Eventually, after a bit of thought, I could get to that level of confidence. Or I could just use a method someone else has already put the thought into and move on with my day.\n\nI've never had cause to use something like isOdd(), but I do use utility functions of similar degrees of triviality if only because a nicely named function makes for more readable code.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Funny thing is that the additional checks “check n is positive” perform unexpected behavior imo because negative numbers also can be even or odd",
        "points": "44 points",
        "children": [
          {
            "comment": "I'm not really sure why OP added that. The actual package does Math.abs(n).",
            "points": "39 points",
            "children": [
              {
                "comment": "OP here. Thanks for reading and pointing that out! I guess in my head I translated the abs into \"ensuring\" that the value that the modulo is performed on is positive and miswrote that.\n\nI'll fix it for future readers",
                "points": "11 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "It doesn't check if it's negative. It just does abs.",
            "points": "7 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "If you really want a laugh https://github.com/jezen/is-thirteen",
        "points": "60 points",
        "children": [
          {
            "comment": "korean and polish broke me",
            "points": "4 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "downloaded forked by Drake, Epstein, and a tonne of downloads from the vatican?",
            "points": "21 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Heavily utilized by Twitch, I imagine.",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "This essential dependency holds the world together.",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "",
            "points": "",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "So... If it first checks that the argument is positive, that means that it gives the wrong result for negative and zero values?",
        "points": "10 points",
        "children": [
          {
            "comment": "Not quite.\n\nIt doesn't return an error or anything if the number is negative, it just takes the absolute value, which provides a couple benefits. \"n % 2\" will return -1 for an odd negative number, so you need to handle negatives somehow. Taking the absolute value at the beginning also has the benefit of converting string inputs into a number format, which lets you do the isInteger() check.",
            "points": "7 points",
            "children": [
              {
                "comment": "Java at least used to throw a warning at you if you tested with n % 2 and said it's just faster and safer to do n & 1 but I don't know if that would work in JavaScript",
                "points": "-1 points",
                "children": [
                  {
                    "comment": "",
                    "points": "",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Nah, it does Math.abs(x) I think the article writer just flubbed the explanation.",
            "points": "6 points",
            "children": [
              {
                "comment": "",
                "points": "",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Disappointed. Was waiting to see a major framework or popular package use it ...\n\nNext research/excursion should be to find out how many dependencies this major/popular things have edit and if they are \"externally\" controlled ...\n\nEdit had to get this on. From socket.dev the dependencies:\n\nJs: - React - 3 dependencies - Vue - 20 - Angular Core - 3 - Express - 60 - Async - 0 - Mocha - 54\n\nPy: - Django - 2 - requests - 0 - numpy - 0\n\nJava: - JUnit - 1 which has 0 maintainers - SLF4J logging api - 0 - Kotlin Stdlib - 0 - Scala-library - 0\n\nGo: - Logrus - 3 - aws-sdk-go - 4 all which are AWS maintained - testify - 4",
        "points": "9 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "https://www.npmjs.com/package/is-even has a link to the repository https://github.com/jonschlinkert/is-even\n\nBut that user changed their name and now the repo links to https://github.com/i-voted-for-trump/is-even\n\nSame applies to https://www.npmjs.com/package/is-odd",
        "points": "8 points",
        "children": [
          {
            "comment": "Yet another reason not to use the packages",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "You don't need a package for is-even or is-odd, the most senior developer thing to do is spin up an LLM (local or cloud) and ask it if the number is even or odd.",
        "points": "7 points",
        "children": [
          {
            "comment": "",
            "points": "",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I don't use those, I only use the quickest is-prime algorithm out there",
        "points": "9 points",
        "children": [
          {
            "comment": "Oh my god, lol'd",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Wannabe pros use % 2\n\nReal pros use & 1",
        "points": "8 points",
        "children": [
          {
            "comment": "sorry but that's unreadable. try this:\n\nfor (;;) { if (num == 0) return true; if (num == 1) return false; num = num - 2 } ᶦ ᵈᵒⁿ'ᵗ ᵇᵉˡᶦᵉᵛᵉ ᶦⁿ ⁿᵉᵍᵃᵗᶦᵛᵉ ⁿᵘᵐᵇᵉʳˢ",
            "points": "6 points",
            "children": [
              {
                "comment": "Mutability is an anti-pattern. Prefer a more functional approach: function isEven(num) { return (num == 0) || (num != 1 && isEven(num-2)) }",
                "points": "12 points",
                "children": [
                  {
                    "comment": "sorry but that's just blown up my stack. here's an improvement:\n\nboolean isEven = true; for (int i = 0; i < INT_MAX, i++) { if (i == num) return isEven; isEven = !isEven; }",
                    "points": "6 points",
                    "children": [
                      {
                        "comment": "I was going to correct you that the above functional approach does a tail call after short-circuiting, so there is no stack overflow, but instead my mind is boggled by the fact that JS apparently still doesn't have tail call elimination. Amazing.",
                        "points": "5 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "You call that readable? I prefer this:\n\nif(num == 0) return true;\nif(num == 1) return false;\nif(num == 2) return true;\n...\nif(num == 254) return true;\nif(num == 255) return false;\n\n\nNumbers that don't fit into unsigned 8 bit values don't exist.",
                "points": "9 points",
                "children": [
                  {
                    "comment": "i can't argue with the line count. truly you are the most senior engineer",
                    "points": "4 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I didn't look at the code, but I hope at least one of these is a dependency of the other.\n\nI might consider using them if we didn't already have our own is-even microservice that has 5 9s of availability!",
        "points": "2 points",
        "children": [
          {
            "comment": "Author here! Thanks for reading. And yes. Yes it is. is-even depends on is-odd and does !isOdd",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Why use packages when determining odd or even is trivially easy using the modulo operator. There are plenty of reasons for using packages or modules in your code. This is not one of them.",
        "points": "5 points",
        "children": [
          {
            "comment": "Not that I'm defending this craziness, but it's JS we're talking about, so modulo is one thing but then you hit stuff like undefined, none, objects, floats etc, and it turns out if you want to actually implement this to be 100% correct it's not as trivial as it might seem",
            "points": "7 points",
            "children": [
              {
                "comment": "Very much this. Javascript is notoriously quirky. I'd prefer to rely on a library written by someone experienced, who knows all these edge cases and properly handles them.",
                "points": "2 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "I guess I’ve never had to determine evenness in JS. I will investigate further.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I use it on projects where I feel like I need to pad-out the node_modules directory, or at least there isn't enough risk of (insert developer name here) injecting some malicious code in my dependency tree.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "bool istrue(bool value) {\n  if (value==true) {\n    return true;\n  } else if (value==false) {\n    return false;\n  }\n}",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I’ve written on-orbit patch scripts, orbital sequence procedures and overrides for satellites. I’ve had to hand these scripts off to test engineers, systems engineers, satellite operators, even university folk and program managers that have provisioned one of our satellites our/or ground control software.\n\nIn the majority of these situations they did not have a high level understanding of coding nor the API framework used when writing these types of procedures. I’ve used these types of methods and other similar methods in both Ruby, Python and Rust (when I was writing these scripts) to communicate more clearly of what the script does.\n\nThat said, I get the point that is being made in the article. Understandable and I can relate to their frustration.",
        "points": "3 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Too many dependencies is a code smell, change my mind",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I love the idea of introducing all that cruft to basically do (x % 1) or !(x % 1) 🤣",
        "points": "-1 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "No games programmer should be, at the very least.\n\nIt's drilled into many to use i % 2 == 1 (or an even more succinct version depending on the language) long before something like is-odd is conceived.",
        "points": "-2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "",
        "points": "",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19919fx",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.youtube.com/watch?v=b8AOyY9KfBw",
    "title": "PyCharm Community versus Visual Studio Code for Python development tutorial",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19918xr",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.phoronix.com/news/CPP-Linux-Kernel-2024-Discuss",
    "title": "A 2024 Discussion Whether To Convert The Linux Kernel From C To Modern C++",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19918r6",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://aus.social/@zanchey/111760402786767224",
    "title": "Almost all of fish shell has been rewritten in rust",
    "points": null,
    "comments": [
      {
        "comment": "Will they rename to crab-shell now?",
        "points": "150 points",
        "children": [
          {
            "comment": "Crab evolution strikes again",
            "points": "45 points",
            "children": [
              {
                "comment": "For today's lucky 10 000 - https://en.wikipedia.org/wiki/Carcinisation",
                "points": "9 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "crab-fish-shell",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Here's the why\n\nhttps://github.com/fish-shell/fish-shell/blob/master/doc_internal/fish-riir-plan.md",
        "points": "78 points",
        "children": [
          {
            "comment": "That doc was initially committed on Feb 2, 2023, with a timeline of \"Handwaving, 6 months?\". Not too bad",
            "points": "83 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Why Port\n\nGain access to more contributors and enable easier contributions. C++ is becoming a legacy language.\n\nFree us from the annoyances of C++/CMake, and old toolchains.\n\nEnsure fish continues to be perceived as modern and relevant.\n\nUnlock concurrent mode (see below).\n\nWhy Rust\n\nRust is a systems programming language with broad platform support, a large community, and a relatively high probability of still being relevant in a decade.\n\nRust has a unique strength in its thread safety features, which is the missing piece to enable concurrent mode - see below.\n\nOther languages considered:\n\nJava, Python and the scripting family are ruled out for startup latency and memory usage reasons.\n\nGo would be an awkward fit. fork is quite the problem in Go.\n\nOther system languages (D, Nim, Zig...) are too niche: fewer contributors, higher risk of the language becoming irrelevant.\n\nRisks\n\nLarge amount of work with possible introduction of new bugs.\n\nLong period of complicated builds.\n\nExisting contributors will have to learn Rust.\n\nAs of yet unknown compatibility story for Tier 2+ platforms (Cygwin, etc).",
            "points": "63 points",
            "children": [
              {
                "comment": "C++ is becoming a legacy language\n\nThis is far from the truth. C++ is very popular in high-performance applications, and said applications do not care about memory safety enough to switch to another language. The language constantly receives updates and evolves. TIOBE named C++ as the language of the year in 2022 due to its recent growth",
                "points": "44 points",
                "children": [
                  {
                    "comment": "Legacy language as in higher and higher percentage of people either refuse to use it or just straight up don’t know how to use it. Not legacy as in nobody needs it anymore. And it’s clear that C++ has lost popularity compared to 10, 20 years ago. I’d say it counts.",
                    "points": "74 points",
                    "children": [
                      {
                        "comment": "I don't think it will be in the same spot as other legacy languages. It will probably be mainly used in gaming, fintech and HPC since these are the industries that do not care about memory safety as much.",
                        "points": "-5 points",
                        "children": [
                          {
                            "comment": "“fintech”\n\n“do not care about memory safety”\n\nLord help us.",
                            "points": "34 points",
                            "children": [
                              {
                                "comment": "Let me provide a more complete quote for you since you trimmed it off early:\n\nfintech ... these are the industries that do not care about memory safety as much\n\n​\n\nYes this is correct for certain subsets of fintech, like HFT (high frequency trading), where performance is the number one concern which happens to be dominated by C++ at the moment. Most areas in fintech really care about memory safety. I used the term \"as much\" in an attempt to convey it isn't as strict on an industry level. The medical and automotive industries are both examples of industries that are very strict about memory safety. Sorry for the confusion and I hope this explains my original message. ^-^",
                                "points": "7 points",
                                "children": [
                                  {
                                    "comment": "automotive industries are [...] are very strict about memory safety\n\nToyota wishes to enter the chat.",
                                    "points": "2 points",
                                    "children": [],
                                    "isDeleted": false
                                  },
                                  {
                                    "comment": "Fwiw we use C++ in medical. In fact we recently decided to port more code to C++.",
                                    "points": "0 points",
                                    "children": [],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          },
                          {
                            "comment": "that do not care about memory safety as much.\n\nMemory safety is pretty well solved in c++ (smart pointers and writing classes which check reads and writes are in bounds).\n\nThread safety is still not fully solved in c++, but from the majority of people in a c++ industry who have tried rust, the complaint is that it is too constraining.",
                            "points": "1 point",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "Fortran is very popular in high performance applications, and a very powerful modern language that grows every year too, but most people would still call it a legacy language. Such will be the case with C++.",
                    "points": "66 points",
                    "children": [
                      {
                        "comment": "Yeah I totally agree with you. It seems languages are starting to become more specialized and each field will have a \"dominate\" language. I think C++ will still dominate the gaming industry, fintech and HPC for a long time.",
                        "points": "4 points",
                        "children": [
                          {
                            "comment": "I honestly don't think so. Having used both Rust and C++ for high performance stuff (numerics, simulations) Rust is so much more productive and nice to work with and it doesn't take a ton to make it more generally viable for HPC. I think as time goes on and the ecosystem grows it'll see way more use and seriously compete with C++ (or we'll see a new language beating both out)",
                            "points": "1 point",
                            "children": [],
                            "isDeleted": false
                          },
                          {
                            "comment": "Like COBOL for banks.",
                            "points": "1 point",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "Legacy doesn’t mean it isn’t popular. Things will exist in C++ probably forever. New stuff is more likely to be written in rust.",
                    "points": "13 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "I’ve never heard of TIOBE but they also had “assembly language” in their top ten last year 🤔",
                    "points": "5 points",
                    "children": [
                      {
                        "comment": "Their methodology is to search +<language> programming and count the results https://www.tiobe.com/tiobe-index/programminglanguages_definition/\n\nThis is why it's a useless metric.",
                        "points": "5 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "TIOBE isn’t very credible, see https://blog.nindalf.com/posts/stop-citing-tiobe/. To quote some of the more extreme reasons:\n\nTo put that absurdity in context, Visual Basic is more than twice as large as Swift (1.27%) and Objective-C (0.94%) combined. The entire iOS, iPadOS, watchOS, macOS ecosystem is apparently half the size of the mighty Visual Basic ecosystem.\nSadly, the market for Logo (#48) programming seems way down. Back in it's heyday, it was as high as #21 on TIOBE. This is the programming language that involves moving turtles across the screen.",
                    "points": "4 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "Down-voted for quoting TIOBE which is a disease that needs to disappear from everyone's mouth and typing fingers.",
                    "points": "15 points",
                    "children": [
                      {
                        "comment": "I think it has some merit, but yes I agree it has problems like everything else.\n\n​\n\n> a disease that needs to disappear from everyone's mouth and typing fingers\n\nThis seems like an overreaction.",
                        "points": "-8 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "Remember: C++ is legacy, but x86 is modern",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "How is x86 modern? It's super legacy",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "++ is becoming a legacy language.\n\nI am working in the EDA field, and I can tell you that C++ is anything but legacy. Especially nowadays with C++ 17/20..",
                "points": "2 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "I wonder what old toolchains they think they are getting rid of. Are they saying they’re only going to support the latest release of rustc?\n\nThey know that qualification of rustc in ferrocene is going to make that version a defacto standard, right? It turns out adoption means having standards and release support cycles that businesses can use. Their legacy code is just getting started.",
                "points": "0 points",
                "children": [
                  {
                    "comment": "I wonder what old toolchains they think they are getting rid of.\n\nThe README says you need Rust 1.67.0 or later. I don't see any record of why that version was chosen, though.\n\nThey know that qualification of rustc in ferrocene is going to make that version a defacto standard, right?\n\nThe qualification has already happened, and I don't see any standardization on it. Broadly speaking, the community is past 1.68.0, though of course fish is lower than that!",
                    "points": "2 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "There are plans to make c++ a memory safe language. The tooling around c++ also is going to improve soon. These people are then going to regret switching to rust.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "Since when C++ becomes legacy language ? I doubt the people who said this even use unique_ptr in their code base.",
                "points": "-5 points",
                "children": [
                  {
                    "comment": "I doubt the people who said this even use unique_ptr in their code base.\n\nGiven that it is open source, you can check this yourself:\n\n> git clone https://github.com/fish-shell/fish-shell\n> cd fish-shell\n> git checkout 3.7.0 # last release, master has rust, this has c++\n> rg \"unique_ptr\" --stats\n<bunch of output>\n111 matches\n109 matched lines\n25 files contained matches\n1867 files searched\n\n\nThey indeed did use unique_ptr.",
                    "points": "17 points",
                    "children": [
                      {
                        "comment": "TIL: rg --stats, very nice! Used to | wc before...",
                        "points": "1 point",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "Yeah, please also check the usage on new and delete operators.\n\nAnyway, my point is I don’t think there are much incentives to rewrite anything in Rust as C++ already provides the tools I need. I actually don’t know how many of “them” (including the actual C++ developers) think “C++ already becomes a legacy programming”.",
                        "points": "-8 points",
                        "children": [
                          {
                            "comment": "I actually don’t know how many of “them” (including the actual C++ developers)\n\nThe people doing this are the team that was writing the C++.",
                            "points": "8 points",
                            "children": [
                              {
                                "comment": "Guess it's a good team where everyone has the same opinion.",
                                "points": "-6 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          },
                          {
                            "comment": "Coming from C++ the borrow checker isn't fancy to you?\n\nI can see the logic that Rust makes the wrong trade offs in complexity (C++ template errors are the worst but they are much easier to write than Rust generics), or that the library ecosystem isn't big enough, or that C++ FFI isn't where it needs to be.\n\nBut I don't get \"C++ has everything\".\n\nI love having a GC but sometimes can't afford it, we always give up things.",
                            "points": "1 point",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "will arrays in fish start from 0 now?",
        "points": "27 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Wake me up when Make, CMake and company are gone and it's just Rust build-scripts. Honestly, that is one of the main reasons why I like Rust more, it comes with a package manager and a build system so it can all \"just work\".",
        "points": "18 points",
        "children": [
          {
            "comment": "They're using cargo for the build, they're keeping cmake around for some scripting tasks only.",
            "points": "30 points",
            "children": [
              {
                "comment": "Gotta drop cmake for make",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Will they rewrite everything again in Zig in few years?",
        "points": "14 points",
        "children": [
          {
            "comment": "C# on dotnet. And then INTERCAL.",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Sweet now I can be cool without changing my shell",
        "points": "5 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "This fits all my preconcepted stereotypes of both fish and rust enjoyers",
        "points": "-56 points",
        "children": [
          {
            "comment": "Cool",
            "points": "17 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Careful in place migration with exact feature parity (including bug mirroring) and without attempting to remodel the problem domain in the new language?\n\nHonestly it seems the opposite of what everyone complains that Rust users do. (Aka just rewrite it in Rust using the correct Rust methodology and the newest features)",
            "points": "6 points",
            "children": [
              {
                "comment": "Yeah I was actually rather impressed by the level of consideration here. It actually makes perfect sense why they needed to change and how they did it; it's just a bit tongue in cheek but it looks like the tone was misread somewhat.",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "[deleted]",
        "points": "1 point",
        "children": [
          {
            "comment": "Probably involves paying more people to do it over a longer period of time.",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "And it’s 10,000 lines larger and still mot thread safe 😂",
        "points": "-6 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Who's naming these things? What are we going to be programming in in twenty years",
        "points": "-11 points",
        "children": [
          {
            "comment": "Bash is the same pun and was made in 1989. (Two characters followed by sh aka shell)",
            "points": "4 points",
            "children": [
              {
                "comment": "And fish even names itself “friendly interactive shell”",
                "points": "2 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_19918pi",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://inconvergent.net/2024/lisp-query-notation/",
    "title": "Lisp Query Notation",
    "points": null,
    "comments": [
      {
        "comment": "I'd really suggest dropping the keywords as strings idea, it's really confusing. For keys it's fine but even there I'd prefer unevaluated/uninterned symbols for the sake of clarity.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_199188f",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://github.com/kparc/ksimple",
    "title": "Bare minimum atw-style K interpreter for learning purposes",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19916e2",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://queue.acm.org/detail.cfm?id=3639445",
    "title": "How to Design an ISA",
    "points": null,
    "comments": [
      {
        "comment": "A good example showing the tension of being experienced vs. being old.\n\nOr, as a friend said: \"RiscV is the perfect ISA for the kind of CPUs we stopped building 30 years ago.\"",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_199161b",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://github.com/kffl/speedbump",
    "title": "Speedbump – a TCP proxy to simulate variable network latency",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19915am",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://timkellogg.me/blog/2024/01/17/htmx",
    "title": "Htmx Is Composable?",
    "points": null,
    "comments": [
      {
        "comment": "Good read, but you really need to give the solution explanation and exploration the same detail and examples you gave the original problems. From reading the ending I still don't know what this composition with HTMX is that you mentioned. Can you give code examples of what HTMX as configuration is?",
        "points": "4 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I need someone to help me out understanding htmx because it doesn't make too much sense to me.\n\nAs far as I understand, hateoas was mostly a way to navigate and modify state on the server.\n\nBasically, the app was the whole website i.e. A server owned aplication.\n\nNow with htmx, if I understand, the same hypertext is used to modify state on the client in a more granular way to eschew the usage of javascript?\n\nSo we prefer communicating with the server for every little change on the client even if it's not at the granularity of a page change?\n\nMy hunch is that it will be tremendously wasteful for a big app but I might be wrong.\n\nNow, that being said, does it mean that I need to bui'd a specific endpoint on the server for every change that might occur on the page? For instance, if clicking a button replaces the content of a div with some server fetched html, I need a specific endpoint for that? Repeat on every page?\n\nOr is htmx somewhat clever enough? (honestly asking because I'm genuinely interested but my brain just shut down when it seemed that I'd have to remember a handful of new attributes and how they compose).\n\nMake me a believer 😄",
        "points": "1 point",
        "children": [
          {
            "comment": "It depends on what you're trying to accomplish, but for me it gets rid of needing any kind of massive application framework. My state lives on the server and my server serves HTML. That's pretty much it. HTMX doesn't need to know the state of JS. So when someone goes to a new page I can hydrate the page using HTMX from simple HTML server responses. There's nothing more I need to do from there. It's blazing fast because nobody has to download MBs and MBs of JS. I don't have to worry about ShadowDOM. I don't have to worry about client server state parity.\n\nIt's not going to be a solution for everything, but with AlpineJS (Hyperscript is an alternative here) + HTMX I haven't touched React/Vue in awhile now. Some of the perks of React with Node is JS on the server and JS on the client, but my argument here is what if we just have.. HTML.",
            "points": "4 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "In short, what htmx is trying to accomplish is removing the complexity of local state, and keeping that in sync with the server (because, the server is always right, and the client is only sometimes right, when it comes to the state of the server). The idea is to remove that entire world of issues related to local state.\n\nAt least, that's the part that intrigued me about it. It also simplifies API design by making the HTML into the API (kind of). It also has a few other nice things.\n\nNow, that being said, does it mean that I need to bui'd a specific endpoint on the server for every change that might occur on the page? For instance, if clicking a button replaces the content of a div with some server fetched html, I need a specific endpoint for that?\n\nYes, but that's kind of the same already though, right? If replacing the content requires some data from the server - which your example makes it seem - then you have to call the server anyways.\n\nAll this said, I'm by no means a master of HTMX, I've only used it for a few test projects, but what I've seen is very promising.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_199159v",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://status.kagi.com/issues/2024-01-12-kagi-down-on-some-regions/",
    "title": "Post-mortem for last week's incident at Kagi",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_19914h0",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://blog.senx.io/demystifying-the-use-of-the-parquet-file-format-for-time-series/",
    "title": "Demystifying the use of Parquet for time series",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_199148a",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://mastodon.me.uk/@bbcmicrobot/111762132859648345",
    "title": "BBC BASIC raytracer in 432 characters",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1991372",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://willowprotocol.org/",
    "title": "Willow Protocol is a protocol for peer-to-peer data stores",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_1990u8t",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://github.com/merwin-asm/April",
    "title": "GitHub - merwin-asm/april: A programming language for making APIs",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_198s7d5",
    "subreddit": "u/HeroWarsDominionEra",
    "dataType": "link",
    "dataUrl": "https://www.hero-wars.com/?delayedsignup=true&nx_source=adx_reddit.{{AD_NAME}}&cp=-.ag-{{ADGROUP_NAME}}.agid-{{ADGROUP_ID}}.aid-{{AD_ID}}.cid-{{CAMPAIGN_ID}}.post-{{POST_ID}}.rdt_click-{{CLICK_ID}}",
    "title": "Many failed before. Will YOU complete the trial?",
    "points": null,
    "comments": [
      {
        "comment": "A black hole is a region of spacetime where gravity is so strong that nothing, including light and other electromagnetic waves, has enough energy to escape it.[2] The theory of general relativity predicts that a sufficiently compact mass can deform spacetime to form a black hole.[3][4] The boundary of no escape is called the event horizon. Although it has a great effect on the fate and circumstances of an object crossing it, it has no locally detectable features according to general relativity.[5] In many ways, a black hole acts like an ideal black body, as it reflects no light.[6][7] Moreover, quantum field theory in curved spacetime predicts that event horizons emit Hawking radiation, with the same spectrum as a black body of a temperature inversely proportional to its mass. This temperature is of the order of billionths of a kelvin for stellar black holes, making it essentially impossible to observe directly.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Wait, you actually opened the comments? Are you stupid?",
        "points": "2 points",
        "children": [
          {
            "comment": "Just to see whether I'm alone or not...",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "they are",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I'm that lonely and bored...",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "The world would be such a better place without you people in it.",
        "points": "1 point",
        "children": [
          {
            "comment": "You start!!!!",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "this you?",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "nice",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "son ellos",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "with many on the title this is a juicy clickbait .",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "who is upvoting this why",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Wasn't expecting comments on this",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Techbible is your go-to tech community. Ask questions and get expert answers on all things SaaS. Stay updated on the latest tech news, discover trending tools, and share your tech stack with the world. Don't Forget to try it out.\n\nhttps://techbible.ai/",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "wow",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_1990f3t",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://medium.com/@ymz-ncnk/do-we-really-need-a-message-broker-158d58547fb3",
    "title": "Do we really need a message broker?",
    "points": null,
    "comments": [
      {
        "comment": "Yes",
        "points": "7 points",
        "children": [
          {
            "comment": "😅",
            "points": "-1 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Systems with message brokers remind me of TCP. Systems without message brokers remind me of UDP. I find the latter to be more interesting.",
        "points": "1 point",
        "children": [
          {
            "comment": "That's a good comparison. What I mean is that the service itself can guarantee reliable message delivery (like TCP) without the help of a message broker.",
            "points": "-1 points",
            "children": [
              {
                "comment": "That is possible, however then all connected systems must have this built in, and be compatible with each other.\n\nThe easier route is to have one message broker, one protocol and all your components talk to the message broker",
                "points": "2 points",
                "children": [
                  {
                    "comment": "Yes, with this approach, we lose the advantages of a message broker, but we can get a faster system in return. Moreover, in theory, it can be applied partially, i.e. some services can communicate with each other directly, some - through a broker.",
                    "points": "-2 points",
                    "children": [
                      {
                        "comment": "True(ish)\n\nMy approach would be\n\nSet up a PoC using both direct and message broker to measure the increased speed, throughput, latency etc.\n\nThen based on the measurements decide if it is worth it.\n\nAlso take into account upgrades in both cases\n\nCreate a plan with timings, how long the PoC implementation will take.\n\nShow it to a decision maker.",
                        "points": "2 points",
                        "children": [
                          {
                            "comment": "",
                            "points": "",
                            "children": [
                              {
                                "comment": "“Laziness” is not an appropriate metric with which to measure the value of an architecture. Every popular tool has its value and use case; message brokers are no different.",
                                "points": "0 points",
                                "children": [
                                  {
                                    "comment": "Every popular tool has its value and use case; message brokers are no different.\n\nI totally agree with you.",
                                    "points": "0 points",
                                    "children": [],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": true
                          },
                          {
                            "comment": "",
                            "points": "",
                            "children": [],
                            "isDeleted": true
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "So you mean your wrote your own message broker.",
                "points": "1 point",
                "children": [
                  {
                    "comment": "No, I just described an idea how the service itself can be responsible for message delivery.",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "You made a broker you can’t scale horizontally?",
                        "points": "1 point",
                        "children": [
                          {
                            "comment": "I think the service itself can scale horizontally.",
                            "points": "0 points",
                            "children": [
                              {
                                "comment": "If a service instance is responsible for guaranteeing message delivery itself and it goes down after intaking the message and before delivery how do you know the message didn't get delivered?",
                                "points": "1 point",
                                "children": [
                                  {
                                    "comment": "No, I just described an idea how the service itself can be responsible for message delivery.\n\nIn the sense that it does not need to save messages in the message broker. The service client will poll the messages directly from it.",
                                    "points": "0 points",
                                    "children": [
                                      {
                                        "comment": "Are there or are there not messages that only the service instance knows haven’t been delivered yet when the service unexpectedly goes down?",
                                        "points": "1 point",
                                        "children": [
                                          {
                                            "comment": "Only the client of the service knows which messages it have already consumed and which have not.",
                                            "points": "0 points",
                                            "children": [
                                              {
                                                "comment": "",
                                                "points": "",
                                                "children": [],
                                                "isDeleted": false
                                              }
                                            ],
                                            "isDeleted": false
                                          }
                                        ],
                                        "isDeleted": false
                                      }
                                    ],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "This is just Kafka/Kinesis but worse.",
        "points": "1 point",
        "children": [
          {
            "comment": "This approach allows us not to use Kafka/Kinesis.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_198zf5h",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://github.com/rupa/z",
    "title": "Z - effortlessly jump directories",
    "points": null,
    "comments": [
      {
        "comment": "What are 'frecency' and 'frecent'?",
        "points": "2 points",
        "children": [
          {
            "comment": "A mix between frequent and recent",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Z is a great tool.\n\nI don't actually use it often, just cd for normal navigation. But sometimes I want to come back to something after not having used it a long time, and I can't remember where it is then I think \"oh yeah, I can use z\".",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_198xuhi",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.blobstreaming.org/is-san-francisco-still-the-best-place-for-developers/",
    "title": "Is Bay Area Still the Best Place for Developers?",
    "points": null,
    "comments": [
      {
        "comment": "This data is ten years old. \n\nWhy even spend the time typing up pre Covid salary/rent studies?",
        "points": "49 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "My company with a Bay Area HQ has frozen all hiring in Bay Area because of high salary costs. Moving all North American hiring to other locations and expanding international hiring.",
        "points": "20 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "This is a weird mindset of accepting major cost and risk of every part of your life for a vague possibility of reward later. I’d need to be well over 2x my current paycheck (probably more like 3x) to sustain my standard of living in the Bay Area. The adjustment between my salary where I live and the bay is more like 15-30% at most companies.\n\nThis is a type of pitch I’ve seen from lots of startups. “We’ll pay you less than you’re worth, but if you get lucky, you can have some juicy breadcrumbs after the investors get theirs”.\n\nI think a lot of people in their 30s just see behind the curtain, do the math, and leave. A few are paid well enough that it works out to stay, many (like myself) are not.\n\nI also think most startups are very remote friendly, so as programmers, living in the bay isn’t going to open up all these major opportunities, really. So it makes even less sense now.",
        "points": "11 points",
        "children": [
          {
            "comment": "Right. The days when you needed to be close to vc money is over. In those times sf was doing cool stuff cause you had to be there, but now not so much. Tack on insane living costs and the fact that you can do the same work remote and the question becomes why move to sf? It’s not even sf for gods sakes it’s some overpriced exurb! Gross",
            "points": "5 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Its also a place that has almost no nightlife, is horribly expensive, and the politics is like something out of the hunger games eith fantastically rich people encouraging homelessness for the benefit of their own charity orgs and their own fat paychecks.",
            "points": "4 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "STartups are a gamble you make in your 20s, after that a steady paycheck feels much more appealing",
            "points": "1 point",
            "children": [
              {
                "comment": "It is not appealing but it is required, especially if you have a growing family.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Don’t forget taxes, which are no joke in CA for Bay Area engineering salaries. They’ve got ~10% income tax, PLUS they have a state cap gains tax.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Where do you live? :)",
            "points": "0 points",
            "children": [
              {
                "comment": "Eastern Washington state these days, though I was in Oregon before. I've worked remote since 2017. Pay scales are still evolving, but in general, I find most places having \"tiers\" based on zip code. And the difference between tiers isn't anywhere near as big as the cost of living.",
                "points": "2 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Anywhere with internet and your computer is the best place for developers.\n\nThe bay area is best if you want to spend 70% of your earnings trying to find a home to keep yourself, internet and computer.",
        "points": "6 points",
        "children": [
          {
            "comment": "The bay area sucks. I can speak from experience.",
            "points": "-1 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "if the remaining 30% is still higher than going somewhere else, then the bay area would be best",
            "points": "-3 points",
            "children": [
              {
                "comment": "Not if you value your quality of life by more than a measure of how much money you are profiting while living and working in terrible conditions for a likely multi-year / decade span.\n\nThe more healthy approach would be to significantly lower your cost of living and working from somewhere in conditions that actually make you happy while proportionally also taking home some profit while not donating your best years to a meat grinder startup culture that will dump you at a moments notice in the bay.\n\nEdit: Healthy work environments by the way... your cost of living is the 30% and the 70% is the whatever you want do to with it portion. But to get here you have to realize that short of some life saving medical tech... no tech startup is doing anything important enough for you to take so seriously you're devoting your life to it.\n\nThen you have to have the wisdom to see the \"perks and cool shit\" they offer are just amounts of cash they should pay you directly, but instead provide to isolate you and keep you on campus working unpaid overtime \"for the team\".",
                "points": "2 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Never has been. It's not what you earn, but what you keep.",
        "points": "4 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Also stop posting this, this was literally posted yesterday",
        "points": "3 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I did the Bay area thing for 5 years after college (this was about 12 years ago). I'm not even sure it was the best place back then depending on what you are looking for.\n\nUnless there is a specific company you are looking to work for and they only have opportunities there, the answer is probably no. But you have to figure out what is important to you (cost of living, lifestyle, population density, etc) to really answer your question. But you can absolutely find great development jobs everywhere, particularly if you work remotely.",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "The bay area has NEVER been the best place for developers. If the developer is a member of the lemming family then they might follow the flock, however software developers are needed and employed all over the country. The best place for a developer depends more upon the developer as an individual as they might prefer the mountains of PA , the wonderful life that TN provides or maybe the open spaces of Montana.",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_198xjz8",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://socket.dev/blog/devtools-podcast",
    "title": "DevTools Podcast: Rethinking Open Source Security Beyond Buzzwords",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_198wmq2",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://jakeseliger.com/2024/01/16/why-dont-schools-teach-debugging-or-more-fundamentally-fundamentals/",
    "title": "Why don’t schools teach debugging, or, more fundamentally, fundamentals?",
    "points": null,
    "comments": [
      {
        "comment": "It depends on the education I suppose. Every school I went to had some amount of debugging in various classes in the curriculum, and my current university (Oregon State) heavily emphasizes this in each course.",
        "points": "259 points",
        "children": [
          {
            "comment": "It’s a bad premise. Many top schools have these courses. I particularly like this concept of teaching the “in between” stuff as another course, like MIT’s Missing Semester course: https://youtube.com/playlist?list=PLyzOVJj3bHQuloKGG59rS43e29ro7I57J&feature=shared",
            "points": "42 points",
            "children": [
              {
                "comment": "I didn't know about some of these profiling tools\n\nhttps://missing.csail.mit.edu/2020/debugging-profiling/",
                "points": "11 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "That's cool, I'm gonna recommend this to folks\n\nKinda weird to teach Vim tho imo. Most systems you need to shell into will have nano or w.e.",
                "points": "2 points",
                "children": [
                  {
                    "comment": "Most systems you shell into have vi. It's even a part of busybox so it's available on minimal linux distributions on low power devices.",
                    "points": "11 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "Legacy systems that haven't been upgraded in decades will still have Vi on them, whereas Nano means it probably got released after 2001.",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "Very often in containerized environments, nano is missing and apk/apt is disabled. Basic vi keybinds are worth knowing.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "Vim, or Vi, is basically everywhere, and much more powerful than nano. It’s worth knowing.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Same. Java was our first language and they taught us how to debug it using eclipse",
            "points": "51 points",
            "children": [
              {
                "comment": "Similar experience but with C/C++ and GDB. We did a full lab on how to use it, plus had to use it for exercises.",
                "points": "27 points",
                "children": [
                  {
                    "comment": "This is one of the things I really liked when I learned Common Lisp. The REPL was such a different way of developing. Basically rewrite your program while it is running and see the output and values. Go back and execute from 5 lines ago, and watch it run again. It was amazing and one of those aha moments for me, It combined the idea of the debugger and the logger into a single metaphor and put the developer in the middle of it in a way that author time and runtime of the program were indistinguishable. To this day I have never really seen another language focus on flattening the asymmetry between what is written and what is running like LISP and the REPL did.",
                    "points": "2 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "If you’re anything like me, after school you forgot it even existed. cout, printf, and console.log forever.",
                    "points": "4 points",
                    "children": [
                      {
                        "comment": "Nope, I kept that shit close to my heart. I use print statements as well, but both are invaluable IMO.",
                        "points": "11 points",
                        "children": [
                          {
                            "comment": "I'm in .NET, but console logging is invaluable once you get into multithread nonsense :-)",
                            "points": "2 points",
                            "children": [
                              {
                                "comment": "Both are useful, but you really have to dig into using a debugger correctly for that env. It's a lot to learn though.",
                                "points": "0 points",
                                "children": [],
                                "isDeleted": false
                              },
                              {
                                "comment": "Just logging in general. Whether its to a console, a database, or the filesystem, all that matters is the almighty log.",
                                "points": "0 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "Lol. Finding the right thing to log or finding more things to log is always fun ;) Logs are a great way to figuring out how to reproduce the bug.",
                        "points": "1 point",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "thats very suboptimal and a debugger gives the variable values anyway...",
                        "points": "1 point",
                        "children": [
                          {
                            "comment": "Both have their place. Logging is faster when I just need to see what value something is spitting out or how something changes over time. Intricate bugs usually benefit from breakpointing, but if I dont need to step through the call chain or examine program state then I normally go with logging. Particularly for UI work I find not needing to juggle the BP means I can move a lot faster.\n\nDepending on your tech stack and framework sometimes breakpointing isn't even realistic (eg with Angular and observables breakpointing is often worthless since you cant see the inner value of the observable)",
                            "points": "6 points",
                            "children": [
                              {
                                "comment": "Logging is fine for simple things, but the person Ive responded to claims to never use a debugger.\n\nI mostly work in cpp and cout statements become useless really fast.",
                                "points": "2 points",
                                "children": [
                                  {
                                    "comment": "Yea outside of the frontend world I find logging much less useful. When I'm working in c# I almost exclusively use breakpoints.",
                                    "points": "2 points",
                                    "children": [],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              },
                              {
                                "comment": "Logging is faster\n\nThere's no way you believe this, unless your only exposure to debugging is terminal debugging(which isn't real debugging)",
                                "points": "0 points",
                                "children": [
                                  {
                                    "comment": "For frontend work? Its easily faster. Rerenders can trigger dozens of times a second. I can either release a breakpoint a dozen times checking the value every time or I can just console.log and check the values. Sure you can set conditional breakpoints but thats additional setup time and you don't always know the value you're looking for, just that its anomalous.",
                                    "points": "1 point",
                                    "children": [
                                      {
                                        "comment": "I don't do much front end work, so maybe you're right.",
                                        "points": "0 points",
                                        "children": [
                                          {
                                            "comment": "",
                                            "points": "",
                                            "children": [],
                                            "isDeleted": false
                                          }
                                        ],
                                        "isDeleted": false
                                      }
                                    ],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          },
                          {
                            "comment": "In a lot of contexts, you can't attach a debugger to a production system. In that case, you're better off not using a debugger at all so that you put in the necessary logging/observability during development instead of finding out you failed to capture the necessary information after you have a production issue.\n\nPersonally I've only ever used a debugger to inspect the workings of someone else's program that I don't control. Otherwise logs + source works great.",
                            "points": "1 point",
                            "children": [
                              {
                                "comment": "In a lot of contexts, you can't attach a debugger to a production system.\n\nWhat would those be? Embedded, maybe?\n\nAs far as I know, if it’s a running process you can attach to it.",
                                "points": "0 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          },
                          {
                            "comment": "While I agree with you, different things work better for different people. If they're getting their work done and not a drag on the rest, you do you.",
                            "points": "1 point",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "Command line debugging using GDB is a terrible and slow experience compared to debugging using an IDE. If you didn't use an IDE to debug, you weren't taught how to debug.",
                    "points": "-1 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "I'm going to take a risky guess; was this in relation to the book \"Computer Systems: A Programmer's Perspective\"? That's where I had to learn GDB.",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "Bomb lab, man.\n\nI was lucky enough to take it with the authors at Carnegie Mellon. 15-213 was a fantastic course.",
                        "points": "2 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Oh God why would they torture you with eclipse?",
                "points": "-6 points",
                "children": [
                  {
                    "comment": "Before VSCode it may have been the only free GUI-based debugger.\n\nRight now, yeah, I avoid it.",
                    "points": "14 points",
                    "children": [
                      {
                        "comment": "Yeah, but Intellij is free for students, and honestly any Java shop still using eclipse is not somewhere you want to work",
                        "points": "-10 points",
                        "children": [
                          {
                            "comment": "Some of us have been around since before IntelliJ IDEA was a thing. I know, right?",
                            "points": "2 points",
                            "children": [
                              {
                                "comment": "We are talking about a current college course right ? Not one 20 years ago",
                                "points": "-2 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "We got a small guide for all IDEs we used. As well as chrome and Firefox Dev tools. I thought this was the norm until I got into some communities and looked at the help section...",
            "points": "7 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Also at Oregon State and can confirm that debugging is important and even explicitly required as an assignment in some courses such as Assembly.",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "By any chance, are you involved with the postbaccalaureate computer science program at Oregon State? I'm wondering if you could speak to it a bit more.\n\nI've regretted not studying computer science when I was in undergrad, so I find this opportunity really exciting.",
            "points": "0 points",
            "children": [
              {
                "comment": "Hi! So I am a non-traditional student in that I'm turning 30 this year, but I am pursuing my first Bachelor's degree, not a post-Bacc. Originally, I was pursuing a BFA in college right out of high school, but I got burnt out and quit.\n\nThat said, I really like OSU's Online CS program. Having done online CS at my community college and at a different university (Old Dominion University), OSU is leagues ahead of them. Post-Bacc students take the same courses, just not on the same degree plan (fewer gen-eds, I think fewer electives etc.). I can't speak to how well the accelerated course plan prepares you, and I'll say I transferred into OSU as a junior (so I've only had to take a couple 200-level classes, everything since has been upper division).\n\nIt's completely asynchronous, and you're very much expected to drive your own learning. Most classes are structured as such to provide you an educational framework, evaluations, and instructional support, but there is not a lot of hand-holding and if you're not a self-driven learner you're likely going to struggle. However, the help is there if you need it. I've personally found all my instructors to be responsive, engaged, and helpful, and usually there's tons of office hours throughout the week.\n\nIf you're considering it, I can 100% recommend OSU's online CS program, at least as someone pursuing their undergrad. Even for an online college the atmosphere and energy of everyone is excellent. I found students and administrators to generally be more engaged and positive about the experience vs. the other schools I attended. Your mileage may vary, of course, and ultimately it's on you to make the most of it.\n\nThe one thing I can't speak to is career opportunities. I'm already a full-time working professional with a strong network, so I haven't pursued things like career fairs or internships. Definitely the weakest point of pursuing an online education is you miss out on the networking opportunities, but I'm personally just here for the education, so I don't feel deprived.\n\nLet me know if you have any other questions about my experience, happy to share!",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I was about to post \"They do\" to the post title question, but I also went to Oregon State so maybe we're just built different.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "My university had a huge part of our C course dedicated to debugging using both a debugger and printf. It was super fun, you had to scavenge a black boxed code and find out all the hidden bugs and were marked on how many bugs you found.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Oregon State has gotten heavy feedback from the industry that debugging is a necessary skill. As an alumni I know that I point this out as have others.\n\nThough the tools have gotten way better than they were even 20 years ago. I don't even think we had access to a good IDE back then. I remember spending lots of time with printf statements trying to figure out why the code wasn't working.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Speaking for Germany, those who are good programming teachers teach adults for several times the money they could earn teaching high school students.",
        "points": "53 points",
        "children": [
          {
            "comment": "I‘ve never learned about debugging in germany. We even wrote our exams on paper. No wonder our IT sector is so bad.",
            "points": "11 points",
            "children": [
              {
                "comment": "Demand change!   Germany’s software problems are world wide news.",
                "points": "4 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "What’s wrong with writing exams on paper?",
                "points": "-1 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "[deleted]",
            "points": "7 points",
            "children": [
              {
                "comment": "People aren't downvoting you because they don't understand you're being sarcastic, they're downvoting you because you're being rude (and also your comment is very poorly translated)",
                "points": "7 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Mine certainly did. Very first programming course used eclipse and showed us how to set breakpoints, step in/over/out, and so on. Is that not standard? I went to a state school, not anything special or unusual",
        "points": "131 points",
        "children": [
          {
            "comment": "I guess it's not, because I wasn't taught how. I'm almost 20 years past graduation now but it's crazy how many junior and intermediate devs do not have any clue how to debug, like there's a guy with 10 years experience that I was helping debug and if he hit a breakpoint and needed to go 5 lines forward he'd set another hreakpoint and hit f5. Had no idea he could just step forward to that spot.\n\nNot to mention any time I've been screen sharing and I've used a conditional breakpoint and people's minds just explode. Everyone thinks I'm a wizard and I'm just using what I feel is basic functionality.",
            "points": "32 points",
            "children": [
              {
                "comment": "First time I’m learning about a conditional breakpoint lmao, thanks for bringing it up",
                "points": "10 points",
                "children": [
                  {
                    "comment": "Dude, spend a few min researching advanced breakpoint techniques. It will make you so much more efficient. I did a presentation a while back at work on this and here were some of the big things I was surprised no one knew about:\n\nConditional breakpoints - Only fires when data matches your criteria. Is your method breaking for only one piece of data but it's looping through 1000s of records? Set a breakpoint, go to settings, check conditions and write something like x.Id == 472 (or whatever makes sense) then when you hit item x that has an id of 472 it will stop, and everything else will be ignored.\nActions - For long running jobs you might not want to break as it can cause timeouts on things like API calls. So you can just have it log a value to the output window and keep executing.\nBreakpoint labels - If it's a breakpoint you'll use again give it a label, that way you can easily find and identify it. Used to use these a ton before the next one was introduced.\nBreakpoint groups - I often will have several breakpoints tied to a certain ticket I am working on so I will group them under that ticket #. Then when I'm done I can disable all those breakpoints by unchecking the group. If that ticket comes back to me a week later with a bug I can quickly re-enable all the relevant breakpoints, or just some of them.\nWatches - Basically like a breakpoint but tied to a variable and not a line of code. If you are not sure what's updating a variable set a watch on it and the code will break automatically when it's updated.\nThe Immediate Window - I use this a ton, but I almost never see others using it. It allows you to execute code while at a breakpoint. You can update a variable to a new value, or maybe you need to null it out to test for null reference errors. Heck I often use it to genereate a GUID. Probably the most common thing I'll do is copy a long if statement (minus the if) and see what the value is. e.g. if you have something like if(dataset.where(c=>c.Date > [somedate] && isEnabled == true && somethingelse > 5 && anotherthing == \"foo\") you can quickly determine if that evaluates true or false by pasting it into the immediate window. Then from there you can strip it down and find out exactly which part isn't working as expected. This is really handy for stuff like LINQ in the if because you can't just hover you mouse over it to see the value.\n\nThat's all for now but if I think of more I'll add them to the list.\n\nEdit: Should have mentioned these are for Visual Studio, but you should have similar options available in other IDEs.",
                    "points": "44 points",
                    "children": [
                      {
                        "comment": "Wow this is super detailed and helpful. Thank you for sharing!",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "Most of them negatively impact performance.",
                        "points": "-12 points",
                        "children": [
                          {
                            "comment": "You don't usually debug performance-optimized release builds...",
                            "points": "8 points",
                            "children": [
                              {
                                "comment": "You also take cycles to evaluate the breakpoints and even might crash the runtime. What's your point?",
                                "points": "-6 points",
                                "children": [
                                  {
                                    "comment": "What's your point? You stated something obvious to anyone with a brain. Should we not use these features?",
                                    "points": "2 points",
                                    "children": [
                                      {
                                        "comment": "I've assumed you had one but apparently not.",
                                        "points": "0 points",
                                        "children": [],
                                        "isDeleted": false
                                      }
                                    ],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              },
                              {
                                "comment": "They're not wrong, though.\n\nConditional breakpoints can slow down execution by 10-100x, in my experience.\n\nIn some cases you're far better off adding a new line of code inside an if block with the same condition, just because of how bad it can get.",
                                "points": "0 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          },
                          {
                            "comment": "Which is almost never a concern when debugging on your local machine.",
                            "points": "1 point",
                            "children": [
                              {
                                "comment": "Have you never debugged a race condition?",
                                "points": "0 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "VScode calls Actions \"Logpoints\" and \"Immediate Window\" is called \"Watches\". It doesn't have groups or labels.\n\nI don't know how to set a watchpoint, but it probably has them. gdb certainly does, if your platform supports them. lldb also for the few who use that.",
                        "points": "0 points",
                        "children": [
                          {
                            "comment": "Use a proper IDE instead of trash notepad.",
                            "points": "-11 points",
                            "children": [
                              {
                                "comment": "Such as?",
                                "points": "0 points",
                                "children": [
                                  {
                                    "comment": "CLion, visual studio.",
                                    "points": "1 point",
                                    "children": [],
                                    "isDeleted": false
                                  }
                                ],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      },
                      {
                        "comment": "This is fantastic, I knew about some of this but definitely not most of it, will be looking into all of these. Thank you!!",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "The Immediate Window\n\nI usually use the watch window for the stuff you listed. You can put expressions in there instead of just variables. Without side effects they are reevaluated automatically. When watching a variable you can also just edit the value in the second column.\n\nAnother thing not mentioned are data tips, basically watch expressions you can place directly next to the code.",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "I wasn't taught how. The system my earliest courses were taught on didn't even have a debugger. I did them on Turbo Pascal instead on a PC. Which also didn't have a debugger (this was the 1.x version, the later one wasn't out yet).\n\nI'm sure it varies by school to school but my impression is they don't teach anything they can't grade on and grading on debugging is difficult (not impossible).",
                "points": "1 point",
                "children": [
                  {
                    "comment": "Yeah that's a good point. It would be hard to grade. But I could still see creating a scenario where an app has a bunch of bugs and you have to debug it, but there wouldn't be a way to enforce that you debugged it using the tools and not just by adding logging after every line.",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "I wasn't taught it myself. I just idk tried things? Learn on my own. Discover stuff ? Talk to my classmates and learn new ideas from them (sorry mate, do you know how to exit vim perchance ?)\n\nI am not sure about the whole premise of the post. At uni I was taught math/physics. The compsci stuff was mostly self learning...\n\nOfc we had lectures but that was mostly a staring points for self learning.",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              },
              {
                "comment": "I mean, that's more of a tooling thing than understanding how to debug. I have over 10 years experience and I still use logging to debug most of the time, and unit tests to debug the rest - but I know how to debug just fine.\n\nGetting downvoted, but I stand by what I said: debugging is skill, a debugger is a tool.",
                "points": "-1 points",
                "children": [
                  {
                    "comment": "\"Debugging\" is when you do visual debugging using an IDE. Everything else is reverse engineering.",
                    "points": "-3 points",
                    "children": [
                      {
                        "comment": "Debugging is identifying and removing coding problems from software - that's the textbook definition. A debugger is just a tool that helps you do it.",
                        "points": "1 point",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Conditional breakpoints are not commonplace IDE functionality and it's unsurprising that people don't know about it.",
                "points": "-1 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "No it’s not standard seemingly. I despair when I see juniors who apparently don’t even know about it.",
            "points": "8 points",
            "children": [
              {
                "comment": "Have you also noticed people picking it up slower when shown? I really have, when I first saw a visual debugger or a CLI one I was hooked and dug in. Now I show people and step through something, and it's like they can't apply that in different scenarios. Not sure how to get someone else past that.",
                "points": "6 points",
                "children": [
                  {
                    "comment": "Yeah I think I know what you mean?",
                    "points": "1 point",
                    "children": [
                      {
                        "comment": "It's \"learn the thing for this task\" rather than \"learn the thing in general and think about how to apply it\" I think? Its something I haven't hit before in my career and I'm struggling to help folks get past it, but it definitely affects their performance and to be honest my patience.",
                        "points": "11 points",
                        "children": [
                          {
                            "comment": "Oh yeah I have encountered that to a massive degree and I it’s really frustrating to deal with. Feels like a lack of general interest or passion about it.",
                            "points": "1 point",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "Being self-taught I was somewhat horrified that hiring personnel felt like they had to ask applicants if they were able to use a debugger for C#. Like... How do you manage to learn to write software without debugging, and explicitly in C# which was pure visual studio with a very good and simple debugger built in back then!?",
                "points": "1 point",
                "children": [
                  {
                    "comment": "100% have said exactly the same thing before",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "I went to a small state school with a lackluster program. Many of the students in the capstone course didn’t know how to use a debugger. About half of the people in my group for the final project were helpless, it was like they never coded before.\n\nIt may have been dependent on the professor, but most of my algo courses outside of data structures had no coding assignments, it was all on paper.",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "It's been heavily emphasized at mine too. For us it was eclipse as well, then for systems courses we were taught how to use valgrind and the gdb debugger.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Mine did not, I went to a California state university. I learned a little on my own and then in my first dev job",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Unfortunately no",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "\"Is that not standard?\"\n\nNo it is not.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I went to a small private university and the CS professor preferred for us to do all our coding in Notepad and didn't teach us to use an IDE at all. Also didn't teach us what a code repository was or how to use one. Early 2010s.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Practically every course I took involved using some compiler/interpreter toolchain (gcc and make, MSVC, Eclipse, Idle from what I remember), and one of the very first labs we did when a new environment was introduced was the basics of compiling and debugging a program.\n\nThat was usually 1 lab class with like a half dozen problems where we had to implement a program from a partial skeleton, or to debug and fix an unknown problem with a simple expected output (usually it was a problem with an algorithm we had learned recently).\n\nThis was 2008 - 2012. Not a public school, private one, but not exactly one that I'd say was highly rated (or even mid tier) for computer science.\n\nIt definitely varies because some of my first coworkers out of college (same age group as me then) had to be tought this stuff, seemingly never done it before.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I feel like most people went over debugging, they just don't remember or didn't pay attention enough in their CS 1 or 2 courses.",
        "points": "31 points",
        "children": [
          {
            "comment": "As ashamed as I am to admit this, 100% this is me and it came back to bite me HARD in grad school",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "People who aren't constantly debugging aren't truly programming. Black box programming is bad and slow.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Went to CU boulder, did most of our courses in Java and c/c++. They never offered a dedicated class to learn those languages. \n\nSo you end up struggling not with the course material, but the language the professor uses.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "most comp sci classes are just math classes wearing a disguise.",
        "points": "60 points",
        "children": [
          {
            "comment": "fun fact!\n\ncomputer science is the science of computing which is mathematics.\n\nit is not the science of programming which is how to program computers to compute.\n\nthis distinction is honestly not well known because the main job of a computer scientist is a some sort of programmer, but the degree in and of itself isn't (that much) about programming.",
            "points": "81 points",
            "children": [
              {
                "comment": "But AFAIK there are \"software engineering\" degrees these days which will focus a lot more on things like debugging, version control, etc. But yeah, CS is a math degree.",
                "points": "24 points",
                "children": [
                  {
                    "comment": "Software engineering degree programs kind of have a rep of focusing on marginally-useful methodology, though. Meanwhile you can incorporate debugging and version control into a course about broader topics E.g. the common \"binary bomb\" homework assignment for debugging. The CS department at my school actually had a course called Production Ready Software or something to that effect which bundled all the important bits into one semester. I feel like one course is sufficient to expose you to the ideas & tools, the rest of it is just experience you get on the job anyway.\n\n[edit] Note this is not intended to drag folks with SE degrees. This is more reflecting on what's worth spending tuition on. The important parts overlap enough.",
                    "points": "3 points",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "I would also consider IT to be the actual engineering with computers. CS is a good Segway into those jobs though because there is so much programming",
                    "points": "2 points",
                    "children": [
                      {
                        "comment": "Segue. You just made a Ludacris error. ;)\n\nAnd for what I matter I think of IT as closer to a facilities manager than engineering. Certainly it varies though.\n\nI know this, despite having plenty of computing chops, I couldn't hold down an IT job. So I'm not saying it's some kind of joke or easy job.",
                        "points": "5 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "I don't think that distinction really means that much anymore as it comes to jobs or degrees.\n\nWhen you get a CS degree now the only part which is really math is the various \"theory of computing\" courses, basically big O notation and some data structures (others not as much). You have a lot of courses about languages or accomplishing tasks. Those are programming not math.\n\nIn the olden days schools created their computer science departments in their math colleges. And computers really kind of just solved well defined, simple (but not in effort) problems. You submitted a problem in a batch job and it gave an answer.\n\nNow computers are much more about interaction and sequencing stuff. Instead of you taking a lot of measurements and creating a program to solve it you just put the measurements into a spreadsheet, which is a program designed to accept other than \"code\" to define its behavior. Nowadays the computer can just take the measurements itself. Point a measuring device at a wall and boop it measures how far away it is and puts it in a database (spreadsheet often) and you can calculate on it automatically.\n\nWe've really come a long way from \"how do I get this damn to do anything\" to \"I bet I can just google up a web page that can calculate the area of this pentagon.\"",
                "points": "2 points",
                "children": [
                  {
                    "comment": "most of the time when you see people parroting this it's because they don't have a CS degree and are rationalizing why that's better.\n\nNo CS student graduates without doing quite a bit of programming, in the same way that no one graduates with a math degree without doing quite a bit of calculating.",
                    "points": "4 points",
                    "children": [
                      {
                        "comment": "I graduated with a math degree without doing much calculating at all. I had courses in my final year that didn't contain any numbers whatsoever.",
                        "points": "1 point",
                        "children": [
                          {
                            "comment": "As someone who is self-studying math right now, what did you think of those courses and what courses were they? (If you don't mind me asking)",
                            "points": "0 points",
                            "children": [
                              {
                                "comment": "Did a course on Logic, that was fascinating. Also a course on measure theory, which had almost no numbers. But even courses like advanced group theory contained very few numbers at all.\n\nI chose a lot of units based on proof/logic, and I loved them. But many of my friends - doing the same degree title, at the same place - chose units that were much more mechanics-based or much more statistics-based and had a totally different experience to me.",
                                "points": "0 points",
                                "children": [],
                                "isDeleted": false
                              }
                            ],
                            "isDeleted": false
                          },
                          {
                            "comment": "I like to joke \"I'm a mathematician! I deal with letters, not numbers!\" to anyone who asks me to do arithmetic. I hate arithmetic.",
                            "points": "0 points",
                            "children": [],
                            "isDeleted": false
                          },
                          {
                            "comment": "I have a degree in CS & Math and you're talking bullshit or your school has a shitty math department.",
                            "points": "0 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  },
                  {
                    "comment": "I don't think that distinction really means that much anymore as it comes to jobs or degrees.\n\nthere is a big difference between working with high performance applications or applications where you're doing R&D development and Marketing Firm CRUD to pay the bills.\n\nI do not disagree that many jobs out there don't really require any complicated math, but there are a lot that absolutely require you to understand computer science to a tee to do what you want to accomplish.",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "My \"video game\" CS degree was a shit ton of math. Got me 85% the way to quantum mechanics, honestly.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "The science of programming is math too, scooby doo.",
                "points": "-1 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Well, computer science is a branch of mathematics...",
            "points": "17 points",
            "children": [
              {
                "comment": "When I went to school unfortunately this was not common knowledge. Lots of my peers wanted to skip the “BS” classes and go to webdev electives already.",
                "points": "3 points",
                "children": [
                  {
                    "comment": "That's kind of funny, because I actually left my schools CS degree for math so I could avoid the \"BS\" classes like web dev hahaha (I know it's not BS)",
                    "points": "8 points",
                    "children": [
                      {
                        "comment": "I double majored in applied mathematics for similar reasons. The CS program was pretty weak.",
                        "points": "2 points",
                        "children": [],
                        "isDeleted": false
                      },
                      {
                        "comment": "Same! Although we had an interesting set of concentrations in the Math department - including \"Mathematical Computing\" which was basically CS minus practical courses.\n\nI ended up going for Stats & Applied Math, with a CS minor - unfortunately you couldn't have both the mathematical computing concentration and a CS minor at the same time.",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "“You won’t do well if you aren’t good at math” - my teachers\n\nme in the field for over 15yrs now",
            "points": "2 points",
            "children": [
              {
                "comment": "They should teach something useful like how to center a div.",
                "points": "3 points",
                "children": [
                  {
                    "comment": "They would if they knew how to",
                    "points": "1 point",
                    "children": [],
                    "isDeleted": false
                  },
                  {
                    "comment": "One does not simply teach this.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "That’s because it’s a science degree.",
            "points": "4 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "At this point I stopped reading:\n\nIn most K – 12 public schools, after one to three years most teachers can’t effectively be fired, due to union rules, so the incentive to be good, let alone great, is weak.\n\nIt’s a myth that you can fire your way to having a bunch of great teachers. Fact is great teachers quit every year. They are also not easy to come by. Just look at the ratios. Great teaching has nothing to do with incentives. Great anything has nothing to do with incentives. Great anything is a matter of principle. It is the desire to pursue mastery.\n\nDebugging as a skill requires more that “we learned eclipse” or “I can set a break point“ or “I can set conditional break points“ or whatever else people in this thread mentioned.\n\nTo say debugging is about using the features of a particular debugger, is like saying my skills with MS Word make me an author.\n\nNo. Those skills with MS Word also don’t make me an editor. What makes me an editor is my ability to recognize what is helpful feedback and what is not. That’s teaching.\n\nMost people are not able to do that. Most people will latch onto grammar and spelling when they try to edit. If you ever tried to teach writing, you know that doesn’t matter or that such feedback doesn’t educate. Great writing isn’t achieved by being grammatically correct or demonstrating your spelling skills.\n\nTeaching is hard. Understand that much, and maybe you have a chance of understanding the whole of the situation.\n\nProbably, students could be taught how to debug software, but there is more to the skill than being able to set conditional breakpoints and run some debugger compatible code to experiment with possible solutions to the problem.\n\nKnowing the details of a debugger just gets you started with what’s possible. Debugging is another skill. It’s like knowing how to drill, saw, and glue wood. Doesn’t make you a carpenter.",
        "points": "16 points",
        "children": [
          {
            "comment": "I agree with your argument and to extend upon your thoughts: most American universities are research oriented. This means they have less reasons to be debugging things in their day to day. Debugging is more an art than a science so unless that disconnect is addressed, how the hell are universities going to develop a program that is divorced from the over arcing direction of the university or department?\n\nThen they have to find someone to actually teach the thing.",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Debugging at its core is just problem solving - or investigating.\n\nI don't know what the school could teach you in specific that would grant you any merit, except for general problem solving and investigating; which I mean, they do.\n\nThe danger they run in teaching you such a specialized perspective such as debugging tools, is that those tools may very well have become obsolete by the time you enter the workforce. If they teach you problem solving, then the lesson you would've taken away would have been more successful and widely applicable than a specific subset of tooling!\n\nHope this helped.\n\nEDIT: If you're saying not in grade school, but undergraduate - I'd be shocked that they wouldn't have taught you to debug your code in addition to writing it in a programming course. Since, you would've needed to debug as a part of writing a working solution.",
        "points": "12 points",
        "children": [
          {
            "comment": "Debugging is specifically the act of using an IDE to visually debug a program. When a coworker says \"try debugging it\", they don't mean fix the bug via problem solving. They mean hit the debug button, let the debugger take you to the line that caused the error, and look at the complete state of the program to see why the error happened.",
            "points": "-8 points",
            "children": [
              {
                "comment": "This is comically a terrible take.\n\nThere exist many languages, and frameworks that do not use an IDE. What then?\n\nDid the first programmers also use IDEs in the 70s to solve bugs? Cmon now.",
                "points": "0 points",
                "children": [
                  {
                    "comment": "It's not a take, it's just how the word is used in common parlance. Debug means to hit the debug button. Some languages don't have debuggers and IDEs and therefore can't be debugged.",
                    "points": "-1 points",
                    "children": [
                      {
                        "comment": "Alright, so - you're entirely wrong. That 's not at all what debugging means, and the fact that you said that makes me really think you don't know what you're talking about.\n\nMatter of fact - here's a few resources to help you understand what debugging is.\n\n​\n\nDebugging is the process of finding and fixing errors or bugs in the source code of any software. Source.\n\nNot how it is not the process of using a debugging tool, which is what you are referring to. What you're effectively doing is saying that a backup camera is a requirement of going reverse in a vehicle. The tool makes it easier, but it is such a wildly silly take to say that's what going reverse is.\n\n​\n\nIn the 1940s, while she was working on a computer being developed for the US navy at Harvard University, her associates discovered a moth (an actual insect) stuck in a relay that crashed the computer.\nWhen fixing this problem, she remarked that they were \"debugging\" the system. Source.\n\nThe term debugging is older than the actual existence of IDEs.\n\nI honestly could keep going, but it's really not worth either of our times.\n\nPlease do not attempt to educate or correct anyone until you grasp basic computer science concepts. Usually I'm not so harsh, but the fact that you so confidently stuck to an opinion that was obviously wrong, is concerning to the entire field.",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Are we talking \"click here to set a breakpoint\", or are we talking \"meticulously analyzing your mental model of a system and finding where it diverges from reality\"?\n\nBecause the first one takes half a lecture in CS200, and the second one is an intuitive process built from years of experience. I'm not sure how you'd build a full class out of either of those.",
        "points": "8 points",
        "children": [
          {
            "comment": "Sure it takes years to be really good at it but a class with semester worth of exercises which in some way simulate the task of investigating a bug in something like actual production software would put the average graduate in a much better position than without though.\n\nWhat do you do when you look at the description of the bug/issue? how do you reproduce it? how to even start to investigate what might be causing the issue? I had to figure out most of that stuff when I got my first job.\n\nI knew how to use breakpoints and how to step through code when I got my first job but often that is a last resort and in a lot of situations attaching a debugger might not even be an option. I feel dumb saying this but when I got my first job I had no idea to look for a log for instance.",
            "points": "-1 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "You don’t but many students are not ready to enter college technical programs these days.   I’m talking everything from CS, to electrical engineering.   Much of that is due to the inability to use a computer productively.  As such there really needs to be a base level of skill in computer use for these programs.   Added on there should be program specific knowledge required.  For example in a CS / SE program understanding and using a text editor should be a requirement.",
            "points": "0 points",
            "children": [
              {
                "comment": "I saw this happening years ago in my last year as a tutor in CS already.\n\nIt is kind of wild, because stuff like \"debugging\" is part of the \"become familiar with your IDE\" part of the very first courses and it usually takes like 20 minutes or something and you are done.\n\nWhat made people bad at debugging is that they never really tried it because they ware unable to use a normal UI in an explorative or intuitive way. An extra lecture wouldn't have made up for the lack of \"using a computeeer\" for 18 years",
                "points": "0 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I was taught debugging in my intro. to object oriented programming course; however, I will point out that most colleges offer \"computer science\" degrees, not programming degrees. They are very different. Coming up with new algorithms and computer architectures is very different than making software.\n\nThe article is not about debugging, though, it is about not teaching fundamentals before moving on to material that requires it. E.g. not teaching editing, but teaching writing, or not teaching algebra when teaching engineering. I am not sure I agree with the premise of the article as I did learn those things in school, just not in university. A better statement would be that universities should review fundamentals, such as rules for using a comma or algebra, before moving on to more difficult subjects. Which I sort of agree with, however, I recognize that given the limited time that universities have to cover a curriculum and the fact that college students can and should be expected to review things on their own, I don't think it makes sense to have it as part of a core curriculum. Perhaps, they can have a list of review text books or chapters to go over before a section is started.",
        "points": "17 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Because compsci is not programming",
        "points": "9 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Because they fundamentally don't understand it.\n\nThey don't need to.\n\nThe product they are churning out are students, not functional code.",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I remember being shown a debugger, but getting good at it requires experience and practice. Even now I don't find it as useful as other techniques.",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Because university isn't job training.",
        "points": "6 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Yeah I get why an engineering prof would be frustrated by a student's request that why spend class time reviewing algebra.",
        "points": "4 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "University is supposed to be about you teaching yourself how to learn things with the lectures and labs just being a guide. If you practice and research on your own you will discover how to do these things.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "They do.. maybe go to college and not boot camp",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "schools dont teach a lot of things. they just expect to have all the skills beforehand.\n\nwhen i had written my code, the teacher didnt care to look at it . Told me to go through her method and \"learn\" it when my method just missed like 1 line of code which I found out like 10min later :P",
        "points": "6 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "It's disheartening that fundamental teaching is lacking in some institutions. I remember feeling lost and unsupported when I first started learning to code. Maybe if we shared our own strategies and resources, we could help future learners.",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Most of my classes were done on the terminal. Some professors actually made us print the code on paper for grading. Garbage curriculum with a couple of banger courses.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Decades ago, universities separated computer science from programming. It’s insane to think about now, but they told us that we were algorithm creators who would solve hard logic problems and then hand it off to some code monkey to get it working.\n\nIn essence there is some truth to this, but the creator is also the code monkey. Most complex apps I’ve worked on have the fundamental secret sauce that does the useful work that is the core of the program, but that is useless until people can actually leverage it.\n\nOf course, there are hard computer science / math problems that are theoretical and people spend their lives working on these problems, but the overwhelming majority of programmers are basically doing CRUD apps with some business specific processing and enforced rules.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "WTF does that image have to do with this post?",
        "points": "0 points",
        "children": [
          {
            "comment": "They're shilling their shitty article.",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I’ve seen a lot of interns come and go. Computer science doesn’t seem to teach anything practical. If those students don’t get internships before they graduate I don’t think they have a chance of having any real world skills like debugging and we don’t hire graduates who didn’t have internships. It’s the internship which means they’ll have some idea what they are doing. I’d rather hire a technical school winter graduate than computer science graduates.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Perhaps best illustrated by analogy with another profession. In the UK, acting is taught as a university course, and most working actors learnt that way, with the main exception being those who started as child actors.\n\nIn the US, it is more of a trade, which you get at most a 2-3 month vocational course, and then just learn on the job. Hence:\n\nhttps://youtu.be/S2\\_oXZKr\\_J8\n\nHowever, this actually happens at dedicated institutions, not general purpose universities. For example:\n\nhttps://www.rwcmd.ac.uk/department/drama/acting\n\nThese actually want to teach people how to act, and are proud when they succeed. They don't wish they were instead investigating the psychology of mimicry.\n\nNeither country has anything like that for programming. One day, perhaps even before programming becomes obsolete, some country will create such institutions, and all the tech companies will move there.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "A lot of schools/learning institutions follow a purely outcome based curriculum.\n\nSo things like debugging that typically happens as part of the process often get forgotten or in some cases even ignored.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I went to UC Berkeley for CS. None of the courses taught debugging but all of our projects required creating unit tests and were so difficult that you needed to “learn” debugging on your own.\n\nI really wish they taught us how to debug.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Debugging is mostly “Can you determine which half of the code has the problem in? Repeat until found.”",
        "points": "-1 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "via hacker news, food for thought around skill acquisition",
        "points": "-17 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Becasue there is no profit in that.",
        "points": "-2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Because it's boring af and no one would take the classes if they did...",
        "points": "-2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Most Computer Science professors are sharing the same classwork assignments that have been done for decades. my state college (Eastern Florida State College) is heavily focusing on Java, but not in C++. This should be a red flag because most local companies in that area are using C++. I am glad that I got some C++ experience when I had an AS Degree in Computer Programming.",
        "points": "-3 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Because we cannot run country only with nodeJS troglodytes, someone actually needs to know how to do stuff and how stuff works.",
        "points": "-6 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I really wish schools would at least teach Git",
        "points": "-5 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I learned how to use a breakpoint at my first job after college. It was revolutionary to say the least. It had all be console logs up until then.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Are you in a theory school or applied science school? Debugging was a major part of my education. I am not a Computer Science grad, though. For my degree I actually took programming classes.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I was a GSA and I made it a point to teach debugging because I taught debugging.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "they do... but people don't use them for some reason",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "You need a course in debugging? I mean, it's an art, but still, fundmentals means something else, please.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Most schools are for \"computer science\", not trade secrets or practices.\n\nAnd Debugging is mostly cover during C++ or Java course, back in days(not sure how curriculums are now).",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Did they teach you how to see the stack?\n\nI don't think know anyone who didn't pick it up from a coworker or a friend",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "My research is primarily focused on CS Education in K12. So, for those interested, here are a few articles that dive deeper into the struggles of debugging - both in learning it and in teaching it.\n\nDesirable difficulties (not debugging, but a nice overview of the idea referenced in OP's post) https://burrell.edu/wp-content/uploads/2020/09/EBjorkRBjork_FABBSchapter2014-2nd-ed._WithCoverPage.pdf\n\nDebugging a review of the literature (an older Lit Review but still applicable and a quality paper) https://www.tandfonline.com/doi/pdf/10.1080/08993400802114581?casa_token=sP_eaTyi3HMAAAAA:mmU1zeFhDl3VzJkhQVKQ_rHQWJ5uS7WanRd3D_O5m7ldi9r-fSKpaKo5pjGWY7jbOGpcRyWnJX4IBg\n\nThe Cambridge Handbook of Computing Education Research (a mass compilation of CS ED research, including various aspects of debugging) https://books.google.com/books?hl=en&lr=&id=vmAwEAAAQBAJ&oi=fnd&pg=PP1&dq=info:4etl3RJXzT8J:scholar.google.com/&ots=1mqCJX8WbI&sig=GT-aKOJVOd2JBkY_KWXlxZqC7Xw#v=onepage&q&f=false",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "My school definitely did, we learned what breakpoints were and how to do them. It has been a while since I've been in school but I recall doing it in multiple classes.\n\nMy issue has never been with them not teaching fundamentals, I've always felt like I had a good fundamental base. My issue, after getting into the real world, is how little of the real world they teach you. They don't tell you that you're going to have insane deadlines or requirements change at the last minute. They don't tell you the vendor is going to have broken pieces you have to figure out. They don't show you someone else's sloppy code and expect you to work with it. They don't teach you that you're going to spend time in meetings solutioning things with business people that don't understand the technicalities of the code. There's just so many things that a skilled software engineer needs to be capable of that is completely void in the education system.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Article is a lot of blabber. It itself needs debugging.\n\nWhat I’ve observed from the interns we hire, most have some experience using a debugger. None have experience using a profiler.\n\nFrom interviewing though - use of a debugger tends to arrive late in curriculum. Students suffered with a lot of console printing before being introduced to a proper debugger. Not that I think this is a bad strategy - there’s many languages that lack debuggers (or a system you’re working on has none installed) so knowing how to debug code without a debugger is still a valuable skill.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "My school certainly did. Took an entire class on assembly language also... that gets into the nitty gritty of CPU instruction sets, IP and stack, and exactly what is going on when you run and debug a program.\n\nBut yea... there was a lot of \"real world\" programming that didn't get taught. We call that \"Independent Study\" here. :)",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Because debugging requires setting environments, environments usually are hard to set for everyone, and teachers are lazy-ass-non-operations skill",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Software Engineering was supposed to be pragmatic and Computer Science was supposed to be theory... but schools don't have enough industry experience in their lessons designs and so the programs are often used interchangeably which sucks.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I never had a class with debugging",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Because most are Computer Science not Software Engineer curriculums. CS preps you to do scientific research / become a CS professor. SE preps you to build software systems.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "În Romania we had close to zero exposure to debugging, this being at one of the best universities in the country :(",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "My understanding was that Computer Science degrees aren't Software Engineering degrees\n\nAny S.E. curriculum would have these elements (and more) that aren't taught well (or at all) in C.S. curriculums",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "\"schools\"? Most commenters here have taken this to mean \"university\" or \"college\", but IMO these days fundamentals should be taught in high school.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "The amount of people I work with who don't debug, don't know how to debug, and/or don't write code that can easily be debugged. They don't have a high output, but I don't understand how they get anything done.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I think the author is simply wrong in their premise.\n\nIf a person doesn’t know fundamentals of a given field, and particularly if a larger group doesn’t, teach those fundamentals. I’ve taught commas and semicolons to students almost every semester I’ve taught in college, and it’s neither time consuming nor hard.\n\nI remember suffering through this in junior high. Some people convinced the teacher that they had never heard of \"nouns\" before, like it was a completely new word to them, and the entire class was stuck doing remedial grammar. It was a WASTE OF TIME.\n\nIf this guy never heard any complaints by teaching commas in university, then they either weren't listening, or students simply didn't complain because they were happy to take an easy grade or just skip class to do something else.\n\nI know I didn't bother taking extra time to complain about my few poor professors individually.\n\nThey write for a few minutes then I walk around and look at their answers and offer a bit of individual feedback. Ideally, I have some chocolate and give the winner or sometimes winners a treat.\n\nLOL this guy is a professor? Sounds like a primary school teacher. Every single one of my university professors packed their lectures with content. Even in my softer electives (sociology, psychology, English), none of them ever used lecture time for students to do work. The closest we'd get is class debates, which is not equivalent.\n\nNow, I agree with some of his other points that the profs shouldn't be dismissive of students that need to improve their understanding of some fundamentals. But the solution for them is to get support outside of class, not to drag everyone else down to the lowest common denominator. The prof sounds like he is from the generation that came up with participation trophies and No Child Left Behind and \"can't give a kid a zero even if they didn't hand in the assignment\" mindset.\n\nAnd as for teaching fundamentals, my university didn't teach basic things like \"programming languages\". You were expected to pick that up on your own. Then again, this was a computer engineering program, not a software development program, so the focus was elsewhere. I could agree with the idea that some more formal instruction on debugging could be useful, but that's really what the labs and assignments are for, not the lectures. I don't think you can learn a lot about such things from a lecture. You learn by getting experience and doing it and needing to do it.\n\nI don't really get why this article was posted to programming. The article seems to barely mention debugging or anything really specific to programming, and debugging is only mentioned once in the article.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "It's not the school, the board is full of old, really old people.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I know when most people ask me for help I just show them how to debug properly, and then they don't ask for help as often. I feel people just don't see the value in it. I debug pretty much always even if it's just to understand a piece that I don't know helps me see the flow better and how things are being executed.\n\nI don't know as much about other IDE's but in Android and the Android Studio IDE, we can write conditional bugging. So say you have a bunch of elements and you just want to catch a specific one that is failing you can do like if myObj.title = \"corn\" inside of this debug line and it would only ever stop when it meets that condition. it is super powerful.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "At my school, it seemed like most of my perfessors had never worked in the industry or were 30 years removed. One professor was getting his doctorate while teaching. He was clearly a modern industry pro, and he was the best professor I had. He was the only one to teach any debugging.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "They definitely teach it. I question if it is very effective. I am also willing to challenge how effective and representative they can actually make it? Education and the IT world have some alignment. However it is far from perfect. My major shock was the difference in scale, different teams and way’s to access resources. It is hard to replicate this while also using individual grading. From group projects I remember there always being “passing with distinction”, “passing decently”, “Just passing” and “I don’t care” mentalities. You don’t want the motivated people dragging the other’s along to pass. You also don’t want the deadweights to drag the others down or even fail.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "My uni had a course on testing, and testing II as an elective. Most people didnt take the II course because there were other courses that were just more interesting. But the testing course covered debugging as well. It was sort of theoretical but we did have some basic exercises with python.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "They do, or at least they should. The issue is debugging doesn't have a recipe. You just draw lines in the code trying to separate what works from what does not until you reach a piece small enough that you can see the issue.\n\nThat can take many forms, and depending on what you debug can be done in different ways, it really comes down to practice, experience and finding what works for you and your style of programming.\n\nI do a lot of architecting so i am obviously biased, but my mantra has always been good architecture and good separation of concerns will make debugging much easier.\n\nThe biggest issue is when code is monolithic and bloated such that making one change breaks 3 other things down the line.\n\nImagine you have to write some code that needs to draw a square, you can try to do it all at once, or you can split it up:\n\n1 base class that can draw straight lines\n1 that can attach them perpendicularly ensuring right angles\n1 that can determine if 2 lines are the same length\n\nIf you need to debug and notice your lines are squiggly, it's obvious where the issue is and it should not affect anything else when you fix it. It's alo much easier to write tests for each and you can reuse the code down the road for other shapes.\n\nThat's probably more important to teach than actual debugging and i feel like this is what my school focused on a lot.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Debugging by David Agans is the best book I’ve read on the subject. All new grad hires are provided a copy to read and it’s probably more practically important than anything they learn in university.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "One year out of college I couldn't believe I wasn't taught to use a debugger. Or how to write and use unit tests. College would have been so much easier.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Ime college was more for the big concepts. I learned very little hands on programming, you’re expected to work and learn the basics on your own, and I don’t have a problem with that.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Debugging is kind of IDE dependent.\n\nIt’s a skill for sure, but it’s not going to be consistent across platforms.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "American universities aren't geared towards industry but rather research. They don't need to debug their stuff so how can they teach this art?",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "This is just the \"why don't they teach taxes\" question for computer science.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Any tldr",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Too busy teaching syntax and basic understanding of project structure and stdlib",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Best thing you can do when a dev comes on is just have them work on bugs.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Most schools do not even formally teach you English grammar or even how to write an essay properly. I suppose it is assumed to be self-explanatory.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Because \"Computer Science\" is not \"Software Engineering.\" Those are different things. And CS pretty much stops caring about Software Engineering once you exit the early 200-level courses. Once you grok Data Structures and OOP it's off to the Dijkstra's Algorithm and String Buffer Overflow attacks and networking and cybersecurity and ML and AI and Database \"Design\" and a never-ending list of stuff that aren't strictly \"Software Engineering.\"",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "If students were graded on critical thinking, few would graduate.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Too much switching between languages for each and every class.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "That would require professors to understand the fundamentals.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Because no one wants to learn fundamentals. Everyone wants to start top-to-bottom, learning exactly and only what is required to get a job.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "At least in my college the ones who decided to teach were the ones who didn't want to do work in the software industry. Mostly because they didn't cut the jobs.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_198vy6z",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://priyashpatil.com/posts/bootstrap-5-remove-unused-css-with-vite-and-purgecss",
    "title": "Bootstrap 5 Remove Unused CSS with Vite and PurgeCSS",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_198vuf7",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://levelup.gitconnected.com/microservices-are-they-good-or-bad-the-truth-is-it-depends-d648811d5ac8",
    "title": "Microservices: are they good or bad? The truth is, it depends",
    "points": null,
    "comments": [
      {
        "comment": "Screwdrivers. Are they good or bad?",
        "points": "13 points",
        "children": [
          {
            "comment": "Depends on the quality of the vodka, imo.",
            "points": "7 points",
            "children": [
              {
                "comment": "I'm more of a quantity kinda guy :)",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Yes",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I tested them, they make horrible hammers! The plastic in the handle chips. They are all hype!",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Are you making a simple problem complicated, or a complicated problem simple with [insert tech]?",
        "points": "3 points",
        "children": [
          {
            "comment": "In the case of microservices, they're mostly complicating a simple problem.",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "Dogmatism vs Pragmatism",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "The problem is microservices are not in fact 'decoupled' and any bugs that manifest in service #1 but the cause lies in service #2 are now hard to trace. This means any supposed maintainability benefits from using microservices are a myth. The only benefit is microservices are modules with clearly defined interfaces but its usually possible to get this benefit by using existing language encapsulation facilities and possibly a tiny bit of scripting (eg Java packages combined with package-private access modifiers and python modules). Modularisation is important because it's much more clear which parts are coupled to which other parts but microservices do this, then give a lot of unnecessary downsides for no reason.\n\nI would not recommend creating new services unless you have a performance or buildtime problem that is most effectively solved by splitting off a service.",
        "points": "3 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Did perd hapley write that title",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "The best of both worlds, a single code base and deployment for multiple services.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_198vd5y",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://successfulsoftware.net/2024/01/16/visual-vs-text-based-programming-which-is-better/",
    "title": "Visual vs text based programming, which is better?",
    "points": null,
    "comments": [
      {
        "comment": "None, since the question itself doesn't give any context.",
        "points": "8 points",
        "children": [
          {
            "comment": "The article is discussing the strengths and weaknesses of both approaches in general terms, rather than in the context of a particular problem.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "I'm split brain on this -- I have Jetbrains IDEs, but I still go back to good old Vi.\n\nIf you're on your own machine, IDEs are nice. But if you are working across clouds, or distributed programming, you can't beat the old text model. It's bandwidth efficient and works anywhere you've got SSH. Want to program on an IPad (I don't but some people do), it's best to use text-based tools.",
        "points": "-1 points",
        "children": [
          {
            "comment": "The article is more about boxes and arrows vs code, rather than code in an IDE vs code in vi/emacs. But I guess it is a sliding scale of 'visual'.",
            "points": "6 points",
            "children": [
              {
                "comment": "Do you prefer normal menus, or do you ask for the picture menu for illiterate people?\n\nDo you read normal books, or are you still reading Goodnight Moon?",
                "points": "-5 points",
                "children": [
                  {
                    "comment": "If I went to a country where I didn't speak the language, then I would prefer the picture menu.",
                    "points": "-1 points",
                    "children": [
                      {
                        "comment": "That's a little dumb and irrelevant. Unless you think it's likely that we'll have people who can't read programming computers.",
                        "points": "-1 points",
                        "children": [
                          {
                            "comment": "I think you missed the point.",
                            "points": "0 points",
                            "children": [],
                            "isDeleted": false
                          }
                        ],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Quote from article basically sums it up \"It makes 95% of things easy and 5% of things impossible\" and those 95% depends on a app. If we talk about some more complicated apps ten you can switch those numbers around.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_198v377",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://max.engineer/long-term-refactors",
    "title": "Long Term Refactors",
    "points": null,
    "comments": [
      {
        "comment": "This very sprint, I'm actually working on the last component in a 6 year project converting our codebase from PHP to React. We were able to meet business deadlines and provide new functionality during the refactor with some good architectural frameworks and development rules:\n\nBuild the refactored React application as a stand-alone app, but allow it to be integrated into the existing app seamlessly. As we converted each page into React, we replaced the original page with an iframe containing the React app. The React app was smart enough to know if it was embedded and do things like hide the nav menu (the legacy app had its own), get the login token from the PHP app, and make sure cross-app links worked as expected.\nNew functionality was built in React, but legacy pages remained in PHP until we either had time to convert them, or the business requested significant changes to a page.\nBusiness requests came first, and we only converted pages as we had time.",
        "points": "7 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Key points:\n\nThe article discusses the challenges of large-scale code refactoring in busy companies, emphasizing the need for a well-planned and inclusive approach. Traditional refactoring often results in rushed processes, feature freezes, and potential burnout due to lengthy and unexpected delays. The article advocates for a more intentional, long-term strategy involving the entire team from the outset, leading to numerous benefits such as reduced stress, improved ownership of the refactor, efficient pull requests, uninterrupted feature development, and gradual implementation reducing QA issues. The process, based on Chernyak's experience with multiple big refactors across different companies and teams, includes essential prerequisites like having an experienced software engineer with a clear vision and a diverse team. The method involves identifying refactoring patterns, preparing the codebase, creating clear and specific instructions, keeping refactors visible to the team, and integrating them into regular workflows. This approach, contrary to working in isolation, fosters team collaboration, reduces confusion, and allows refactoring tasks to be self-assigned, ensuring everyone is aligned with the decisions and direction of the refactor. However, it requires patience, as refactors can span years, and parts of the code may never be refactored, which is often justified. The article highlights the importance of collective decision-making and communication in successful long-term refactoring endeavors.\n\nIf you don't like the summary, just downvote and I'll try to delete the comment eventually 👍",
        "points": "6 points",
        "children": [
          {
            "comment": "Thanks for the summary; I had a quick read of the article to verify a few points.\n\nThe term I have anchored to is \"coding initiatives\" - long term refactors fits into this pattern - set long term goals, share with the team - socialise via documentation and PR templates - create regular reports or CI measures. Treat code quality as a measurable goal to game.",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Nice work on writing that up.\n\nI can confirm this approach has yielded success for me as well, on multiple occasions.\n\nOne interesting thing that has happened twice while doing these large refactors is that sometimes you have to increase complexity before you can refactor and eliminate complexity. This can be awkward and test your resolve and assertions that the refactor is truly justified.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_198v1fo",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://codeberg.org/Light-Project/secpass",
    "title": "Secpass - A simple password manager written in Python 3",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_198uh8h",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://youtu.be/1sOTTXlIhZo",
    "title": "Supercharge Your C# Code: Integrating Python using Python.NET",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_199495s",
    "subreddit": "u/SaladChefs",
    "dataType": "link",
    "dataUrl": "https://salad.com/download-high-end?utm_source=reddit&utm_medium=promoted-posts&utm_campaign=reddit-distributedcomputing-1&utm_content=golden-ad-suite",
    "title": "Level up your PC's potential with Salad and earn up to $180 per month. We connect your hardware to the world's most valuable computational projects. Your PC provides the power. You get the profit. Start Chopping today.",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_198u488",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.leetsolve.com/3-longest-substring-without-repeating-characters/",
    "title": "How To Find The Longest Substring Without Repeating Characters",
    "points": null,
    "comments": [
      {
        "comment": "It is faster to just use a std::bitset<128> to record seen characters, and move the starting position using a loop. You can do constant-time lookups and updates of the bitset instead of using a hash table lookup, and you don't need to use the heap at all. Sure, you get a nested loop, but it will be bounded by the character set size, and very fast with better branch prediction than a hash table lookup.",
        "points": "1 point",
        "children": [
          {
            "comment": "This assumes ASCII or other character sets where only 7 bits are important.\n\nNot that it's a bad assumption, just don't work in all cases. The original article used char anyway so they're probably assuming the same thing.",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_198u2jz",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://medium.com/techtofreedom/8-uses-of-sed-in-linux-e61678b04114?sk=37ff3317cbfd3e6c0efe41747bba966b",
    "title": "8 Uses of sed in Linux",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_198trmy",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.youtube.com/watch?v=2ArU1uE9QLo",
    "title": "Reinforcement Learning in 5 Minutes",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_198torj",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://stratoflow.com/why-is-java-so-popular/",
    "title": "Why Is Java Still Popular Even In 2024?",
    "points": null,
    "comments": [
      {
        "comment": "Why do people still write dumbass articles even in 2024?",
        "points": "135 points",
        "children": [
          {
            "comment": "People? 🤖",
            "points": "18 points",
            "children": [
              {
                "comment": "...that's a good point I hadn't considered.",
                "points": "2 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Don't people hate it to have to churn out BS articles that have no meaning for actual industry practitioners?",
        "points": "39 points",
        "children": [
          {
            "comment": "Or not. Even if you aren't in the industry and only do programming recreationally, they bring no value.",
            "points": "7 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "These titles are so annoying. They should be banned from this sub.",
        "points": "35 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Despite the hate it gets, Java is a decent language and is useful for a lot of things.",
        "points": "24 points",
        "children": [
          {
            "comment": "I'd go as far as to call it a great language. Not once have I been surprised by some undocumented side effect or ambiguous function in Java. The biggest downside to the language is type erasure, but at least that's all compile-time stuff.",
            "points": "9 points",
            "children": [
              {
                "comment": "That's funny because the biggest complaint people generally have about java is nullability everywhere and a fairly poor type system / missing language feature to express e.g. mutability. Also unchecked/runtime exceptions are the norm everywhere. You must read the documentation very carefully for all this information, but it is not always complete, or there can be a bug, or you think you know what a method does but ah, the docs explain something unexpected (e.g. `List.of(..)` is immutable - i know this now - but it was surprising the first time). These things lead to surprises quite regularly in my experience.",
                "points": "2 points",
                "children": [
                  {
                    "comment": "the language's syntax — is a small fraction of why java is so much popular up until this day. The ecosystem that is reliable, production proof and has tools/frameworks/libraries that solves 99% of business cases — is the main part. There are not alot of languages which have such a robust ecosystem.\n\nalso, Java language gets better, thanks to Kotlin, which emerged as an existential threat to Java and forced the java people to enhance the language.",
                    "points": "0 points",
                    "children": [],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              },
              {
                "comment": "The one thing Java has (or had? Haven't used it in years) is the requirement that a method indicates which exceptions it throws in the signature. Self documenting code should be more universally required.",
                "points": "1 point",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Python is older than Java. They are both good languages (mostly) that are still being worked with and worked on.",
        "points": "19 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Because people still use it, duh.",
        "points": "6 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Java's still hot in 2024 because it's like a Swiss Army knife of programming – does everything from websites to robots, has tons of ready-made parts, and rarely breaks. Millions know it, so finding help is easy. Plus, it keeps getting better and pays well, making it a safe bet for both companies and coders. So, Java's not going anywhere any time soon!",
        "points": "8 points",
        "children": [
          {
            "comment": "The millions know it part is v important and frequently missed. When choosing a tech stack you always think about how easy or hard it will be to staff. I remember around 5-6 years ago being on a new team that was trying Node.js and it was frequently mentioned how hard it was to find people with skills in Node/Angular.",
            "points": "2 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "The article isn't badly written, but it's very generic and more of an overview of Java Language features. It doesn't really answer the question on why it's popular.\n\nIn general titles like \"Why is Java popular/dead/hated/bad/slow\" etc, often don't analyze anything. Regularly that are just generic, bashing without arguments or AI generated. That's why people get so annoyed.\n\nBack to the question. Often there is too much emphasis on technical factors why a programming language becomes popular/successful. There are many others. I asked myself this question not specific to Java, but in general, and wrote a short blog series about it. There I came with a list of around 19 factors that can contribute to its popularity, most are not technical.\n\nLast thing to say: Please stop citing Tiobe",
        "points": "8 points",
        "children": [
          {
            "comment": "\"generic\" is one way of putting it. It reads like something generated for SEO purposes.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "As apposed to what? If your domain needs a statically-typed language, your options are limited. There are obscure choices that are arguably better, but you'll have a harder time finding devs who know it.\n\nOn the embedded and high-performance side you have C , C++, and Go; and on the CRUD/biz side Java and C#. If you can't stand MS, you don't want C#, leaving Java for CRUD.\n\nI personally can't do without optional named parameters, like what C# allows but not Java. The alternatives to emulate them in other languages are not the same. ONP's make shop API/libraries much easier to extend and tune. Microsoft is annoying, but you'll have to pry ONP's from my cold productive fingers.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Java's popularity probably stems from its wide usage and long history in industry, despite some valid criticisms about its verbosity and complexity.",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I use Clojure and really appreciate the rock solid JVM and huge ecosystem of libraries. I can’t see Java going anywhere.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "ava has been a cornerstone of the programming world for over two decades. Its “Write Once, Run Anywhere” philosophy made it a go-to choice for developers across various platforms. From mobile apps to enterprise-level systems, Java has been a reliable workhorse.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Same reason COBOL is still around, legacy stuff and cheap companies that will keep kicking the can forward way into 2050'",
        "points": "-20 points",
        "children": [
          {
            "comment": "Everything is wrong about this statement. Comparison of Java to Cobol: First is in active development and in broad use, second is really legacy. Java devs are not cheap, I don't know a single ecosystem as broad as the Javas for enterprise applications and the dev experience of, for example, Quarkus is still unmet in any other language.  Java and it ecosystem is mature,  so JS kiddies think it's outdated just because there is not a new revolutionary framework every week.",
            "points": "11 points",
            "children": [
              {
                "comment": "I'd wager Java is still in growth in absolute terms as well. Perhaps it's losing popularity to some other languages but that doesn't mean it's in decline.",
                "points": "7 points",
                "children": [],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          },
          {
            "comment": "Not exactly \"cheap\" but entire businesses that are seemingly immune from disruption that have their entire business automated via Java code for 15+ years - and have no need to modernise provided their customers continue to pay the bills.",
            "points": "3 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "It's a lowest-common-denominator language. It's not going to budge for quite some time.",
        "points": "-2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "I’ll tell you why it gets used in some places…. Because Java developers are perceived as cheaper than many other languages because the supply is higher. For decades everyone learned Java in college and the more recent trend towards Python as the first language hasn’t been there long enough to overtake it.\n\nI have product architects who will tell me I should switch to Java because I can hire people for less while ignoring many many other reasons to use Go.",
        "points": "-9 points",
        "children": [
          {
            "comment": "false,\n\njava developers are predominantly better paid",
            "points": "7 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Java is the COBOL of the 21st century. A lot, and I mean a lot, of legacy applications from the golden shower age of Java. Back in the early 2000's Java was the ultimate square peg that everyone was trying to drive into every hole.\n\nI was an employee of the big red back then and suffered through years working with the Red Pile Stack.",
        "points": "-13 points",
        "children": [
          {
            "comment": "java seems to be heavily used for new stuff too. so it would be unfair to call it cobol. (most new stuff i see around me from people i know in different companies where i live are java/kotlin, then js/python/swift/c++ for specific stuff, then rust).",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Bla bla bla and I'm still getting paid for it at the end of the month",
        "points": "0 points",
        "children": [
          {
            "comment": "still getting paid for it\n\nFTFY.\n\nAlthough payed exists (the reason why autocorrection didn't help you), it is only correct in:\n\nNautical context, when it means to paint a surface, or to cover with something like tar or resin in order to make it waterproof or corrosion-resistant. The deck is yet to be payed.\n\nPayed out when letting strings, cables or ropes out, by slacking them. The rope is payed out! You can pull now.\n\nUnfortunately, I was unable to find nautical or rope-related words in your comment.\n\nBeep, boop, I'm a bot",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Platform Independence:\n\nJava's \"Write Once, Run Anywhere\" (WORA) philosophy allows developers to create applications that can run on any device with a Java Virtual Machine (JVM). This platform independence is a significant advantage.\n\nRobust and Mature Ecosystem:\n\nJava has a vast and mature ecosystem with a wealth of libraries, frameworks, and tools. This robust support system simplifies development, reduces time-to-market, and ensures stability.\n\nStrong Community Support:\n\nJava has a large and active community of developers. This community contributes to ongoing language enhancements, provides support, and shares knowledge, fostering a collaborative environment.\n\nEnterprise Adoption:\n\nJava has been a go-to choice for enterprise-level applications for many years. Many large-scale systems and mission-critical applications are built on Java, contributing to its continued relevance.\n\nVersatility:\n\nJava is versatile and can be used for various types of applications, including web development, mobile applications (Android), enterprise software, cloud computing, and more. This adaptability makes it a practical choice for diverse projects.\n\nBackward Compatibility:\n\nJava has a commitment to backward compatibility, ensuring that older Java applications continue to run seamlessly on newer versions. This stability is crucial for businesses that rely on long-term software solutions.\n\nSecurity Features:\n\nJava incorporates strong security features, including a secure execution environment (sandbox) and automatic memory management, which helps in preventing common programming errors that could lead to security vulnerabilities.\n\nPerformance Optimization:\n\nOver the years, Java has seen performance improvements through updates and optimizations. The introduction of features like the Garbage Collector and Just-In-Time (JIT) compilation contributes to efficient and high-performance applications.\n\nAdoption in Emerging Technologies:\n\nJava is adapting to new trends and technologies. For example, it has played a significant role in the development of Big Data technologies (Hadoop, Spark) and is actively used in cloud computing environments.\n\nContinuous Evolution:\n\nThe Java language is continuously evolving with regular updates and new features. The language designers are responsive to industry needs, ensuring Java remains relevant and modern",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_198til5",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.infoq.com/news/2024/01/slack-cell-based-architecture/",
    "title": "Slack Migrates to Cell-Based Architecture on AWS to Mitigate Gray Failures",
    "points": null,
    "comments": [
      {
        "comment": "Here's the TL;DR version (although the article actually is worth a read):\n\nAnd so we finally arrive at our cellular architecture. All services are present in all AZs, but each service only communicates with services within its AZ. Failure of a system within one AZ is contained within that AZ, and we may dynamically route traffic away to avoid those failures simply by redirecting at the frontend.\n\nEdit: Sorry, the actual Slack blog post is worth a read, not the garbage infoq article this post links to.",
        "points": "5 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_198t08a",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://winand.at/newsletter/2024-01/clouds-bring-rain",
    "title": "Big News in Databases — Review 2023",
    "points": null,
    "comments": []
  },
  {
    "id": "t3_198stc5",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://youtu.be/wycZDewUi-8",
    "title": "The Rise of Gaming Tech and the Career Skills Needed",
    "points": null,
    "comments": [
      {
        "comment": "Never thought I'd see gaming become \"enterprise\".\n\nGod have mercy on all our souls.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_198sdax",
    "subreddit": "r/programming",
    "dataType": "link",
    "dataUrl": "https://www.forrestthewoods.com/blog/dependencies-belong-in-version-control/",
    "title": "Dependencies Belong in Version Control",
    "points": null,
    "comments": [
      {
        "comment": "At the extreme end this is only feasible if you are targeting a single well-defined platform, and even then its iffy. Thing to consider is what things are you committing as binaries and what will you bootstrap from source? Ultimately you need to have some binaries somewhere to bootstrap anything.\n\nWorth noting that this is basically how major Linux distros operate; they are fully self-contained and their repos contain everything needed to compile themselves. So if you actually fully embrace a distros packaging tools, you are essentially getting this same effect. NixOS is fancier realization of that idea.",
        "points": "9 points",
        "children": [
          {
            "comment": "I only skimmed the article but I don't think it's advocating for versioning everything by source and disallowing binaries.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "TL;DR: I can't get opensource projects to compile, therefor my local practice for just myself and one platform would suit open source projects.\n\nThe article makes zero sense.",
        "points": "9 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "So in beginning he wants  \n\nA user should be able to perform a clean OS install, download a zip of master, disconnect from the internet, and build  \n\nbut then in his dream vcs he suggests\n\nThis is near instantaneous as files are not prefetched. The user then invokes the build script. As files are accessed they're downloaded  \n\nSo which one is it?",
        "points": "2 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Here's the gist:\n\nThe post advocates for including all project dependencies, such as source code, binary assets, third-party libraries, and compiler toolchains, in version control. This approach simplifies the build process, making it as straightforward as cloning a repository and running a build command without needing additional tools or downloads. The author argues that this method enhances usability, reliability, reproducibility, and sustainability of projects, demonstrated through a C++ demo. However, current version control systems like Git have limitations in handling large files and repositories, necessitating alternative methods like containers or improvements in version control software. The feasibility of this approach may depend on the project and language, and issues like licensing and updating dependencies are discussed as potential challenges.\n\nIf you don't like the summary, just downvote and I'll try to delete the comment eventually 👍",
        "points": "8 points",
        "children": [
          {
            "comment": "Imagine this, even toolchains in SCM. Absolutely horrible. I wouldnt work for any company doing this.",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "For the use cases that I'm familiar with, containers do solve the build issues.\n\nYou can make your own container image with all (and only) your project dependencies inside, at the right version, and by inside I mean you don't have to pull a base image and install stuff wasting time and resources, but baking everything in the image. Once you have the container image, which is distributed over a container registry and uniquely identified by a hash, you can write your \"recipe\" of how the build should happen, with that specific image, and that \"recipe\" is the thing that you commit.\n\nIn the git repo, you now have all the sources, and your recipe. The container that spawns, will mount the folder containing the sources (those shouldn't be baked inside). With this you can have pretty reliable builds I think.\n\nMy snarky opinion is that Docker and friends primarily exist because modern build systems are so god damned fragile that the only way to reliably build and deploy is to create a full OS image.\n\nI think the idea is the reliable deployment, but the container technology has a huge amount of applications, and suits our build use case as well. And of course images should be as small as possible; Docker/Podman images are small on purpose, then of course everybody can build the image that suits them better. For full OS images that resemble more little VMs than containers, there are projects like LXD.",
        "points": "1 point",
        "children": [
          {
            "comment": "That said, I'd like to see that in practice.\n\n> NGVCS is obviously a dream. It doesn't exist today. Actually, that's not quite true. This is exactly how Google and Meta operate today. Infact numerous large companies have custom NGVCS equivalents for internal use.\n\nCan you share any references supporting this?",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "Obviously a windows guy, who missed three decades of package management, distros and devops. And producing code that quite no distro maintainer ever really wants to cope with.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "The solution to this is CI/CD\n\n( And making dependencies specific (before a release), and caching all dependencies in your own package repository so they can't ever disappear )\n\nWith the solution in the article you STILL need CI/CD to check whether you actually got everything in version control. And if you got CI/CD.... your OG problem is already pretty much gone.",
        "points": "4 points",
        "children": [
          {
            "comment": "I’m not sure I understand how CI/CD is relevant here",
            "points": "4 points",
            "children": [
              {
                "comment": "Good CI/CD makes sure everything builds on a build agent with a known (documented) config. It also makes sure you ACTUALLY committed everything.\n\nPutting everything in the repo isn't a magical solution which forces you to put everything correctly in the repo, but CI/CD does....",
                "points": "-1 points",
                "children": [
                  {
                    "comment": "I don't this this is limited to CI/CD. But, as you say, good CI/CD should mean that your build is automated, documented and contains everything it should.",
                    "points": "0 points",
                    "children": [
                      {
                        "comment": "If you aren't doing this in a continuous way you will lose time or screw up.",
                        "points": "0 points",
                        "children": [],
                        "isDeleted": false
                      }
                    ],
                    "isDeleted": false
                  }
                ],
                "isDeleted": false
              }
            ],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "We also do store all our dependencies together with the project. This way we can easily revert to a reproducible state, even when it is 10 years old, with a few mouse clicks. Helps a lot when trying to locate an elusive issue.\n\nBut we do not store toolchains, as they can get really big. Everyone usually just installs all of them. Which ones to use is defined inside the build scripts.",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "If you can’t afford a jfrog or other style of proxy caché then sure\n\nI’ve seen one instance where MSFT unpublished an exchange online jar, broke all around. The ci system had a cache that got wiped with a rebuild and the only version was found on a developer’s laptop.\n\nFun days",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_198s7d5",
    "subreddit": "u/HeroWarsDominionEra",
    "dataType": "link",
    "dataUrl": "https://www.hero-wars.com/?delayedsignup=true&nx_source=adx_reddit.{{AD_NAME}}&cp=-.ag-{{ADGROUP_NAME}}.agid-{{ADGROUP_ID}}.aid-{{AD_ID}}.cid-{{CAMPAIGN_ID}}.post-{{POST_ID}}.rdt_click-{{CLICK_ID}}",
    "title": "Many failed before. Will YOU complete the trial?",
    "points": null,
    "comments": [
      {
        "comment": "A black hole is a region of spacetime where gravity is so strong that nothing, including light and other electromagnetic waves, has enough energy to escape it.[2] The theory of general relativity predicts that a sufficiently compact mass can deform spacetime to form a black hole.[3][4] The boundary of no escape is called the event horizon. Although it has a great effect on the fate and circumstances of an object crossing it, it has no locally detectable features according to general relativity.[5] In many ways, a black hole acts like an ideal black body, as it reflects no light.[6][7] Moreover, quantum field theory in curved spacetime predicts that event horizons emit Hawking radiation, with the same spectrum as a black body of a temperature inversely proportional to its mass. This temperature is of the order of billionths of a kelvin for stellar black holes, making it essentially impossible to observe directly.",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....All this squares make a circle....",
        "points": "1 point",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Wait, you actually opened the comments? Are you stupid?",
        "points": "3 points",
        "children": [
          {
            "comment": "Just to see whether I'm alone or not...",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "they are",
            "points": "1 point",
            "children": [],
            "isDeleted": false
          },
          {
            "comment": "I'm that lonely and bored...",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "The world would be such a better place without you people in it.",
        "points": "1 point",
        "children": [
          {
            "comment": "You start!!!!",
            "points": "0 points",
            "children": [],
            "isDeleted": false
          }
        ],
        "isDeleted": false
      },
      {
        "comment": "this you?",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "nice",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "son ellos",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "with many on the title this is a juicy clickbait .",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "who is upvoting this why",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Wasn't expecting comments on this",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "Techbible is your go-to tech community. Ask questions and get expert answers on all things SaaS. Stay updated on the latest tech news, discover trending tools, and share your tech stack with the world. Don't Forget to try it out.\n\nhttps://techbible.ai/",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      },
      {
        "comment": "wow",
        "points": "0 points",
        "children": [],
        "isDeleted": false
      }
    ]
  },
  {
    "id": "t3_199495s",
    "subreddit": "u/SaladChefs",
    "dataType": "link",
    "dataUrl": "https://salad.com/download-high-end?utm_source=reddit&utm_medium=promoted-posts&utm_campaign=reddit-distributedcomputing-1&utm_content=golden-ad-suite",
    "title": "Level up your PC's potential with Salad and earn up to $180 per month. We connect your hardware to the world's most valuable computational projects. Your PC provides the power. You get the profit. Start Chopping today.",
    "points": null,
    "comments": []
  }
]