[{"text":["How to Share State Between Browser Windows"],"points":0},{"text":["Question — How to Use If-Then Statement to Add Valies to a CSV File (R and Python)"],"points":0},{"text":["Data Structures and Algorithms In Java (DSA Masterclass)"],"points":0},{"text":["The CAP Theorom Twelve Years Later: How the \"Rules\" Have Changed"],"points":0},{"text":["The Role of CAP Theorem in Modern Day Distributed Systems"],"points":0},{"text":["Playing Windows 98 error sounds when a build fails"],"points":0},{"text":["Voxos.ai – An Open-Source Desktop Voice Assistant"],"points":0},{"text":["Starting my career again as a junior engineer"],"points":0},{"text":["Humans Are Shit — Replace Them With Tools"],"points":0},{"text":["Please review the initial draft of my first open source project","All in all, it looks very nice.I would recommend you to include the text in this post to the project's readme (I was about to ask what's fishbowlapp after reading the repo).Classes like DriveType could be defined as enums.Type annotations could be a nice addition.Maybe you'll be able to attract developer among the website community easier than in python."],"points":0},{"text":["Windows support in Crystal 1.11","As someone who really likes ruby and also likes finding type errors before runtime, Crystal is super interesting but I haven't tried it. How does it compare to some of the efforts to bolt static typing onto ruby? Outside of type stuff, does crystal have other advantages?"],"points":1},{"text":["Face2ID - Transform Biometrics to UUID Fast","Is this even possible? Any function from a connected space (face pics for example) to a disconnected space (like the finite set of UUIDs) is either constant or discontinuous, so two very simmilar faces (or pics of the same face) are gonna map to different UUIDs"],"points":0},{"text":["Monoliths, microservices, and serverless aren't what you think they are","we have an architecture like monolith C and it actually works \"surprisingly\" well. The biggest limitation is the single point of failure postgres, but as we have migrated to other datastores, the mere fact that it's the same codebase running in a bunch of different modes/ways does not hinder us [much]. it is tricky right-sizing test suites, making sure the right tests run under the right circumstances, but the same exact complexities still exist with microservices. If anything, integration testing across microservices is more difficult than what we deal with today.","Thank you! Yes, sometimes a series of small, single-purpose machines still is coupled tightly to their back-end database service. The mere format of the single-purpose machine makes no statement whatsoever about how tightly or loosely it couples to other components.It is a major point of critique to the onslaught of microservices that got created under the pretense of easier maintenance: no, you didn't solve the coupling, so any change to your database model will still require a change in your clients. It doesn't matter whether that's a monolith or a myriad of small apps.","Before chiming in, look at the 3 diagrams which ask:- Which is a monolith?- Which are microservices?- Which is serverless?","I think that's conflating services with code components.A monolith code can be loosely coupled, I wrote tons of those.Serverless is just running code on machine managed by the cloud provider.On a regular monolith, an user can use the whole app while the server code executed won't leave the server machine (except for db calls).When your internal logic starts to do IO to process a single entity (job/user), you fo further from the monolith and closer to the microservices.Yes, I think what differenciate the 2 are IO calls.","What do i think they are?","honestly its a bit pointless to discuss. for example, serverless is stated as \"The abstraction of infrastructure management makes it serverless.\"but obviously infrastructure management can be abstracted to various degrees, and you still have to think at whatever level of abstraction you decide on for yourself. so how is this useful?same for microservice; \"Loose coupling and cohesion make it a microservice.\"well, packages modules and even classes and functions can be loosely coupled. and no one can agree on what constitutes \"loose-enough\" coupling anyways; its more that we can identify when things are not loosely coupled enough and must bear the cost. so again; what is really being said here, how is it useful and how does it help inform our decision-making as developers?finally for monolith we have; \"Tight coupling makes it a monolith.\"this is probably the most confusing one because it means if you have a bunch of well-factored packages and modules you actually don't have a monolith, even if they're all bundled up into a single artifact and deployed together. why is that a useful mental model?overall, what I have noticed in this kind of technical is that there's almost no use trying to \"generalize\" anything like this in tech. whats good for me may be bad for you, and vice versa. anything that is \"true enough\" for every situation is generally too vague or not useful. we need to be more specific.Rather than trying to pin down imprecise language whose meaning needs to be specially interpreted in specific contexts, its better to study case studies similar to the kinds of projects most relevant to us as developers, as well as our own projects, and try and improve upon past mistakes.","Someone told me, \"You can’t scale a monolith horizontally. You can only scale it vertically.\" That seems silly because I’ve scaled huge monoliths across hundreds of small servers.That pisses me off to no end. I can staple a photograph of the \"scale out\" settings page in Azure to their forehead and they'll still repeat that lie.","I feel like everyone who complains about microservices were not given a working budget to include monitoring, auditing and orchestration (and if possible A/B or canary deployment strategies), yeah without those microservices are impossible"],"points":64},{"text":["CFP is open for POSETTE: An Event for Postgres 2024, formerly Citus Con","Hi folks, Eren from POSETTE team here,I wanted to share that POSETTE: An Event for Postgres 2024 started accepting proposals for talks this year. POSETTE (Postgres Open Source Ecosystem Talks Training & Education) is the new name of Citus Con and it is a free and virtual developer event organized by the Postgres team at Microsoft, now in its 3rd year.It's a great opportunity to share experiences for first time speakers as well as seasoned speakers. All talks will be pre-recorded and livestreamed during the event with live speaker Q&A. The CFP is open until April 7th and the virtual event will happen on June 11-13.You can get more information and submit your talk proposals at https://aka.ms/posette-2024I highly encourage you to submit your talk proposals if you have any stories, perspectives, tips or expertise to share about anything related to PostgreSQL. Please let me know if you have any questions or comments. Thank you."],"points":1},{"text":["From 0 to 1 MB in DOS","The 80286 has no MMU. The MMU is for paging, and was introduced with the 80386. The 80286’s goop is a couple extra adders and comparators, basically ALUs, the shadow and descriptor regs, and a bunch of microcode.Also, VM86 made it possible to run even one DOS program at a time in pmode. You could run some, very limited sorts of DOS programs unmodified in pm16, in theory, but any attempt at supporting access to MMIO &c. or huge pointers bogged down immediately, and any use of real-mode BIOS or what have you required a full CPU reset—once in pmode, you had to reset somehow to exit, and if everything went right, you could get the BIOS to vector back rather than bootstrap normally. (Even LOADALL couldn’t fix that.)Later versions of DOS could load-high themselves, although maybe MemMaker did more than that.It also bears mentioning that there can be memory mapped in the MMIO region under 1 MiB—e.g., an extended BIOS data area (EBDA), to complement the normal BDA at 0x400. Often these either ate a bit of memory at the top of conventional memory, or used mobo regs to map some of the RAM that’d otherwise be placed >1 MiB into the 0xD0000…E0000 range.And the >1-MiB map may have holes for MMIO or BIOS around the 16 MiB boundary (80286 max address), the 4 GiB boundary (80386–P5 max address), at the 64 GiB boundary (P6+ max address in 32-bit mode), etc. (48+ bits now supported), so the memory map kinda repeats at each expansion.Unreal mode was a technique on the 80386+ where you popped into pmode, set ES SS DS FS GS to flat-map the 4-GiB address space, and return to real mode. As long as you don’t reload the seg regs, their shadow descriptors remain unchanged, and you can access any 32-bit address through them. However, if a segreg is reloaded you have to reenter pmode to restore it.Because XMS was kinda shitty but DOS per se was still useful, it became common to use DOS extenders (like DJGPP’s) that could run mostly in pm32 but hop into VM86 for use of DOS/BIOS. These were very common for games. On the API side of things, DPMI was offered as a means of playing nicely with DOS, HIMEM.SYS (which actually emulated DOS in VM86 mode), and Windows when running in pmode.Finally, most BIOSes for 80286 or later CPUs do offer a means of copying sub-64-KiB blocks of memory to/from the extended area. It’s slow and limited, but it works in a pinch."],"points":1},{"text":["Perf is not enough","\"Test your software the way customers actually use it\" seems obvious but apparently even Google forgets it."],"points":0},{"text":["Handling external API errors: A resumable approach"],"points":0},{"text":["C and returning values quickly or safely. But not both","What a bullshit, there is no reference in C.Pointers is just a variable which stores address. Everything is passed by value in C, even variables with address, aka pointers.Moreover, pointer size sometimes larger than some builin types, like char, short, int. Pointers takes up to 8 bytes (on 64 bits systems, and 4 bytes on 32 bit systems)","Passing by value is slower, since a new variable has to be createdMy understanding was that passing e.g. int vs int* would be the exact same runtime cost. What does it mean \"a new variable has to be created\" in terms of assembly? Copying something larger than word size would take longer, but if something is <= word size, shouldn't it be identical to the cost of pass-by-pointer?","This is slower, and consumes more memory during the process of making all these copies, BUT it’s far, far safer.What is frustrating about this is if C had scopes you could just tell (a good) compiler \"screw the ABI do the stack math for me, avoid copying, and just make this fast\" and it will, flawlessly... if you're using (modern) GCC/LLVM. They'll even make the debug information looks nice when everything is inlined.This works GREAT... except it is non-standard so when you need to develop C for something that isn't a modern ARMv8/x86_64 CPU you can't use it. Which is most of C development.So even if this did get standardized tomorrow, it wouldn't appear on your PICs devboard for 10-15 years.","I find the arguments very weak.Passing pointers? Authors concern is that pointers could modify content or be of the wrong time, both of which the compiler will prevent by const and type checks. The real danger is pointers pointing to null or invalid locations - or more subtile two pointers pointing to the same (or overlapping) region.Passing a list of pointers vs passing a pointer to a struct has the major benefit that this struct now becomes easily maintainable. Imagine you expand the struct by one more field.Returning static memory? Yes it’s fast, and valid. No, with const the user cannot modify the content. All good? No. What’s more dangerous is that another call to the same function may modify the static values, and hence the values you use somewhere else in the program (since the goal was to avoid copying, right?)Returning structs is as fast as a copy. The struct is created on the stack, there is no cost in memory allocation. Adding 16 or 1m to the stack pointer is the same speed. The caller will later then need to copy it from the stack to his variable (likely also on the stack). but only once."],"points":28},{"text":["On-demand JSON: A better way to parse documents?","If your requirements are such that you feel that you have to implement on-demand JSON parsing your time would probably be better served moving to a structured binary format instead."],"points":0},{"text":["Gleam's New Interactive Language Tour"],"points":0},{"text":["How we handled our server downtime (managing automated processes/CRON)","Barely has any usefull information within \"writing\""],"points":0},{"text":["A Rust RPC framework with high-performance and strong-extensibility for building microservices"],"points":0},{"text":["Sourcehut network outage post-mortem"],"points":0},{"text":["Run Lisp machine emulator on Linux"],"points":0},{"text":["Build your ML Ops platform on Postgres"],"points":0},{"text":["PathFinding Visualizer in Python and Tkinter. Source code is in the description."],"points":0},{"text":["ex google engineer on how to build software as a team of one","Disclaimer: I'm a startup founder, mainly doing Devops and AI today as the company grew.A lot of his issues could be fixed by using docker [or any VM based service]. He repeats like 10 times in his talk the replicability between prod and local like it was some exceptional property. Should he know about docker/VM he wouldn't have used that as one of the key values, just doesn't make any sense.Maybe I'm just a devops and can't understand how is it possible to give a talk with such confidence and lack about the basic skills of working with and deploying a software, it's actually impressive.Looks like a case of an overconfident dev that create unmaintanable architecture even for himself 6-12 months down the line.Don't get me wrong for your personal project you can do all that just fine. For anything else that is supposed to live for longer, these kind of mentality and style of working will bite you in the ass sooner or later.PS example: It's because of these kind of guys that some companies are stuck using Ubuntu 10 in 2024 and can't update to install newly needed libraries or features, because every damn thing is interlinked so you're forced to rebuild the whole damn thing from scratch on a new server to use a newer OS and it's bound to be a nightmare of bugfixing for months.\"works on my machine\" type of guy"],"points":4},{"text":["How to Read and Remove Metadata from Your Photos With Python"],"points":0},{"text":["The Risks of API Integration and How to Mitigate Them"],"points":0},{"text":["One PID to Lock Them All: Finding the Source of the Lock in Postgres"],"points":0},{"text":["BehavEye: Advanced dynamic malware analysis tool"],"points":0},{"text":["The magic triangle of software development","Just one triangle? Have you not heard of the conjoined triangles of success?","Speed and quality aren't opposite corners and the iron triangle doesn't always hold for software, especially if you measure development speed over the lifetime of a piece of software. High quality software is usually easier to change and therefore you can move faster.","Seems silly. One can increase the scope, maintain the quality and speed, by simply working for longer. I.e. the triangle doesn't take duration into account.","This article can be represented by a singular point at the “speed” vertex.","\"Better, faster, cheaper. Pick 2\"","Honestly why even bring quality into the equation. X features in Y time is how it works. It's not up to management to weigh in on how the work is done, or to what quality. Only what is needed on what timeline to what degree of criticality."],"points":43},{"text":["Making your apps error proof with Remix.run","I don't know what your software does, but I do know it hasn't figured out how to prevent all errors."],"points":1},{"text":["The State of WebAssembly – 2023 and 2024","When do you anticipate it being reasonable to use python say, instead of javascript, to build a progressive web app?"],"points":0},{"text":["Why Kubernetes? Focus on the API, not the servers"],"points":0},{"text":["Symlinks for repeated files in multi-repos"],"points":0},{"text":["How does public key encryption work? C# Example Simplified - Essential Software Development Career + Technical Guide","You generate a symmetric key, bulk encrypt the data then wrap that key with the recipient's public key. Send the ciphertext and wrapped key to recipient where they unwrap the symmetric key with their private key and bulk decrypt the data."],"points":0},{"text":["JavaScript Promises Training","I hope you like the summary below:Practice working with promises through a curated collection of interactive challenges. This repository provides a platform to refine your skills, complete with automated tests to to give you instant feedback and validate your progress.If you don't like the summary, just downvote and I'll try to delete the comment eventually 👍"],"points":0},{"text":["So Your Technical Debt Has Gone To Collections","We don’t really know what these servers do. Authored by people no longer with the company. Somehow also mission critical servers.This reads as a company that has more problems than just tech debt.If you have \"mission critical\" servers that are not owned by any team, it means you have \"mission critical\" business processes that are not owned by anyone. Either the company is in a known unhealthy state, and actively trying to resolve this, or management is asleep at the wheel.","Is it unfair to call this technical debt that had gone to collection? You didn’t know you were relying on a legacy service until you were informed you had to take action, and then you took action.","It's not clear to me whether the issue was that the IaaS provider didn't upgrade their dependencies or the Author's company didn't upgrade the IaaS service. Either way, it is a bit surprising they got no help from their IaaS provider.I am a bit disappointed there aren't real lessons here for the rest of us, it is just a story. I remember when the log4shell exploit came out. We had 0 days to fix it and nearly every system we had was vulnerable. Thankfully, the maintainers created a drop-in replacement, so the hard part was mostly finding everything that was vulnerable.","Imagine we have an electric network, but the electric company is free to decide that they can change the voltage and/or phase and/or frequency of the electrical supply at will when they want, and it's your duty to adapt quickly all the electrical appliances you have at home. If you get it wrong, you can absolutely start a fire.This is how it is to be a software developer. Except that these change occur more or less every few days.","My takeaway after browsing this while eating lunch is that they learned the wrong lessons. Know where in there did he touch on:How they screwed the pooch with unmaintained servers being used in production. How do you not have at least a spreadsheet of servers/services/etc?How they (essentially) ignored the initial warning, because they didn't think it fit them. (i.e. assuming Google was in the wrong, not that they were)Apparently have no internal process to manage when an employee leaves/is reassigned. Unfortunately common in smaller companies, though by no means limited to them.I'm sure there are more big issues I missed, but lunch is over."],"points":98},{"text":["API pagination with FastAPI and SQLAlchemy"],"points":0},{"text":["Exploring Pandas for Time Series..."],"points":0},{"text":["5 Levels of Using Context Managers in Python"],"points":0},{"text":["Programming the Web with HyperLANG & HyperCLI","Quick summary:Mike introduces HyperCLI, a command-line tool serving as a generic client that can consume popular Hypermedia API media types such as Siren, HAL, Collection+JSON, etc.If you don't like the summary, just downvote and I'll try to delete the comment eventually 👍"],"points":1},{"text":["My secret for growing from engineer to CTO","Even after googling you, I have no idea what you are CTO of. Also, freelancing in no way prepares you for a CTO role. It's kinda the opposite of being a CTO in a lot of ways (no ownership, no need to make decisions with the long term in mind, etc).","Wake me when you have a “secret” that doesn’t require 12+ hour days.","Money laundering","I bet it was not definitive aspect. There are way too many freelancers who aren’t cto and ctill want to be. It’s like saying that eating cucumbers made me a cto only because I value cucumbers and did become a cto.In practice it’s almost always about being in the right place in the right time and be ready to take a shot. Will freelance help harnessing those aspects? Maybe. Are there better ways that freelance to recreate those aspects? Most probably.","Why would you want to","You get asked that question regularly? By who? Coworkers?"],"points":52},{"text":["How to choose a programming language in 2024","Step 1: Use the one you like the most. Step 2: There is no step 2."],"points":1},{"text":["Best Practices for Authentication and Authorization in API"],"points":0},{"text":["How bad is LLVM *really*?","So the bad thing is speed, the time it takes to compile. That doesnt make LLVM itself bad.It is not like its full of bugs and stuff like that, or have weird behavior or undefined behavior that is really different to gcc.","LLVM isn’t slow if you consider what you are getting with it.   In fact it is rather impressive and on modern hardware not a problem.   People that complain about LLVM should get off their Z80’s and run modern hardware.","The main issue is backend performance.Has anyone actually profiled it?","\"It's really focused on C/C++ and other languages may have problems if they want behavior that doesn't agree with C/C++ behavior. Here are some small examples.\"Saved you a click."],"points":46},{"text":["Spring Boot and Apache Camel Integration"],"points":0},{"text":["Stop idolizing a small set of companies that have problems no one else actually has...","I joined a VC backed startup that had a bunch of ex Amazon engineers.The system was so over built for what it was doing.  Running separate web services and key rotation on interservice API calls that could have just been 1 service.  Debugging was difficult because you had to run everything.It was super complicated.  With the CTO's blessing, I squashed it down to one monolithic service and we never looked back.  Trying to solve every problem assuming Amazon, FB, Google, Netflix scale is the root cause of a lot of the useless complexity we see in software engineering today.","There used to be a group that was trying to push our entire company into a monorepo \"like Google\". Every codebase for every product/service, including ones that have nothing to do with each other from completely different industries/purposes.They didn't seem to realize that Google (and other companies that do this) invest heavily in teams that just make and support the tools that make something like that actually work, and that our company (culturally and financially) would never find spending all that money on internal-only custom tools to be economical.Thankfully, no one listened to them and they are all gone now.","How many more startups could be funded if VC understood that 80% of startups could be serviced by one of the following?Go api + reactDjango + htmxBlazor appHook it up to Neon, Planetscale, or Mongo Atlas.A good product should be able to provide value with a very simple interface (it can look modern and be simple - you don't need to be geocities here).","I agree with the concept but I've worked with a lot of people who use it as a meme to avoid things that do make sense.eg. one team I worked with refused to use containers, proper ci because 'we're not google' and near every deployment they made failed in a way that impacted customerslike yeah don't be a architecture astronaut or bandwagon concepts you don't need ( service mesh, microservices usually ) .. but you still have to solve for your problems","Talks for nearly four minutes without actually saying a single thing. That's some politician level shit.","This clip is trash just go read the transcript.https://changelog.com/podcast/564","The problem is that the \"trickle down of best practices\" only happens at the surface level, and the smaller companies don't understand the mounds of research and planning that happened before any code was written. There are very specific reasons that products from enterprise companies work a certain way, and if you don't share the same underlying needs and assumptions, mimicking another product doesn't make any sense.What should instead be taken from these companies is the amount of prep work that goes into understanding a problem and planning before any technical decisions are made. Once you understand the problem, then you can start to make decisions about how to solve it, which may or may not being as complex as a solution that a FAANG has come up with for their use case.","So true. It's not just that those companies have unique problems it's also that many of them have cash printing machines or literal monopolies that make it possible to fuck around with research projects and see what works. I did have the problem of \"It would be nice to have a nice modular JS framework instead of this piecemeal jquery/backbone thing I'm doing now\" but even so the company didn't have the excess resources to let people fuck around writing their own, and so you get your React and Angular from Facebook and Google, who do have them.","valid point, not very well articulated.","she looks drugged.","But unnecessary \"web scale\" fills up my resume with nice buzzwords.","I... guess? Architect what makes sense for your needs, but a reverse proxy is always a good idea? Google or not. I was at Google, we just ran a big monolithic application because that's what the product required. If you go out and build everything like youtube or something, then you're an idiot applying the pattern you know.","A lot of strange assumptions.We don’t teach and require understanding of algorithms just because you might use them. We do it to help you understand common techniques and patterns used in programming. People who don’t know basics just don’t turn out to be great engineers.Most engineers at Google or Facebook don’t deal with problems of scale on a daily basis. You use existing infrastructure which already scales very well. Small minority of very senior engineers will ever be a part of any serious scalability discussions while working on said infra.","She’s correct 100%.I’d add to that unless you’re at a company dealing with scale similar to a FAANG, idolizing best practices as dictated by any of these companies is inappropriate.Best Practices for most companies needs to be determined by the company and its culture; not some external company that operates in an ivory tower with almost limitless resources.As a principal engineer, I’ve worked across the scale with FAANG as well as SMB. I feel too many people read into some of these best practices as gospel without determining whether these practices even make sense. Unfortunately it shows that critical thinking and decision making skills are really lacking across the board in many companies; and instead they play a game of follow the leader. I feel there’s way too many people playing the “nobody got fired for using IBM” mentality instead of taking a hard look at their needs, and crafting the right solution themselves and being okay with making mistakes along the way. It’s those mistakes that make you an expert - learn by following the leader does nothing to establish credibility.","It's because software engineers don't understand how fucking business works.Monoliths are efficient and quick to change. You need that when you're running on revenues of thousands vs millions. Being able to ghost image your whole business off one computer and make backups is an asset. You probably have 4 programmers, not 10 and definitely not 40.You make a monolith to make your initial cash, and then when it comes time to expand, then you do it. That's what business is. It has several phases and each phase is different. Knowing when to scale is crucial.Running Google/Amazon farms when your business is not even making 100k per month is just a fast way to burn out.This is why video games are monoliths. They're not live services. It's one and done. The same applies to startups. You can scale AFTER you can afford to pay your staff at market rates","Yea, when \"this is how Google does it\" is their argument , that is a clear indication that they have no real justification for the crap they're peddling."],"points":379},{"text":["From Slow to SIMD: A Go Optimization Story","So basically if you want vectorize your code, Go is not going to help you much. You still need to resort to hardware specific assembly code."],"points":0},{"text":["Mobile is actually pretty hard.","I tried web dev and mobile, I will stick with the backend.","I've really enjoyed building apps for Android but I have a very narrow enterprise use case:MDM controller app installs, no need for public app stores2 devices with stable OS versions, known screens, known hardwarelow level access to device hardware through OEM mobility hooks and just complete control over the entire app environment from start to finishfull admin on every client device, up to and including nuking it / starting over / sending it back for mfg punishmentWithout these things it seems like kind of a shit show, I don't know that I would want to do it otherwise tbqh.The public play stores seem to be 50% of the pain I see and hear from mobile folks with the OS version whiplash + hardware diaspora making up the rest.Otherwise it's pretty nice, highly recommend it.","In my darkest days, I was once on the hook in App Review for over 50 days while a SEV-2 smouldered in the background.This is insanity. Just pull the submission and resubmit if it takes more than three days for Apple to review the release. Like what the fuck?It’s obviously not ideal but you’re not powerless; you have agency, you can toggle state.","tl;dr web dev is hard and mobile dev has some of the same issues.","In my darkest days, I was once on the hook in App Review for over 50 days while a SEV-2 smouldered in the background.That's why we need thirt party appstores. At least android has f-froid although it's a bit clunky.","Except for the AppStore issue, this is how programming outside of very narrow field (backend/microservice) feels, I don't really see anything hard about it.","Mobile it's always a pain.. prefer to work on desktop stacks like C# / XAML (for the front part), especially on internal business software's where UI/UX don't care a lot. If I realy need to work on mobile, best thing to use toolkits like reactive native where you just need to copy / paste / adapt and survive...","I don't mind web dev because you can build front ends that don't need maintenance. But iOS apps are a nightmare because they require so much maintenance year after year.","I'm glad I never got into mobile dev","mobile wouldn't be this hard if they embraced the browser but apple and google realized they can't double dip with their \"app-stores\" operating like a mafia where they decide who can sell stuff on their turf , breaking the knees of anyone that doesn't pay the fees and potentially burning down the whole business if they don't comply with their made up rules.it's even worse because if your business is too successful they will straight up steal your shit and put you out of business.the Mobile market is what Microsoft tried to pull during the 90's and they failed back then because the government was somewhat still functional but now these failed states can't even enforce basic anti competition lawsOh one more thing it sound crazy but Android is a carcass like it's dead dead.it's so fucking sad how it went from might be viable option like linux to watered down iOsGoogle tried to revive it by doing 5 consecutive UIs overhauls but they failed miserably","As somebody who has done a good amount of front-end and back-end dev, I’m always surprised by the attitude that back-end dev is fundamentally more challenging in some way. Writing user-facing application code typically involves a considerable amount of operations and context that are happening concurrently, in a way that you often don’t have a great idea how the user will approach it or in what order things will happen. It can be an extremely challenging and error-prone endeavor if you’re not pretty familiar with how to lay out your application code to deal with that level of asynchronicity. On the other hand, back-end code is often considerably more deterministic, with fairly distinct entry and exit points.I suppose there’s a feeling that front-end code is easier to crank out if you just do it poorly? I don’t know. There’s a lot of absolutely terrible front-end code out there.","Agreed. I love front end and back end, absolutely hate mobile dev. Tried my hand at Flutter (using two separate langs was not an option) and yes, while you can get a decent app going, the App/Play Store rules and processes are terrible, not to mention flutter is a clusterfck in terms of readability and overall use. NEVER again.Edit: pls don’t mention the awful thing called React Native. Frameworks/whatever are supposed to make life easier, not harder.","i wonder when mobile devs just moves to electron like what's happening on desktop (except for when performance is integral),cause who really wants to deal with whateverthefuck is thought up by whosever ego is promoted to control of any particular part of the apple/google ecosystems?","I'm not touching mobile because it's dominated by Apple and Google OSes, one of which is a closed garden (which I'm very much against) and another had trash development experience when I've researched it.","PWA and webview with some extra native functionality for iOS and away you go...","Another clickbaity title saying that \"a part of programming is hard\". Everything is as hard until you learn it, we all know. git --gud","reminder that substack is a nazi site, try to find a different platformedit: I said what I said, cowards","meh","React Native is now synchronous and seems a lot more performant than it used to be.","Cool"],"points":837},{"text":["Solving the Memory Puzzle: How Contiguous Memory Allocation Boosts Operating System Performance","Whoever wrote this article is a clueless crayon eater who has no idea how virtual memory works in any modern OS.","Reads like gpt written. Lots of rephrasing with of the same two things. It conveys no new information but by using differently built sentences the reader often doesnt notice it. /s","Well, it’s more about cache locality. Storing things contiguously in memory can help with that, unless you exceed cache lines."],"points":9},{"text":["Netty Source Code Analysis-ByteBuf"],"points":0},{"text":["Scaling Airbnb’s Payment Platform","Digest Version:This post, written by Angela Zhu & Karen Kim from Airbnb Payments Engineering, delves into the evolution of Airbnb's payment platform. Initially, Airbnb's transactions were offline and cumbersome, leading to the decision to handle payments in-house. The early system was simple, using PayPal for guest payments and paper checks for hosts. As Airbnb grew internationally, the need for a more sophisticated, global payment system became evident. This led to innovations like integrating local payment methods, such as Boletos in Brazil, and addressing the complexities of currency conversion and regional payment preferences. The payment infrastructure underwent major changes, moving from ad-hoc integrations to a more structured system with a Billing Interface API, a unified Payments Gateway, and a scalable Financial Data Pipeline. These upgrades facilitated easier integration of new payment methods, improved financial reporting, and supported Airbnb's global expansion. The post highlights Airbnb's commitment to owning and continuously improving its payment system, which has been pivotal to its success as a global travel platform.If you don't like the summary, just downvote and I'll try to delete the comment eventually 👍"],"points":3},{"text":["Emulator-Backed Remakes","The idea is good, but not new. For example see this version of R-Type with the original graphics and new 3D.https://youtu.be/ppchIpOJxHs","Isn't this basically the same thing as texture replacement, which is available in many emulators for 3d consoles?","Kind of feels like what RTX Remix will allow — or what Reshade presently does (injecting its own drawing calls)"],"points":5},{"text":["Exploring Global Fishing Watch Public Data With SedonaDB & GeoParquet"],"points":0},{"text":["The architecture of today’s LLM applications","Main Points:This GitHub Blog post outlines the essentials for building Large Language Model (LLM) applications. It covers five critical steps: identifying a specific problem, selecting an appropriate pre-trained LLM, customizing the LLM for specific tasks, establishing the app's structure including user interface and prompt construction tools, and conducting real-time app evaluations. The article emphasizes the importance of each step, from the initial focus on a manageable problem to the customization and online evaluations critical for effective LLM app development. Additionally, it includes real-world examples like NASA's geospatial AI model and Johns Hopkins' conversational AI agent for medical guidance.If you don't like the summary, just downvote and I'll try to delete the comment eventually 👍"],"points":2},{"text":["[Release] basic-rust v1","I can’t figure out what this is supposed to be. It literally just prints hello world and has a bunch of unused structs for File and Log that don’t do anything while confidently declaring itself “negative cost”. What is v1 about this?"],"points":2},{"text":["Short Read: Code for Tomorrow, Balancing Timelines and Maintainability","The first solution that works is often not the most maintainable solution. That's when it takes some discipline to not open a PR at that moment and instead do the refactoring work that'll make life easier for future-you. Thanks, I like this \"micro-blog\" style post.","\"Do good and slow, don't do bad and fast\"Advice given by a guy who has never worked in startups and works in huge and slow monopolist enterprise that don't need to verify ideas or experiment coz it has a huge money pipe already."],"points":2},{"text":["How Much Testing is Enough?","As the codebase grows and reaches a point where numbers of functional units are available to test as a group, it’s time to have a solid base of integration tests. An integration test takes a small group of units, often only two units, and tests their behavior as a whole, verifying that they coherently work together. Often developers think that integration tests can be deprioritized or even skipped in favor of full end-to-end tests. After all, the latter really tests the product as the user would exercise it.I am of a firm opinion that integration tests have a bigger value for the software quality in general and especially over time - than unit tests.Unit tests are fine for algorithmically complex units and to expose the low-level software design, but oftentimes they are not very useful.Their purpose simply is not to test many things that should be tested, like performance, threading, load, observability and the correctness of the interaction between the units and the other parts of the whole system which is where, IMO, most of friction is.","How Much Testing is Enough?When you trust them. If you make changes in the code and green build means you immediately push the deployment, it means you have enough good tests. If you don't trust green builds and you still have rounds of manual testing of some sort, then you're clearly missing something.","Unpopular opinionUnit tests imo is only for advanced business calculations or critical processes that has to be in a certain way.Moqing API contracts is borderline insane to me.If you change an input/output and you don't know what it will effect you have bigger issues than failed tests in your software.Testing = time. Time is money, bussiness want to make money and thats why we should focus on delivering features.","Testing is a cost saving measure, where you try to find most of the bugs in as little time as possible. It's nice to have, because realistically, no one is going to rewrite their codebase to make it easy to prove, and then write 5x as much in a proof in Coq or Agda or any proof assistant.Static typing is an attempt to mix formal verification with programming code. Ultimately, that leads to the programmer doing two things at once, simultaneously being forced to write and prove their code. The reason why static typing seems to be optional for most programmers is because the way we reason about our code is often not capturable in a typing relation.So basically, static typing captures some bugs, and hopefully testing catches the rest. But often our users let us know what's wrong.","I hope you like the summary:The post addresses the perennial question in software development: \"How much testing is enough for a software release?\" Recognizing that the answer varies depending on software type, purpose, and target audience, it suggests a flexible approach rather than a one-size-fits-all answer. Key recommendations include documenting testing processes and strategies, establishing a solid foundation of unit tests, not overlooking integration testing, conducting end-to-end testing for critical user journeys, understanding and implementing various testing tiers, gauging code and functionality coverage, and using field feedback to refine testing processes.If you don't like the summary, just downvote and I'll try to delete the comment eventually 👍","That much testing that not a single bug can pass to the final project.","I find that unit tests and integration tests mean very different things to different ppl.Some ppl wil claim unit test should only cover a single class and all dependencies should be mocked. Iam not as I think this way you end up with many meaningless tests that just increases coupling to the code.Iam of the opinion that you use the tool or tools best suited for the job.Is it a REST api? Just integration test it, it's the natural stable interface for it. You don't always need unit tests.Do you have some complex algorithms? Unit test them. Mock dependencies only when that gives value, for example you usually mock out IO as it makes unit tests slower, potentially flaky, harder to run etc. My point is mocking should have a purpose and if there isn't one dont mock. Iam pointing this out specifically as I have seen countless projects where tests had so many mocks to the point the whole test was worthless and unreadable.In the end all that matters is having a good test and there isn't a single type of tests that's better or should take priority over the others. They are different tools and it's up to you to pick what's best depending on the situation.","Have found integration testing to be way more useful for the internal SPA I maintain"],"points":126},{"text":["Torvalds Speaks: Impact of Artificial Intelligence on Programming","This is incredibly refreshing to see.He's just talking in a sensible way. He's not just shit-talking AI but he's also not uncritically raving about AI takeover of everything, he's just cautiously optimistic.He outright says that it's not his area of his expertise, and he talks about what he thinks is a valid use-case and how it may help people.The interviewer keeps trying to push the FUD aspects, and Torvalds doesn't feed that, it's just a steady and fair \"it's a tool that might help, tools can be flawed, people are also flawed\".Everyone should take a lesson from this. Torvalds might go off the chain when it comes to operating systems, his area of expertise, but he demonstrates excellent restraint when it's not his field (at least in this instance).","Code reviews - ShinesReview code - ShinesFinding bugs - ShinesSuggesting coding patterns you want and suggest to LLM - ShinesExplaining error messages - ShinesWriting code from scratch - MediocreArchitecting a solution - Mediocre/PoorUnderstanding code or solutions it has no clue about - PoorContextual multi-file or multi-domain code understanding - poor-- We are all talking about ChatGPT here just in case anyone was wondering.","As always, Linus is extremely pragmatic and does not shy away from new things as long as they provide value.","Does anyone know the full source of this clip?","One of the most interesting things he said was \"...now we're moving from C to Rust.\" Does this portend an eventual move to Rust for the Linux kernel?","This is a much more reasoned view on automation than you usually hear around here. We've been using automated tools to help code ever since the invention of the compiler.I'm tired of the \"it will never work, and if it did work it would be the end of the world\" from programmers who are obviously scared of losing their jobs.","All my life I have done coding and robotics. I’ve loved the programming part the most. I started out with a robot rover that used the simplest commands to move. From there I got into block coding and such. As I’ve gotten older my interest has only grown, but one day right before I had a structured programming class, I found out about chat gpt. All my life I had planned to go into some sort of programming job, but after that I got depressed and felt like my entire life had been wasted. Because who would want to hire a programmer when they could just type what they want and get the answer. It wasn’t until i had decided to really get to the truth and figure it out for myself that I found how it wasn’t so bad as I had thought. I realized how good of a tool it could be. I kind of went deeper into how prompts worked and how I could better design prompts to help me with tasks. I still love straight coding, but I use stuff like copilot or ChatGPT for many of the things that I do now and I still love it as much as I did when I was little. This isn’t something to be scared of, but something you should use. This is just my experience.","I'm currently applying for a job as a chatbot code trainer.The idea is you create projects using the chatbot code app, then critique/ review the solutions it creates.You must be the one to create the prompts, and they want to see original / interesting prompts.","Is it me or does Linus looks each day more like Palpatine 🤔","Nice to hear him have a mature answer balanced view of the place of LLMs in coding.","while everyone are distracted by LLMs Linus mentioned that rust will have a big push this year ! slow and steady boys we are taking over the kernel 🦀","This technology is evolving so rapidly, that his observations about GPT as a tool are only valid, like, in this exact moment. GPT has only been mainstream for a year and how look quickly it has taken over so many aspects of programming and other language-based tasks.There's no way in 10-15 years our jobs aren't almost entirely obsolete. \"Rewrite the Linux kernel in Go\" will be like an overnight task for the models at the big tech companies. If you think otherwise, I think you're in denial.","[deleted]","Here is a better question, do you trust artificial foods in your body?","Always accepted and approved, no code review needed, nor QA. Or QA by AI, why not. Of course. Straight in production. A true boss/CTO dream isn’t? Well… sorry boss, still doesn’t work like that. Apparently you still need me! Very sorry about that! 🤭","There is a huge and extreme difference between what people think LLM is and what LLM is.It works only as long as code is only syntactically complex. At the moment you introduce logical complexity it fails. It is not a reasoning machine outside of direct patterns obvious from the literal code itself.","I see the bugs that happen without them everyday.... I think we're doing those just fine on our ownSick burn lol","I find the analogy between AI and the use of higher-level languages a bit naive (and surprising for an experienced programmer like Linus).The success of higher-level languages rests on the shoulders of compiler science and technology which are some of best results to come out of computer science. Unlike LLMs, compilers are based on rigorous mathematical algorithms to process and transform code. And they are predictable, i.e. you can rely on their behavior in new situations. Expecting anywhere near the same level of reliability from LLMs is IMHO wishful thinking.Linus' remarks about Rust the reviewing of \"simple bugs\" is also interesting: I'm not sure what kind of bugs he specifically had in mind, but Rust should be able to prevent a lot of common bugs in C/C++ because of the stronger type ML/Haskell-like type system and the borrow checker. I'd put more faith into the latter (type systems) than AI automatic code reviews.","AI is the Auto-Tune of software development.","\"because all a large language model does is it predicts the most likely next word\"Tbh, I find this view pretty ignorant. We aren't even so sure if humans themselves don't operate like this as well. It could also be that LLM don't just predict the next word, but much more, it's only that the final output is just one token. But a model that can predict much more that just the next word, will likely be better than a model which tries to only predict the very next word.\"Not very intelligent\", lol LLMs are already better than most human beings at proving geometry theorems or some other formal proofs. They can write better texts that most humans. They can write (small scale) code that probably runs better than what most developers would write without access to a compiler and other tools.As if humans don't write bugs. At some point the bug-per-line measure will be lower for some LLM system than the average developer, and it'll probably happen sooner than we think.","\"LLMs are just auto correct on steroids, they don't have real intelligence\" - that's not a very useful thing to say. Do we have proofs that our brains are any different? We also make stupid mistakes. I'd argue that ChatGPT is possibly a better programmer than the average programmer.In the hands of a skilled programmer it's an incredible tool."],"points":1471}]