[{"text":["Do You Have A Hard Time Understanding Docker Compose?","Hello Programming Community!As a university lecturer, I know the importance of sharing knowledge. That’s why I’m excited to share a comprehensive Docker Compose Cheat Sheet that I’ve created. It is available as PDF and PNG. It’s completely free, with no email signup or any other requirements.This Cheat Sheet is part of my detailed blog post about Docker Compose. Here is the link: https://devopscycle.com/blog/the-ultimate-docker-compose-cheat-sheet/ It walks through the essentials of managing multi container application with Docker Compose. You will also learn about accessing running containers and how to persist data. The post also includes a public GitHub repository. It comes with all the source code, available for anyone to use and learn from. It is an excellent entry point for an internal hackathon at your company or university.If you like the blog post, the Docker Compose Cheat Sheet or the GitHub repository, I would appreciate it if you share it. Your feedback and experiences are always welcome. Let’s keep learning and growing together!Cheers,Mr_LA"],"points":0},{"text":["Why you should aim for 100% unit testing coverage","I disagreed with the title and I still do, but you raised some interesting points for me to think on. Good piece and I'd recommend others with opposing views give it a read too"],"points":0},{"text":["🚀 Introducing CYBERBNK: Banking for Architects of Tomorrow","LMAO still tryna sell crypto wallets in 2024. Find a new grift."],"points":0},{"text":["Engineer, meet Devin. Here’s how he will change your career.","Hey mods can we please ban this lame Devin astroturfing?","Blow me, Devin.","Fuck you Devin. The worst engineer since sliced bread. - Should be article title."],"points":14},{"text":["A Real-world Guide to use SwiftUI framework to implement MVVM-C"],"points":0},{"text":["I quit. After 25 years in tech (17 as a dev manager), I finally got that one, truly horrible boss who drove me to the brink of madness. Literally — I needed 3 months of mental health leave. But it inspired me to quit tech and make it my mission in life to reform bad managers... Here goes nothing!","End stage LinkdInitis","All i hear is a project with 3-4+ layer of managers and only 1 engineer pressured from them all.Maybe a sixth layer of managers could solve the problem! /s","I salute the effort, but in my opinion, these people are irredeemable.It comes down to one thing, they are weak. They have any pressure from above they immediately cave in and pass the issue down. Then they encounter you, who probably refuses to dump his truckload of shit on the team. Shouting matches ensue.What you need is to stop companies from promoting pushovers as managers. You can not teach someone to have balls and say: \"This is simply not feasible, and not what we agreed to.\"","It's very common for devs to move back and forth from management back to IC roles. I've been in management for about 8 years, I'm considering going back to an IC role too. Principal engineer is a nice place to be too, you just don't have as much control, which is kinda nice honestly. If coding is your passion, rediscover it. Nothing wrong with it.","lol 3 months of mental health leave. You Gotta Pump Those Numbers Up, Those Are Rookie Numbers."],"points":157},{"text":["Environment Setup & Visual Optimization (Unity)"],"points":0},{"text":["What Agile Development Means in 2024"],"points":0},{"text":["Tic Tac Toes - A \"three dimensional\" Tic Tac Toe game I made. A twist of Tic Tac Toe inspired by VSauce written in React + JS. I will happily accept contributions, if you’re interested you can check for any open issues or create your own!","Not what I imagined when I heard 3D tic tac toe, but cool idea.Instead of the player with the most wins, what if it was the player who got tic tac toe in the 3x3 larger grid, getting your mark if you win the inner game?"],"points":1},{"text":["Fake 7 zip on Microsoft Store just caught them using remoteconnect and installing malware on my gf’s computer.","What does this have to do with programming?I had to google \"Romanithos\" which is not a thing, do you mean the developer \"Romanitho\" on Github and one of their specific projects? https://github.com/Romanitho/Winget-AutoUpdateWhat did you do to \"trace all the bad events\"? Why would both 7zip and this guy's .. package manager for windows (?) be in cahoots and both be executing malware independently?That package manager thing has less than 1k stars and the author seems to be French. Why do you think they're Russian again?Igor Pavlov is Russian, but 7zip is so widely used I think we'd have heard about this already?","Bro is taking meds","https://winaero.com/fake-russian-version-of-7-zip-in-microsoft-store-distributed-malware/amp/","And that surely wasn't archive contents?..","Makes you wonder what else in the AppStore may be infected - VS, .Net, etc."],"points":26},{"text":["JavaScript Event Calendar for Resource Scheduling"],"points":0},{"text":["voidb.in: An end-to-end encrypted pastebin","What does that mean? Like I can't seem to input a key, so how is it e2e encrypted?"],"points":1},{"text":["Goto Is Not A Horror","I’d say stringly typing is multiple orders of magnitude a greater menace to your code than goto, at least a good 6 or 7This is the single biggest reason why ORM is preferred option when working with SQL databases.I know people will complain about ORM is bad and magic, however I learn ORM using debugger and show_sql = trueand for Goto - He is correct, sometime, someone needs to us Goto for some reasonHowever, that someone can read high level language like Java, C/C++ or C# and translate it into assembler (in his mind) without any tool","Yes. Very useful thing, when you don't have destructors","Dijkstra was right, and is still right.","25 years of C++ and I have never used goto. I have never needed to use goto. I suspect that that is most people’s experience. He’s right that modern goto is not 60s goto, but so what? It is still best avoided as it is different to the other control flows and so is easy to get to wrong. Maybe C programmers need it sometimes.","Stop freaking out about goto. Stop acting like the 1960s goto is the same as today’s goto.However, please try to rewrite your code so that you do not have to use the modern locally scoped goto constructions either. If too much work at least try to extract the aberration to a small method with only that control flow and no further logic.","Only thing slightly close to goto is throwing and catching exceptions. I've seen people do some crazy BS abusing them.Back in the 00s I was looking at a C# project don't m some contractors wrote and found a few old fashioned gotos. Those were the days!"],"points":22},{"text":["A Comprehensive Guide to Trumbowyg: The WYSIWYG Editor for Web Developers","Trumbowyg 2024"],"points":0},{"text":["Solving 1000 LeetCode Problems (Is it Really Worth it?)","No","Hot take: leetcode is kinda fun and I just do them as a brain break","Solving 1000 LeetCode problems is not important; solving questions in minimum time is important. In the coding round, you only have 1.5 hours to solve 3 questionsThis is the conclusion the article makes. The author of the post is deciding if solving 1000 problems is worth it FOR participating in contests. Its probably key to understand what solving 1000 problems represent, if it means learning a new data structure or some algorithm it could be reasonably useful in certain scenarios, the key question is it worth it for what scenarios?For a job interview ? - It could be worth it for jobs where leetcode is commonly asked (eg FAANG companies that ask it). There are other companies where leetcode is not asked so it may not be worth it.For learning about interesting problem solving techniques and data structures ? - In a way yes, if you want to learn how a database like MySQL stores data in a tree, you'd want to know what a Tree even is and doing leetcode problems on trees would give you the knowledge on what a tree is and would give you practice to be able to manipulate trees and try different stuff with it. But it should be noted that leetcode problems are generally too simple in these cases for instance a tree problem in leetcode is just a simple tree of numbers whereas in real life it is probably a tree of objects (I know its not a big difference but it can trip up new programmers) but its still good for fundamentals before you jump into the actual mysql codebaseDoing it as a hobby ? - If you're the kind of person who wants to solve programming problems for fun then leetcode is a great place to do itDoing it to participate in ds coding contests ? - It definitely is worth it especially for a beginner but once you get to a good level you'd have a lot more fun at codeforcesFor performing well at the actual job ? - Its usefulness highly varies based on the kind of work you do at your job, if all you are doing is CRUD operations or building websites or standard run of the mill analytics software you can get by without knowing any of these. But if you are building something that has a data structure at its core (like a database) you atleast need to know that a data structure exists for a use case.One example I heard from a friend was about how this dev (not exactly dev but a business analyst who knew coding) was storing a bunch of data in an array and then looping through it every single time to see if there was a duplicate file name that existed when they encountered a new file. The only problem was there was a huge number of files and this person did not know about databases so they couldn't just store it there and check nor did they know what a map or a key value pair was so it was just bad code. At the end of the day it has its own pros and cons and is nuanced as hell and it doesn't really make sense to just make a generic statement","Answer: No.Because when applicants sit in front of me for the interview, they get a piece of practical code, that has nothing go do with anything you see on [insert-comp.-coding-site-here] and a question like \"Lets talk about the approach taken here and its pros and cons\".I don't care about Leetcode. LLMs can solve Leetcode. I don't hire for skills the computer can do faster and cheaper. I hire for the skills it cannot.","The sweet spot is maybe 50-100 problems. Mostly easy/medium for fun and the occasional hard one for dedicated study. Its a fun exercise; not some holy grail of coding ascendance.","Leetcode as a hobby is ok","https://en.wikipedia.org/wiki/Betteridge%27s_law_of_headlines","No, make a real project that people can use. Don't waste time with LC.","This tells something about you that is enough to get you a good job.","It depends.LeetCode can be helpful to test your existing knowledge and get you thinking about different ways to breakdown solve the same problem to find approaches that yield better performance (time and space complexity). It should help you develop a mindset and thought process more so than wrote memorization; you should be able to explain why one solution is better than another. If you’re doing them right, you should be able to recognize a very differently worded problem as being similar/the same in terms of the solution, data structures involved, algorithm approach, etc.When Interviewing at Google, they are not testing you for any particular role or project. Their problems tend to be very direct and impersonal - here is the GIVEN info, implement a solution to do X and make it run in O(n) time. The candidates who get through all of the stages then essentially become the interviewer to team leads and managers for potential projects/teams that they want. (At least that was how it was done in my experience about a decade ago, maybe it has changed)One problem in the industry is that technical interviewers are often not trained for that role at their company. They instead lean on these generalized technical screen platforms like LeetCode and/or the experiences they had when they interviewed. In the flip side, some companies do have a rather rigid and unhelpful guideline script that they want their interviewers to follow but which are way too generalized for the project/team/role and probably were written by someone in HR rather than engineering.At the end of the day when I am screening candidates, I keep a git repo with all types of questions and various solutions with unit tests at my disposal. Depending on the role and the needs of the team and the position level, I look for different things. I always start with a general conversation and pick and choose which questions from the set to use. Sometimes people suck at one type of problem and that’s OK. If the domain doesn’t require using graphs … I’m not going to ask them to implement Dijkstra's algorithm. If they’re not senior level, I’m mostly looking to see if they have enough foundational knowledge and the mindset to learn and grow on the team.","I've lost out on jobs that would have been an otherwise great fit because of this nonsense interview style.","Not at all. It is a disposable knowledge and experience. You will quickly forget most of the tricks soon after you stop doing that exact same type of puzzles, i.e. even if you continue doing other type of LC puzzles.","Imo I only do leetcode because it is asked in an interview, other than it is nothing.","No","You kind of missed something rather important.If you're going to do FAANG level interviews, then Leetcode may prepare you for that... Except....They also don't. \"I can solve the problem.\" isn't what these places are looking for. \"I can communicate about my solution and I come up with a reasonable algorithm.\" isYOU MUST practice the communication and collaboration of the ideas, YOU MUST be talking with your interviewer, YOU MUST take feedback and hints. I've done interviews as well and the person who nails every question is impressive, but the person who collaborates with the interviewer is the one was prefer to hire. And Leetcode does nothing for this type of thing.Even leetcode's testing is good for pressure but AWFUL for communication AND awful for actual interviews. The people who come in get a question, don't ask any follow up question and just turn in the \"Correct answer\" is staggering, and yet there's more than enough discussions from the FAANG interviewers to understand that those approaches don't get the job.\"Why?\" Because they didn't actually ask questions. When I give a problem I'm not giving an order, I'm giving a situation. Today I had an interview. \"Search a Doubly Linked list for a value.' you know what? I'm going to pass that, and not because I can do .... Because I started with asking \"How is the list designed? Is the list well formed? Can we be sure there's a end and we're at the proper beginning?\" and so on. Those questions showed I wasn't just answering the problem, I was designing the problem, and that's the key to a lot of interviews. (And man the interviewer didn't have a poker face, I could hear on the phone call he was happy with those questions rather than just jumping into code.)Now you want my story? Google gave me a thumbs up on the phone interview... then laid off people, so the position was gone.. A crypto company gave me the thumbs up on the phone interview and reorged the company (fired the HR person talking to me). Meta gave me thumbs up on the phone interview and they wanted me to come in.. except they sent out offers on the position they were looking at me for just before they did, and there's no others in Orange county right now.FML. I'm probably going to be taking a job in Orange County for potentially 160k because the market is in such a shitter of a position. I have the skills, I just have had rotten luck. The good news is I have 16 years experience, I have the knowledge, I have seen that I can pass the interviews. And you know what, there's always next time, but it'll be on my schedule, not when it's layoff time again.Edit: Also forgot System Design which is not easily teachable (is not teachable at all maybe?) with leetcode's system.","It's fun and it improves your programming skills, so yes definitely. Although I wouldn't put a target on it.","Not really, no.","Do as many leetcodes as you can, as many projects outside of work as you can, have no girlfriend and please, do no have any time to exercise or a be a nice person outside of work, that is going to guarantee you get hired! /s","if you are not yet sure what domain you want to eventually pursue, how about hopping over to https://github.com/RajaSrinivasan/assignments and explore. Explore broadly but get deep into some aspects of interest - would be my advice. best, Srini","Iighuguijarro uuuiuuuuuhuuuuuuh"],"points":648},{"text":["New study could provide revolutionary way to build an AI that understands Logic and Time: Theories and Aplications of Boolean Algebras by Ohad Asor"],"points":0},{"text":["11 most used Monorepo Build Tools","I was actually just thinking of building something like bit. It looks like they really try to force the enterprise commercial cloud offering though..."],"points":0},{"text":["Messing with AI programs","Search for AI \"poisoning\" - that's the terminology being used for this concept. Judging from headlines, yes, it's possible but I don't know any details.","At this point LLM poisoning is a moral imperative.","A lot of professional art comes from sampling the work of other artists. Unless it's flat out spitting out a single piece of art and calling it its own I don't think you can claim there is anything illegal bout it."],"points":32},{"text":["David Adam: \"#fishshell rewrite-it-in #rust progress, 2024-01-15: 100 %\"","So, we're done? Well, yes and no.Yes, in the sense that almost all the C++ has been rewritten in Rust (at a raw line count about 10% more, which is not a particularly insightful number). The fish_test_helper standalone binary remains in C++, because it's basically entirely libc calls, uses no other fish code and never gets run by end users.No, in the sense that none of this code is shipped to users. We've still got work to do to get this into a tarball that someone can (say) brew install - at this stage I think it looks like CMake will be hanging around, much simplified, to handle some of the configure/install targets, while cargo is used for the actual build.However, some of the social goals have definitely been achieved. Large parts of the rewrite came from contributors who had never worked on fish before. There's been a lot of buzz in various online fora. Vibes are just as important to free/open source software as proprietary software and although there were solid technical reasons for the port, the PR outcomes are added benefits.Finally, this is definitely not proof that you should rewrite your software in Rust. It's a data point at best, and maybe check back when the answer to \"are we done\" is \"yes for sure\". [ ... ]","Congratulations on the milestone, Fish Team!","next: rewrite it in zig","What is the performance increase? Or the main benefits of this great work?","Can we stop re-writing things in rust? Make new things if you are so enamoured with the language."],"points":153},{"text":["Is the “AI developer”a threat to jobs – or a marketing stunt?","One of their MRs for a test they supposedly passed was openly mocked by the maintainers for how bad it was. https://github.com/pvolok/mprocs/pull/118","It's corporate propaganda salivating over yet another way they can reduce salary expenditures, which they consider a cost sink.","When I can get the AI to spit out a bug-free branch refactoring my 35k LoC React frontend to add a new feature or rewrite some existing functionality, I will happily welcome it and focus on figuring out what to improve instead of having to build it myself.","Why not both?","I thought everyone with half a coding brain worked this out last week...?Are there people still impressed by the magic smoke and mirrors...?","The current state is closer to a supercharged IDE that attempts to implement a feature or fix an issue.Quite promising for a V1: to handle easy PRs, boilerplate or just changes that are simple but take time to implement.However the V2 and V3 of such tools are probably going have much boarder confidence scope."],"points":66},{"text":["Our Development Philosophy: Collaboration & Testing"],"points":0},{"text":["New Research Exposes Privacy Risks of WebGPU Browser API"],"points":0},{"text":["Composition over Inheritance: My refactoring recipe","Maybe there's a language-specific subtlety that I'm missing (never touched Kotlin/java) but I don't understand why you're claiming that abstract classes are the problem.The problem is not abstract classes, it's inheriting logic. A hierarchy of concrete classes would be just as problematic whereas pure abstract classes would not (they would basically just be interfaces).","I would just like to mention my own experience with abstract classes from a slightly different perspective: I was working on a project where abstract classes really were the best solution. However, it took me a long time to come to this conclusion and verify this because I was always told to go with composition over inheritance.In this particular project, using composition resulted in incredibly complex code that was otherwise extremely simple using inheritance. Not only that, but inheritance also resulted in less code upkeep because the shared code changed very infrequently, if ever. Sometimes you want and benefit from tight coupling. It's very context-dependent.I think the important thing to focus on here is teaching people to look at their architecture and the structure of their code first. If you have an idea of what your architecture looks like, you can then determine what the best tool for the job is. Often, I agree, it will be composition. However, analyzing the architecture from the very beginning would have saved me so much headache."],"points":9},{"text":["What is Actually the Universal Windows Platform and what is WinUI, MSIX, and Project Reunion / Windows App SDK?","Can you list some UWP apps (using the UWP app model) that you use on daily basis?"],"points":0},{"text":["Python extends its lead as the most popular programming language — but why does it have such widespread appeal?","The Tiobe institute aims to ... help companies make strategic decisions about what programming language should be adopted for new softwareWhat professional industry is using Scratch, which is in the top 10?","For the record, TIOBE's rankings are based on how many hits you get when you search +\"<language> programming\" in a bunch of different random websites with search engines (8 are Google in different languages, 7 are Amazon in different languages, then you got stuff like Walmart and Ebay) put at seemingly random weights (I think it used to be based on the now discontinued Alexa rankings, not sure if they've updated them since).That's it. That's what \"most popular programming language\" means, just that if you search +\"python programming\" in a bunch of different websites you get more results than +\"java programming\", when many of those sites are stores that give you \"learn C++ programming in 30 days!\" books when you try either.","This article really reads like it was written by a LLM lol","I love typed python. I hate untyped python.","As someone who has been a python dev for 4 years: it helps you build something that provides business value from data quickly.Not saying it will be the most robust in the long term, nor enable good habits in the process of building a product in all cases... But it lets you go from nothing to something usable that gets you value from data you already have in \"no time\". And using a \"developer\" who is a bit less experienced or even comes from a non dev background.All other reasons are trumped by this imo, although this ultimately feeds back into lot of them. The momentum of the language (ongoing support of open source libraries, language improvements) is provided by hundreds of companies out there finding fast and valuable usage of it.Companies don't care that it's interpreted. They don't care about the GIL. They don't care that environment management and deployment can be a pain. (Until you are.5 years into the project and hit issues with these things lol) Because ultimately it gets a data oriented products out the door and in a useable state with less effort than anything else. And that means $$$","I guess there are network effects combined with a very gradual learning curve. It's popular, people build libraries, tutorials etc. This in turn makes it even more popular.","it’s widely available by defaultscripting and easy prototypingvast amount of libraries across almost every fieldreads like a human languageperformance..shmornance.. write that stuff in C and give me Python bindings to it.","Python is popular for two reasons. First, of course, it is easy and interpreted and has some decent tools to work with.But the second is the insane number of packages written for it. When you can find something to do anything you want, you lean in that direction. Java has lots of libraries but they are either commercial or annoying or both","But it's not. It's JavaScript","Answer: It’s really easy to learn and it can do alot of things.","I dunno, I guess it just snakes its way into people’s hearts","modern python is fantastic. i remember being a freshman (wow 7 years ago) thinking what the fk is this mess of a javascript-bash homuncule language, modern tooling with type annotations, type hinting, close C interoperability, wide adoption, sensible package management, reasonable performance… it’s a fly wheel at this point, the good only keeps getting better and the what remains of the bad stuff has been accepted as a quirk of the language… what i don’t get is why anyone adopted python originally… oh yeah, cause nothing says “holy shit, lunch time already?” like finding out that your missing a bash script required for part of your build pipeline that you didn’t know existed in to being with","The gap between Python and the rest has never been that largeI think it's common knowledge that Python remains popular, and will continue to for years to come. Interesting that Go was added to the top ten this year though.Worth highlighting that Stack Overflow's dev survey - referenced here - gives a bit better context on the popularity of languages in a professional context.","For me, the answer is simple: I feel more productive in python. I find it easy to read, easy to reason about, and easy to write.This is not to say someone can't write a plate of spaghetti in python--that's possible in any language. But generally speaking, I spend less time wrestling with the language, and more time getting actual work done.","Python is the new BASIC. Except it's a reasonably well designed language. It has a big useful standard library, and a glut of third party libraries to do just about anything. Where speed is an issue, many libraries have successfully worked around Python's weak performance by moving functionality into C.The BASIC comparison comes from Python being a great language for teaching/learning. The simple syntax does a decent job of getting out of a new programmer's way. The meaningful whitespace trains new developers to indent properly. And he language itself can be used to teach numerous programming styles where most languages are more opinionated; Procedural, OOP, and functional are all perfectly reasonable, even where many languages make switching between them difficult.It's the perfect lowest common denominator of programming languages, and while that's often used as an insult, here it's a tremendous boon.","I think Python is popular because it focuses on usability rather than on efficiency. When I first came to Python from C++ I was shocked by the nonchalance with which Python programmers create arrays, sets, and dicts just to improve readability. No old-school C++ programmer would ever do that.Now that I've been corrupted by Python I don't want to go back to early optimize everything I write. When Python is not enough, I just reimplement the slowest parts in Rust.","Its just easiest language to learn so it has the widest range of people knowing and i bet a nice percentage of people that like it know only it (not like 50% but still a nice portion)And I agree it's nicer on the eyes","My $0.02 is that it’s the new Visual Basic on steroids. Easy to learn, friendly syntax, cross platform, and anything computationally heavy is a package written in another language that is easily accessed.I don’t use the VB comparison to slight it, suppose it just depends on your views on VB 😜","Because basically all ML development uses python toolchains. How is this mysterious?","Lowest common denominator.I expect to get downvoted, but it's true. The language simply does not have the fundamentals needed to write good software. Type checking is awful. There are no private members for classes. The PEP is full of community-enforced style requirements that seek to help alleviate these issues rather than just improve the language. And anyone who brings up these issues is downvoted and talked down to and essentially told to \"git gud\", when the reality is that Python is most popular among developers who wouldn't know what to do with advanced features even if the language had it.I've repeatedly found in my career that there is very real value in building rigid systems that are quick to throw errors when you deviate from what's expected. Where you have to declare your intentions up front, and then follow through. Yes, sometimes these languages are \"slower\" to develop, since you have to have a very good understanding of what you will be doing before you do it, and yes, sometimes it takes longer to make changes in these systems. But it also results in a better product. Besides, I've found that any (development time) \"speed\" you think you're getting through an easy-to-write language like javascript or python is going to be lost on the tail end as you put an increasing amount of effort into tracking down and fixing bugs, or trying to figure out why your API call is failing and the only error message you're getting is \"no data\".Also, it's very explicitly not the most popular language. Don't believe everything you read online.","\"I have a problem!\"\"Use Python!\"\"Now I have two problems!\"Where I work, they throw Python around everywhere, and now it's a mess of badly designed Python code when other languages would have been more suitable and maintainable.","because it's fucking easy, saved you a click","Its got a cool name. That's the real answer.","Why does Python have widespread appeal? High level, dynamic typing, strong libs for web services, data science, and ML. Tons of learning materials. It's not a mystery. I really dislike it but it's a very solid choice if you're only going to learn one language","this shit is irrelevant, of course using programming language mostly because the community and libraryI mean python got it so popular because numpy scipy pandas and suchand none on par with it even in R","simplest write code once language for non-software engineers","My guess is Python is getting a huge bump with the recent interest in all things AI and ML.Python is almost the lingua franca of that sort of stuff at this point.","Because it is simple and effective.","Python is slow and packages suck","I find that developers whom talk a lot of shit about python, do just that, a lot more talking than they do developing. Python produces tremendous value incredibly quickly and in a memory safe way.It's most real glaring weakness is its dependency management. If you're worth your salt as a programmer, you should only be really using PSF packages and rolling your own anyways because python makes it so easy to produce code quickly.","Am I the only person to hate python?For one, it's not actually an easy language. It has a ton of features, a lot of which don't really work great together. It also has a lot of annoying behaviour, where some methods mutate variables and perform IO, while returning None, while others also do side effects but do return and finally methods that don't do side effects and return new values. Other languages do the same like Go, Java, etc, but I think python is probably the worst because it's not typed.The type system in python is bad. It's not as bad as javascript, because at least conversions are more explicit but it's still a nightmare. I know you can use typing but that doesn't do much except give hints, which are sometimes irrelevant. Typescript does more then types python and it still can't fix javascript. The object oriented stuff is weird. Since you don't have types, interfaces become irrelevant but that's kind of the biggest appeal for oop. Not having algebraic types sucks, there are duck tape solutions but they just don't feel that good to use.Python is a bad scripting language. The language is huge, you can't really embed it inside another app. The way it handles file and database IO is questionable. The way it handles permissions is also questionable. I would rather use lua.Managing dependancies is impossible. If you're starting a big long term project, using virtually environments is not enough. Those are for bigger scripts you might have. You have to use docker instead in my opinion. In other languages I've never felt like I \"need\" to use docker, especially if I don't have a database server or some program dependancy. With python, getting your environment corrupted is just part of the experience.Python is slow. Being interpreted is a disadvantage for building apps. Say I want to build a server in python. There's a rule I like to follow where if making a database call is more expensive then waiting for the database, there's something seriously wrong. Poor performance can lead to bad user interaction and higher expenses. Also, it's nice to be able to give out a binary file sometime, instead of scripts.I can see how python is good for data analysis. Using it with sqlite and you've just replaced Excel. Not bad! Anything else and you're doing something weird.","Cause idiots like me can understand it","It’s pretty hard to argue the case against python. It’s easy and damn near universal.","Python is widespread because...In the 1990s the number of programmers the world needs exploded from \"just Bob by himself\" to \"billions of worthless web developers\". You can't pull good experienced developers out of thin air. The world had to use bad inexperienced developers. It was a disaster.The solution was to design new \"comfy safe lounge chair, with extremely bad performance\" scripting languages specifically for all the bad inexperienced developers; then make everyone pay orders of magnitude more for state-of-the-art hardware to cope with how slow it is while the climate changed due to the inefficiency.Most of these new languages where horrendously awful (e.g. Perl, which was developed by an oyster coating an irritant in secretions). Python rose to the top mostly because the syntax wasn't as bad as \"horrendously awful\", and because lots of people wrote native libraries written in efficient languages to make the performance of \"gluing together things real programmers wrote\" suck less, and because it started being taught by universities (who still refuse to admit that their curriculums' control the industry more than industry controls their curriculums).","This entire article could have been a single table","Because I can use it to turn out some infrastructure automation in a couple of days, and produce a ReST API in under a week.","Its has appeal because it's taught to students.The End.","Easy copypasta","Great tools that support it, like jupyter notebook. Amazing debugger. And great integration with ide. No one else has that!","Tooling sucks","Not compiled, weak typing, plug and play code libraries with pipUniversities love it, and have really changed programming from programming into connect the Python code fragments together that we give youEdit: I remember thinking during an assembly language course, why write assembly if every function call is a C API?Python goes the other way, why write in performant language if all you do is call various C/C++ libraries and glue together the outputs","AI and Machine learning that's why. Somebody ported the C libraries to python first and all the examples and documents were written in python afterwards.","Free IDE. Support libraries from enormous worldwide communities and most academic libraries for scientific analysis are made in Python. Easy syntax. No compiling into complex packaging. No overhead in methods with unnecessary syntax. Extreme cross platform usability. Run it from anywhere. No need to install thousands of resources just to run some code. No registering needed.Need something done? Write it in Python and execute it anywhere. Done.Coding was never about big companies earning thousands of dollars from you in licenses and software. It was always about the ease of use and accessibility.I do most of my Python coding from my Android phone when I have 5 minutes to spend at the airport before my flight while drinking a nice hot cup of cappuccino.","TIOBE represents the number of search results for any given language.That means the languages with the most articles or tutorials wins.That means that languages popular with beginners are highly overrepresented.Nobody in industry really thinks Python is most popular language, it clearly isn't.","Because it fits the bill for lot of tasks that need to get done. For example when I need to do some data manipulation or generation that only needs to work once ever, would I start a project in any other language? I would rather not. But whipping out a jupyter notebook for it is perfect for such tasks. In many ways python works great as an excel++ and that gives it a ton of everyday utility.Of course it does have it's downsides too and many of them. Python kind of sucks for anything that needs to be distributable. It's very meh at GUIs. If you have to do a lot of computation in actual python rather than offloading it all to dependencies, it's not particularly performant. Less said about threading the better...","answer: it's easy","My take is that the majority of devs are fine with writing below decent garbage as long as \"it outputs the right thing\", thus not wanting to put in more effort than the minimum.I literally had to explain how fetching the data with SQLAlchemy, filtering it IN PYTHON, then RETURNING IT as a list argument for further processing was not by any means acceptable. The response time for a single query REST API endpoint was 5+ seconds. After that I not only grew to hate the community but the language too.","Python is the language of choice of people who need to write code, but don't know how to code or want to learn beyond their specific requirements. Most notably mathematicians and scientists mSome of this is because of features it has, but a lot of it is the pure inertia of the belief that it's the right tool for this.It's not a terrible language, but if you need language features that don't fall under the umbrella of ease of access for highly educated non developers it's probably not a great choice.","To me it’s an aspect of the way the world as a whole has moved backwards away from civilization towards “Idiocracy.”Python was not a very good language when it was created. There were more capable, more self-documenting, more performant, less error-prone, etc. languages. On any distinguishing characteristic there were better ideas for how to do a programming language than Python. And numerous examples of such languages: various BASICS, various LISPs, etc.Since then, numerous languages have been released that seek to provide a better solution to the problems at hand than Python: C#, Rust, Julia. All-in-all, these languages are typically described as “too” sophisticated: “You talk like a fg and your shit’s r” to use the Idiocracy quote. The idea that someone could more reasonably seek out a language that helps them write better code than seeking out the worst common denominator is seen as effete pretense.And as we see a decline in society’s tolerance of any principle, there is a decline in the support for the idea that languages should be performant, self documenting, protect you from making mistakes, etc. The idea is that the world is chaos and by presuming to mess with that, we are overstepping our jurisdiction as humans. It’s the same principle as antivax, anti-regulation, etc. By believing that progress is possible, by working toward progress, you are somehow suspicious or nefarious.Of course the logical extension of that is the premise that “AI” (which doesn’t really exist) can simply write your programs for you. And then it doesn’t matter what language you use, and any mistakes in the program are not decipherable, since you don’t know how to program. And the idea that program could be constructed a priori to always produce the correct result is inconceivable to such people, and almost sinful.Of course this is also an aspect of the Agile/Scrum Taylorisation of software development as a profession: degrading the role of a developer into a cog, a button-pusher, whatever. By denying the premise that there is some creative or mental work happening on the part of the developer, he is turned into a simple day (or day-and-night) laborer. “ChatGPT/Copilot/etc could do this for you,” so no need to think, no need to know.If your software makes mistakes, that is unavoidable in an anti-progress mindset, just like the barbarians who now run Boeing have successfully brought us back into a world where aviation safety can’t be taken for granted by the public. But who could have believed aviation could be safe? It is not in the human being’s purview to decide questions of death and life. Just so, when the inevitable happens and a bug mindlessly copied from ChatGPT kills someone, we will shrug and say, at least the code was Pythonic!",""],"points":1418},{"text":["Open source Alliance : Accelerating Human Progress Through AI"],"points":0},{"text":["I created a reverse polish notation programming language after falling in love with old HP calculators","https://forth-standard.org/","It's called PostScript. Been around a very long time.","I was deeply in love with RPN in high school, loving my HP calculators, feeling so smug because I felt I had an edge over my school mates who were using... gasp, parentheses.But here is the dirty secret about this part:while still requiring fewer keystrokes compared to the infix notation.The reason why RPN calculators require fewer keystrokes is because they are asking YOU to do extra work.Sure, you don't need parentheses, but that's because the calculator is forcing you to parse that complex nested expression, find out the innermost one, push that one on the stack, and then walk your way out, little by little.There is no free lunch. Either you type fewer keystrokes and you think more, or you type more keystrokes, but you think less.","https://linux.die.net/man/1/dc","I'd always look up who I'm interviewing with before I show up. If they were in the industry for a bit, I'd bring my old RPN HP and use that for interview questions (non-software engineering) and we'd always end up talking about how great it was.but on my first day of work I'd always be using a TI-89 for daily tasks.","... something something...lex & yacc..."],"points":11},{"text":["Best development methodology"],"points":0},{"text":["Internals of the async/await pattern from first principles"],"points":0},{"text":["Let's create a Tree-sitter grammar","Amazing! I've been looking forward to a tree-sitter grammar for djot.I had written some basic scripts in lua as well as typescript to map the cursor position in a djot document to section metadata ---- from there onwards to call relevant info from, or cause 'side effects' in, the world outside the text editor.However the setup always ended up getting too convoluted with typescript (socket connection to a server, etc. etc.); and although both vim & neovim make it easy to work with lua, I really don't enjoy writing in that language ---- and recently I've migrated to emacs anyway. I implemented similar scripts using org-element; but org-mode syntax, in turn, is a little too busy for my taste; and 'hiding' the markup requires further error prone scripting.... so a tree-sitter grammar for djot might finally allow me to do what I want to do in emacs (which has had tree-sitter capability for a while now; and as of v. 29, it's built-in.)Really looking forward to working with this."],"points":2},{"text":["Introducing Natural Input for WebXR in Apple Vision Pro"],"points":0},{"text":["OpenJDK Java 22 Rolls Into GA With New Features","Noob here, running Pop_OS. I've been curious to try Java and was waiting for this release to do so. Is it best practice (on Linux at least) to download the OpenJDK from the central repository? If so, how long does it usually take for Debian/Ubuntu/Pop to add it?"],"points":1},{"text":["I made an astro template for web dev"],"points":0},{"text":["NiceGUI For Beginners: Build An UI to Python App in 5 Minutes"],"points":0},{"text":["Playing with Code: Programming-Adjacent Games"],"points":0},{"text":["What if the spec doesn't match the code?","Then the code is wrong. (Ok, the spec could be wrong, but that should be adjudicated prior to implementation by asking questions and then revising the spec.)","Then the code gets changed.If you want the software to work differently, update the spec first."],"points":0},{"text":["Experience With Locust? What Programs Do You Use For Load Tests?","I used Locust about 4 years ago when I inherited an e-commerce app with some very serious performance issues.I found it easy to get up and running, and was helpful for checking that the changes we were making did actually improve the performance.","I use a terraform deployment based on this repo: https://github.com/neilli-sable/locust_fargate","Hey everyone,what is your expirience with Locust?Pro's and Con's. What services do you utilize for Load Tests?We want to use them in a automated environment like a pipeline.Cheers Mr_LA"],"points":2},{"text":["Process is a Cost, Focus on Why","All too often, I see managers react to relatively minor hiccups by suggesting more process that will place a tax on all work in the future. Ideally, we would be able to calculate the relative cost of just dealing with a problem as-needed against the cost of implementing a process to reliably avoid the problem."],"points":5},{"text":["jnv: interactive JSON filter using jq","Looks neat, but why do I have to install through your preferred programming language's package management tool?Rust is definitely the one true path to god and all that jazz, I'm sure, but that doesn't make cargo a reasonable way to distribute tools to a diverse set of users.","Dang this looks useful, my first question was \"can i use this with k get and the gif cleared that right up"],"points":5},{"text":["The C3 programming language reaches 0.5.5 + has a new site"],"points":0},{"text":[".NET Developers Begging for Ecosystem Destruction","kekAdding an extra messaging library to the eco system is actually removing all other messaging libraries from the eco system. Trust me guys.Just look at DI containers! Theyre all gone! Dead! Cant use em anymore.All the logging libraries, DEAD I TELL YOU.","fake drama by ppl who like drama, commenting about drama 95% of .net developers aren't even involved with","who cares. you can use the built in implementation or a library. your choice. People still use newtonsoftjson instead of the built in one. People still use custom DI containers instead of the built in one.","Very few communities have a Daddy Microsoft with an army of professional engineers that are building such a broad range of general purpose application libraries.Take Amazon, for example: yes, they have a lot of contributions to OSS, but most of their contributes are for their libraries related to their own products. Relatively few of their OSS projects -- compared to Microsoft -- are general purpose application libraries that have nothing to do with AWS.It's both a boon and a bane. .NET projects tend to have very low external, third party dependencies and I'd say relatively low incidence of long-standing security issues because CVEs are continuously monitored and patched in a timely manner in first party libs and SDKs. This is great if you work in an enterprise environment where that matters. On the other hand, it also means that unless it's aligned with Microsoft's vision, it may take a long time to see features and capabilities rolled out compared to say Node where the huge community means that there's tremendous variety for everything and anything.But that comes with its own tradeoffs. Overall, I'd say \"Por que no los dos?\" I regularly use EF Core alongside of Dapper because both have their sweet spot. Messaging I can see being a bit more exclusive, but it feels central enough to modern compute patterns that a first party offering doesn't feel wrong.","I am a (professional) .NET developer since framework 1.1 and i gained a lot by all the tools MS put in my lap for free. That being said i absolutely do not agree with some of their choices.Some examples any my main arguments: - the entire 'builder' concept (i.e. HostBuilder) You need to google your options, not broadly supported by libraries, and you can't mix it. - asp.net DI Not transparent. Creat a method (configure) in your startup.cs and it gets magicly called. You can add parameters (if you know which) that magicly gets created. Etc. - entity framework How to do inefficient queries and keep programmers ignorant of the best language of the past 40 years (yes sql) - asp.net Mainly cause you have to have a special project instead of being able to simply add we service functionality by simply including a package. This last one annoys the hell out of me.Why can i not create a normal console app and add asp.net dependency and say: AspServer server = new(443, 'path/to/cert.crt'); server.UseStartup(x); await server.RunAsync(cancelationToken);","One of the concerns I have with this event/messaging epic, is that it will introduce a bunch of lowest common denominator abstractions that become pervasive, forcing everyone to \"conform\" to them.If the scope is just a nice set of client APIs to make integrating with the Azure stuff easier, that's one thing, but the title and body of the issue, makes the scope seem MUCH broader than that.I know a lot of people working with .NET like the Microsoft solution to all problems mindset, but it really isn't good for the long term health of the .NET OSS ecosystem. Microsoft literally can't do it all. So when they take over an area well serviced by OSS, it needs to be weighed against the loss of contributors and not working on areas under-serviced by OSS.","Okay, someone educate me on this one. I read a little bit through the thread and I totally don't get the drama.As far as I understand it, MS is building a general purpose API for WebJobs. And it will have some overlapping areas (basic message handling) with existing message broker clients. But why would it replace them? Each message broker and their respective clients have some peculiarities which can't be re-produced by MS.Sure, for a quick PoC you would probably use MS implementation to get messages quickly in and out. But for a real product, where you have to take advantage of the full feature-set of the message broker, you would still use the message brokers client.Just alone the forced parent POCO would deter most projects. I know it wouldn't be feasible in the projects I am working on. We often send binary data, anonymous classes or just primitive datatypes through the queues. All of which couldn't use that POCO.Call me an optimistic, but I don't see how that disrupts OSS."],"points":82},{"text":["C++ creator rebuts White House warning","Fair enough, but it's about more than the language itself. It's the ecosystem, and C++ has a ton of legacy dragging behind it. Rust's youth is its biggest weakness and (in this case) it's biggest strength. There are no legacy libraries to update to modern standards.FTA:Of the billions of lines of C++, few completely follow modern guidelines, and peoples’ notions of which aspects of safety are important differ.Backwards compatibility means backwards compatibility with old notions of safety.","Duplicate of https://www.reddit.com/r/programming/comments/1bhvwyd/c_creator_rebuts_white_house_warning/ ;)","I'm not saying he is wrong and I rather like modern C++. But you have to admit that the C++ community kept saying its the programmer not the language. It can be a pretty arrogant crowd.","I appreciate C++, and have a fair amount of experience of writing it both before and after C++11, but somehow these \"git gud\" arguments when discussing language safety don't impress me. If the language is safe if (and only if) you avoid all pitfalls, and refrain from using multiple core language features, then the language is not safe. If I put a bear trap in my living room, it's not safe just because I consider it common sense that you shouldn't step in bear traps.There are plenty of use cases where it's acceptable to sacrifice safety to gain other benefits (performance, backwards compatibility, etc), but let's not pretend C++ is safe because it has good reasons to abandon safety.","I'd be salty too if my life's work and it's compounding mistakes were called a national security risk by the government.","I see they quoted him from the email response, but do they post the whole thing anywhere?","Of course he would, it's his cash cow.","One ironic thing is that the only virtue of C++ that I used was pointers in creating highly optimized data structures. These were dangerous and required rigorous attention to detail and massive testing to absolutely make sure they were correct.Often graph theory was all over these and there was little chance a non mathematically inclined junior programmer would do anything but break them.I now use rust and just don't do this crap.","Strustrup's worst nightmare is C++ falling into disuse.This is also one of my wet dreams. The language is unfixable, it needs to be phased out.","How do you write viruses that exploit memory vulnerabilities without C++? Does Rust let you do buffer overflows?","So im fine, since im following RAII strictly? I love RAII, i think its beautiful.","Anyone who thinks there is a magical language decision you can make that will overcome sloppy development practices and total lack of maintenance is an idiot.Last C# shop I worked at didn't use any version control did not even have test environments just dev's desktop and prod, when the senior dev left (after working there 10 years) he handed over a handful of usb drives (aka his code repo) and had run a code fuzzer on at least half of his work.","Ok so people shouldn't use C-style pointers anymore. Are you, Bjarne, personally going to go to every single developer who writes code that will be used in government and tell them? Why do C-style pointers even exist in C++? Backwards compatibility my ass. Code from 30 years ago has no business running on modern systems and modern developers shouldn't even be given the option to write unsafe code or at least it should be made as hard as possible. The problem with C++ is that memory-safety is NOT the default. No amount of pointer wrappers is gonna change that.","Strustrup should shut the fuck up, the fucking idiot created the worst programming language to date, worst of all, he said he got into computer science by accident and doesn't like computers. A man who dislikes computers should not dictate to us how to build our software.","C++ gives really strong guarantees, which are about as strong as C. If you don't hit UB, code is completely safe and you can reason about it. If you hit UB, your code is not valid program, therefore not counted toward broken guarantees.","25 years ago my prof handed out a copy of this article on the last day of class.Stroustrup InterviewProf told us Stroustrup had seen it and had commented \"if it were really written by me it would be funnier\". ( oh yes, Stroustrup always one for writing comedy O_oBut, hearing him defending C++ against the White House?Almost as funny as the interview above!","I rebut C++ creator’s rebuttal. C++ needs to die yesterday.","That WH paper was a joke anyway. It was probably written by non technical people who did a Wikipedia research.","i feel like you have to assume government contract corruption is at the heart of thisa sly way to undermine your C++ competitor","\"move to memory safe languages\" was always copy written by some guilded asshat of nepotistic linage. How fucking tone def would it sound in the surgeon general suggested everyone move to robot assisted, laser scalpels?"],"points":727},{"text":["How Tinder Scaled to 1.6 Billion Swipes per Day","They store the user information in a key-value database like Amazon DynamoDBThey send swipes to a data stream like Amazon KinesisThey put the disliked profiles by a person into a data storage like Amazon S3So... is this article just guessing at how they do it? Is it an ad for AWS?","How much is their DynamoDB bill? It destroys bottom lines lol.","Just wait till you hear about how Plenty of Fish runs off a single MS SQL server that does 840,000,000 read/writes a day.. LOL. I was the tech lead there.. Microsoft said they couldn’t support us because they “didn’t design SQL Server for those kinds of loads”. Was a fun place to work. It’s owned by Match Group that also owns Tinder, OKC, Hinge and a few hundred other online dating platforms around the world.","More ChatGPT articles? And from the same source even?","The goal of a good matchmaking app should be less swipes, not more. It's obvious that the goal of Tinder is to keep you lonely (and paying) as long as possible. Please save your money and mental health and don't use it.","Where is the scalability issue with Tinder? I would the all the date would have very flexible consistency requirements, and the data can be easily partitioned by region or more. Even the incoming data can be partition across N number of Kafkaesque pipes.I didn't read the article, but am I missing something?","Bots swiping each other, that's how.","Can we all agree to stop measuring things in transactions per day? It both makes it sound huge and also ignores the real problem of what your peak operations per second are (4 am tends to really pull down the average).They are averaging 18.5k/s which is pretty interesting. But I bet that’s peaking at more than 35k/sec, which is closer to the aggregate traffic of my last employers’s entire cluster before we memcached all the things.","Does anyone actually spend $20 a week for unlimited swipes?? To me that just seems like an insane amount to pay","This blog takes potentially interesting topics and writes boring, surface-level \"explainers\" that aren't going to teach anyone anything useful about design.Like yeah, on one hand the unknown in the headline is obviously horizontal scaling through geosharding. But there's still plenty of interesting design blogs where the hook is less interesting than this one.I got baited again.","their dynamoDB bill must be high lol","How much you want to bet they are actually using kafka over dynamo","horizontally?","What a poor article 😞","Money.","That’s just about 18.5k swipes per Second. Not that much actually","it takes a lot of technical effort to bang an ugly chick","I'm single!"],"points":1217},{"text":["Why does a extraneous build step make my Zig app 10x faster?","If I know the maximum memory requirements of my Ethereum interpreter at compile time, I can outperform the official implementation by 3x.You could reap most of the benefit by passing a maximum heap size as an argument, allocating that, and then using that as the argument to FixedBufferAllocator.It would be a single allocation, so relatively fast -- you could even short-circuit the general purpose allocator and ask the OS directly -- and a fixed-cost overhead.","Pretty cool write up! I had no idea that bash pipes execute concurrently like that.","make that a comptime 2000 bytes, and you will do even better.","[deleted]"],"points":152},{"text":["Product Development Methodologies [Inspired by Hannibal & Rome]","This tactical innovation can be associated with creativity and problem-solving skills.But what’s more tactical innovation was – bridge-making for elephants while crossing the Alps!These examples don't really seem to teach meaningfully lessons. While Hannibal did achieve amazing feats, most of his elephants died in the process of getting to Rome. He didn't even use them in the initial attacks on Rome. When he did use his elephants, they back fired immensely (they literally ran into the direction of Hannibal's army).","I understand the desire to take a historical leader and relate it to software concepts, but I feel that better messages can be taken from Hannibals military achievements. Maybe the usage of having a strategy before committing to a plan, or the importance of moral in a team.I feel the article just wants to use Hannibal because he is a \"cool\" person, but doesn't really go into meaningful lessons from the actual story."],"points":6},{"text":["How to Install GitHub Copilot in Visual Studio","Requires Visual Studio 2022 17.5.5 or later."],"points":0},{"text":["Build System Schism: The Curse of Meta Build Systems","The previous 16 tools all got it wrong, but surely your 17th one will get it just right.","As the legend goes, Stuart Feldman was working at Bell Labs, and he had a problem.I expected this to continue \"Then he invented Make, now he has two problems\".Well, I guess that something made him loathe to give up Make because he chose the latter and made Autoconf.Now we have three.","The article is interesting, and it covers some points really well, but seems to miss the ugly part of some key points and remains optimistic which makes me wonder what will turn out.I actually believe you don't need Turing Completeness in a build system. As a matter of fact a key feature of any build system is that it has to actually build the thing, and if it can build it, then it must halt, and you can't guarantee that on a Turing Complete system.That said it's not easy, and Total Functional programming langauges are still to find a way to be pragmatic to use, and no one has mapped those to build system languages, IMHO.The thing is, the challenge is, in a simple mistake that I keep seeing build systems do:So what if you didn’t need to specify all of the dependencies of a target? What if you could find them during the build itself using the source code itself?And the author answers it themselves:because <language> has a built-in build system and good module support.Though I would change that into:because <language> has a build-in requirement to define dependencies explicitly in code.In C/C++ each file doesn't define dependencies. Sure we have header files, but header files aren't dependencies, they are just common definitions. Header files are a pre-processor hack, you could copy paste all the definitions in yourself, and you'd get files that have 0 explicit dependencies. And the compiler doesn't even care, it just generates .o files and calls it a day, each one with their implicit dependencies, it's only when you get to the linker that you see what is going on. What files do those .o files need? Only the linker knows! Actually no, not even the linker, the linker just knows what names need implementations, but it has no idea where they are.Well maybe that was C/C++, but modern languages haven't got that issue right? Well lets talk Java, a language were you have dependencies that you only need to compile the code, that you only need at runtime, and that you need at both! Which is which? Who knows, run the code and see if it breaks! Is it too bloated and you want to shrink it? That's not the java way! Don't be silly you just ship the entire SunOS!And see there's the thing: if you want to be grow into a great looking, big, strong adult you can't just eat cake you also have to eat your veggies, uhm sorry, right advice for the wrong group. Let me try that again: if you want your build to be sane, you have to list your dependencies explicitly somewhere.Here's my hot take: if you want a general build system, you have to explicitly define dependencies in it, statically. You can have tools that generate these dependencies for languages that are explicit, but I would say that autoconf got it wrong: these tools shouldn't be run as part of the build process, but instead they should be pre-ran on any code-change, enforced by a CI system for modern things. If you think about it that was the genius of make: each step gets explicitly created as artifact files, which mean you don't need to rerun it each time. This also means it's a lot easier to reason about what the build system is doing because you can see the dependencies. So when I update my go project and try to submit a PR, my CI system says that my build-files are showing a diff when they run the godeps (or whatever) tool, so I run it locally, see the diff, realize that I forgot to explicit add some files/dependencies, and then commit that to my PR which then gets submitted. If my project where C or Java though, the only way to be 97% sure is to compile and test.We can do a minor improvement, we can allow our build system to define a dynamic tool that generates the dependencies, but then this means that this tool is required for any dependency/build analysis (consider that you don't need compilers, linkers, or any other external tool to be able to do this normally, so it goes out of the way). It makes the tool more complex and has some gotchas for the engineers setting up things to work with it, but it's not an unreasonable tradeoff, that one is a matter of opinions. It also means that planning a build may not terminate (since we're calling arbitrary Turing machines now) which is a bitch to debug, since you have to work off an incomplete, and broken action-tree, but there's ways to make this work it just adds more complexity to the tool (which now has to isolate and define the problem well enough) but it doesn't make the model or what the developer is doing more complex really.But you can't have dependency analysis for free on every language. Because we can only easily tell what we didn't find, but have no idea to know where to find it, it's hard to give a good error other than \"when compiling we can't find <the thing> you should go and find it and give us that dependency\".","A much simpler way to put it: it sucks when a programming language does not have an officially supported build system.All of the weird issues with building C and C++ are because no one is in charge of making builds work well. Every build issue can be explained away as “you’re doing it wrong”.I really respect how languages like Go and Rust have one way to build and if that doesn’t work well you can file a bug report and actually work towards an official solution.","This article misses a major feature of a (meta) build system: Can my IDE of choice open a project using this build system?","That's interesting. I'll share some of my opinion following opinion regarding how Nix could be a build system (one that I actually use, but not for compiling C files): - Nix have a really nice approach to things. Hashing both the input and the input lead to a really good way to cache stuff, and declaring all inputs allow to have cloud builds too. - One downside is that you can't do early breakoff. But recent work allow to rewrite the hash in the output based on its input to a hash based on the output content, which now allow for early breakoff. - There are two reason I believe Nix can be too generalized: - Performance issue (it can have to parse and run many source file and build the dependancy graph. But actually it's still shorter than running autoconf in most projects) - The fact that it is conceived in a way that most dependancies come from the build itself. For exemple, you will need to use gcc of NixPkgs (or the package you manually create. But that's inpractical). Actually, every inputs are added to the cache be it from your code repo or dependancies fetched from internet (or a cloud cache).n But first and foremost the reason not to use Nix for building sources as you describe is the lack of toolingStill, some things that can be done include: - Using one compilation units per crates in Rust (by parsing the Cargo.toml and lock file and directly calling rustc) - Split a video files into each of their frames, and upscale them individually (something I use to build by animated wallpaper where the source is a not very high resolution GIF) - Build a whole operating system (or a container containing said os). It's what NixOS and NixPkgs does, and the way it's meant to be used.Following those reflection, I don't thing Nix in particular can make a really good build system, but I do think that a E2E build system that use hashing could be very good.(maybe one day there will be a Make2Nix, so hashing could be used with Make. It'll be very good at detecting hidden dependancy, and might also be usefull for CI with it's caching)","Author's lessons about make being designed in a weekend:Simple implementations lead to disasters, andBreaking compatibility is sometimes necessary; do it as early as possible.The \"disaster\" here is that Make requires Tabs for indentation :DSorry but no. Maybe you don't like that, but it works, it does the job. It's NOT a disaster, or even a bad decision.About breaking compatibility: that's the last thing you want from your build system. Make got it right. Gradle has it wrong. I've had to update my builds so many times over the years that next project I need a build system I will use anything but Gradle. I already wrote my own build system just to avoid Gradle!","I like make. It's pretty simple especially for custom rules. I tend to use POSIX make since ever but now I also go with GNU make when needed. I mean I convert custom files with just like%.h: %.png    bin $< $>On POSIX you use .png.h and add the extensions into .SUFFIXES.With CMake, meh. You create a list that you iterate to call add_custom_command. You create a list with all output generated and add them as dependencies to an other target. But yes, at least it's portable.Another gripe: if I use CMake to cross compile then I no longer build host executables to be ran at the same time (e.g preprocess, tests). Again, with Make it just basically using CC and an other macro (e.g. HOST_CC).GNU make is really powerful enough for most situations. The main problem is lack of tool support and... Windows. There are various projets that are built with pure GNU make with no hassle.Other than that, I still recommend CMake for portable uses even though it has various warts.","It would have been nice to have a quick explanation what a suspending or restarting scheduler is without having to go read yet another paper, but that's okay.I've never worked on large software myself but hear tell of the baroque build systems they engender. If/when you need Turing completeness, to me that says you should use a proper scripting language, preferably one everyone knows and likes, which I suppose means Python or Javascript these days. It will be interesting to see what Gavin's answer is here.Even though Make usually meets my modest needs, we can obviously do better than anything in popular use right now so I look forward to April 2. I just hope the cloud component is optional because I am not working with other programmers or even in a company.","However, there seems to be some wind shifting; there is a new type of build system coming to town.That is not accurate. Direct build system, or what the article calls end to end, have existed for decades. And existed before cmake at least. Look into Perforce Jam. Or B2, previously Boost Build, which is the one I've been maintaining for more than 22 years.","Cmake doesn’t exist because Make sucks, CMake exists because Make doesn’t work on Windows. If you’re only targeting Systemd-based systems, then sure, you probably can suffice with Make.","I stopped using C++ in 2012 and it's kinda funny and kinda sad that the state of the art is exactly how I remember it.At the time there was another promising CMake-alternative called Premake which let you write arbitrary Lua to generate your makefiles / vcproj files. But I think it never really took off.But anyway for you C++ users out there, you should know that you are holding on to an ancient & unfixable ecosystem. There are so many better options today, and so many problems (including build systems) are solved or at least drastically improved. You don't actually have to spend your days solving self-inflicted puzzles to things that your customers don't care about.","I half-expected the article to talk about Boost and BJam (where, in order to build the system, you first need to build the build system).","This article doesn't do enough work to define a meta build system to justify its claims. There's no reason you can't metaprogram buck/shake/bazel/etc. build specifications.","No IMake? I remember working with IMake back in the 1980s and thinking \"It doesn't get much worse than this.\"Then it did.","I wonder why SCons is classified as meta buildsystem. It looks more like an E2E buildsystem in nearly all the mentioned categories.","There are two interesting developments in this space.One is to create packaging systems which use and support a variety other more basic build tools to build system distributions. Some of them are made in a way that the same tools support building of programs in development and managing arbitrary dependencies, especially Nix and Rust.Another is the development of a model different to make. Make (and nearly all colleagues) use a text file that describes a dependency graph mixed with build instructions which are shell commands. A completely different way invented by D.J. Bernstein is to turn this inside out into a shell script which executes build commands as well as commands that describe dependencies between artifacts. This is what the \"redo\" family of tools does, and I think they are clearly superior to make as base tools. (But they do not replace things like autoconf which answers the question which dependencies and flags to use). redo mixes better with immutable and reproducible builds, and can be faster for development since it captures dependencies more correctly (no \"make clean\" just to be safe). But maybe in the end, \"make\" is good enough. It is not really a problem to build a program - managing its dependencies is, which Guix does solve well."],"points":232}]