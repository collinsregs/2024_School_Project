[{"text":["How to develop an app that allows me to add/edit IPTC data on photos"],"points":0},{"text":["Entire Blind 75 - Leetcode interview questions solved - cheers."],"points":0},{"text":["Plotteus | The JavaScript library for data storytelling","Here's the gist of it:Plotteus is an open-source JavaScript library designed for data storytelling. It allows full control over animations, enabling more natural and engaging data-driven stories. The library supports seamless transitions between different chart types and elements, including colors. It includes six chart types like bar, bubble, and scatter, and offers features like config-based operation, grouping support, and theme adaptability to any background color. The focus is on empowering the audience to interact with the data at their own pace, making stories more memorable.If you don't like the summary, just downvote and I'll try to delete the comment eventually üëç","This is pretty sweet, thanks for sharing u/fagnerbrack","Uhg... that's some awful scroll jacking. I scroll and then I'm forced to wait for janky animations to complete before I can scroll some more. Rinse repeat... 3 times?Not a good look."],"points":0},{"text":["Python errors as values: Comparing useful patterns from Go and Rust","except code you call can still throw despite you writing non throwing code, which means you have to handle exceptions being thrown as well"],"points":1},{"text":["Natural Language Programming - Building applications with natural English","Is English even the best natural language to build something? how much context do you need to explain something simple in a proper way and without room for interpretation?","Do the videos have an AI voiceover? I noticed it pronounce additional as \"additinal\" which sounded like an AI reading a typo. Either way, it shows virtually no detail on what development actually looks like, so I suspect it is as limited as chat GPT currently is. There was someone who made a POC on this, which basically did the same thing, but they showed how limited it was and you had to do a lot of manual tweaking. It was basically just Microsoft's copilot.","This is the stupidest idea in the history of computer science.What we need is better programming languages, not worse ones. Much less something like english which is literally the worst possible."],"points":1},{"text":["Uiverse.io 2.0 - +3500 UI Elements, copy the code or use in Figma!"],"points":0},{"text":["Becoming a go-to person gets you promoted. Here's how to do it as a software engineer.","You can just as easily be punished for this behavior. You might be helping the team overall, but if your boss doesn‚Äôt value this they‚Äôll see it as you being distracted.","Becoming a go-to-person gets you everyone else's work for no benefit.","Promoted and burnt-out.","In my experience, it gets you more urgent DMs for the same pay.","Unless it's the goto for glue work...\"we have this really impactful project, you write good docs can you write them for us\" and then you wonder why you don't get recognition when the project is delivered.","All hard work will be rewarded with more work.","Basically:The post discusses strategies for software engineers to become the go-to person in their team, which can lead to promotions. It emphasizes the importance of increasing one's scope, impact, and ownership at work. Specific examples include becoming an expert in certain areas like database, Python, caching, frontend, or TypeScript, or specializing in particular product domains. The article suggests that this expertise will make one indispensable and a key player in the team.If you don't like the summary, just downvote and I'll try to delete the comment eventually üëç","Getting promoted depends on your desired track. Being a go-to person isn‚Äôt necessarily the direction to go.If you want to remain an individual contributor, be an expert in something, very competent in adjacent technologies, and understand what depends on those technologies. Be humble about your expertise but confident.Becoming an engineering leader requires all that but also being aware of other teams, their priorities, and their limitations. You also need to be aware of your team‚Äôs strengths and goals and how to help members accomplish their goals. You also have to be capable of articulating that to other teams and executive leadership."],"points":150},{"text":["All the ways to manage files in Neovim"],"points":0},{"text":["I looked through attacks in my access logs. Here's what I found"],"points":0},{"text":["I abandoned OpenLiteSpeed and went back to good ol‚Äô Nginx","Having a similar experience with CyberPanel. OLS+LSPHP >>> PHP-FPM, and LSCache is great, but for literally everything that isn't PHP-related I bail out to Nginx: I reverse-proxy PHP requests to OLS but let Nginx take care of everything else.","[deleted]","Good for you!. Many people I know seem to be using caddy these days though."],"points":2},{"text":["Improve Your Productivity with Google Sheets Automation"],"points":0},{"text":["Apache OpenDAL‚Ñ¢, a library for accessing data freely supporting various languages (C, C++, Haskell, LUA, Ruby, Swift, Zig, Java, Node.js, Python) is now graduated and in search for GSoC 2024 projects!"],"points":0},{"text":["Engineering Progression for Humans","Digest Version:The blog post discusses strategies for career advancement in engineering, focusing on personal development rather than just technical skills. It emphasizes the importance of soft skills, such as communication and leadership, in becoming a valuable team member. The post also explores how engineers can position themselves as go-to experts in their field, thereby increasing their visibility and opportunities for promotion. It provides insights on balancing technical expertise with interpersonal skills to build a well-rounded and successful engineering career.If you don't like the summary, just downvote and I'll try to delete the comment eventually üëç"],"points":0},{"text":["2 Minute Tips: The Strategy Pattern","I enjoyed reading this, I like your writing style. I'm still going to pick some nits :)The strategy pattern should encapsulate and make interchangeable the possible implementations, *independently from the clients that use it*.In your example, the client has to set a property before using it, defeating the purpose IMO, and introducing potential issues.It would be safer in this case to allow the client to name the implementation it wants to use (seeing as they have to know about them all anyway) in an overload argument. This way multiple clients can execute the sort method with different implementations and not have to worry about the current state of the strategy property.Even better if there is some internal, automatic way of selecting the strategy.Have a look at how the Sort method works in a framework like dotnet. The remarks on each of those methods tells you exactly how the system *internally* picks an implementation (the strategy).Optionally, the client can pass in an IComparer to specify their own strategy *if they want*.","tl;dr: higher-order functions in the kingdom of nouns.","Interesting, now I wonder how it differs from dependency injection ü§î"],"points":9},{"text":["Candidate Generation Using a Two-Tower Approach with Expedia Group Traveler Data","Here's a summary to help you with the decision to read the post or not:The post explores the implementation of a two-tower approach to candidate generation using Expedia Group's extensive traveler data. This technique aims to enhance the personalization and efficiency of travel recommendations. The method involves using separate models for query and item representation, allowing for more precise matching between user preferences and available options. The post details the benefits of this approach in improving the accuracy and relevance of travel suggestions, demonstrating its effectiveness in the context of the Expedia Group's extensive travel-related datasets.If you don't like the summary, just downvote and I'll try to delete the comment eventually üëç"],"points":0},{"text":["New GitHub Copilot Research Finds 'Downward Pressure on Code Quality' -- Visual Studio Magazine","It's like people think LLMs are a universal tool to generated solutions to each possible problem. But they are only good for one thing. Generating remixes of texts that already existed. The more AI generated stuff exists, the fewer valid learning resources exist, the worse the results get. It's pretty much already observable.","I was having a convo with another senior at work and we have both noticed and hypothesise that the juniors are using ai assistant stuff to produce code which often doesn't make sense or is clearly suboptimal.","The wild thing for me has been seeing people use AI to generate tests that validate the behaviour of their implementation ‚Äúautomatically‚Äù. This of course results in buggy behaviour being enshrined in a test suite that nobody has validated.","This feels obvious to anyone who has used copilot.¬† It almost never gets it 100% right, and relies on human proofreading.¬† All this is saying is that humans are better at catching mistakes in their own code as they write it vs reading ai assisted code.The real question is \"even with increased churn is ai assistance still faster\"","It‚Äôs one of the reasons I‚Äôm against AI-assisted code. The challenge in writing good code is recognizing patterns and trying to express what needs to be done in as little code as possible. Refactoring and refining should be a major part of development but it‚Äôs usually seen as an afterthought.But it‚Äôs vital for the longevity of a project. One of our code bases turned into a giant onion of abstraction. Some would consider it ‚Äúclean‚Äù but it was absolutely incomprehensible. And because of that highly inefficient. I‚Äôm talking about requesting the same data 12 times because different parts of the system relied on it. It was a mess. Luckily we had the opportunity to refactor and simplify and flatten the codebase which made adding new features a breeze. But I worry this ‚Äúart‚Äù is lost when everybody just pastes in suggestions from an algorithm that has no clue what code actually is.","It's easy for me to assume that my skills as a programmer would degrade if I used coding tools like these.Use it or lose it, they always say.","It just seems to me that LLM are of limited use","Been a user of copilot for the past year, and I've noticed that :it's very good at guessing what you're going to write in very popular languages like JS, TS or Python.It's a good tool to churn out some boilerplate code (for unit tests for instance). I had to write a whole battery of unit tests the past 2 weeks, I managed the task in just under 6 work days, to write probably 150 tests. Most of these were very similar to one another, so I made a quick snipped to give the name of the tests, and the comments to guide the AI into writing the proper tests. Made it a breeze to implement, by the end of things, I was able to churn about 40 tests in a day.Where Copilot gets useless is when it doesn't have any idea of what the code is supposed to do in the first place. That's when the tool really is just fancier code completion. Other than that, for very common algorithms, it gets the job done, and when it generates 5 to 10 lines, it's not the end of the world to either proofread, or just write manually, and let it complete shorter code snippets.","The problem for me is that, when writing Rust, the suggestions are often wrong. Too often. The corpus there just isn't large enough.Switching to TypeScript, it frequently it suggests outdated things.I think that copy pasting from Stack Overflow is inherently less bad than the AI suggestions.When you copy paste from SO you know the answer is not for your question. It's the answer for someone else's question that happens to match your question.The AI answer however is presented to us as the answer to our question. But it's not. It's just the logical completion of the previous tokens, whether that is text or the code.And I don't struggle with the logical completions. They're plumbing, but not hard.But the whole AI movement makes me look slow when I'm actually writhing code that answers the business questions. And there the context is in my head and not in the code. This is the engineering part.","I almost never use it to write code, though it did help need get started on a tricky recursive function I needed to write one day.It's great for education though.¬† Really valuable when you come up to something you aren't familiar with.","Github copilot is useful, but it recently generated a a comment to a YouTube link for REM‚Äôs end of the world. I realize this sounds fake. I wish it was, but its not lol","We really need to be clearer on the distinction between actual artificial intelligence and machine learning models, because even in this thread for programmers there are people who have uncritically embraced the hype","I think the technology's to young to really draw any strong conclusions from, but i do think the inevitable consequence of this sort of technology is less code reuse. It would actually be really surprising to me if it did have high code reuse, just due to how it works.","ya think?","Is it any wonder when it suggests noob mistakes to you.I've been using it with react, and it always suggests that I toggle state directly, like setShowThing(!show thing) instead of setShowThing(curr => !curr).This is a common newbie mistake, so because it is common, it is heavily weighted, so it's heavily suggested, so it's common, repeat.","Gee, who could have predicted that leaning on an AI assistant to pump out code faster to satisfy product managers' desires for moving faster would produce lower quality code? /s","You are telling me the robot trained on the web, which consists of mostly bad code and questions about bad code, is...bad at code?","I‚Äôve found copilot very helpful as a time saver for writing any rote/repetitive/obvious code: finishing a spec that‚Äôs 80% the same to the one above it, template boilerplate, very simple convenience methods, stuff like that.For anything more complicated I‚Äôve found it a distraction. I‚Äôve configured it to only suggest code when a hotkey is pressed, which feels like it should be the default. I summon the suggestions only when I feel very confident it‚Äôll do the right thing so they don‚Äôt get in the way.","All of this effort putting \"AI\" into code generation, all I want is fancier static analysis. It'd match the Copilot name a lot better, too.","I've seen ChatGPT used at work by newbies to code things they don't understand, and I think that's harmful in multiple ways: it increases the chance of latent bugs and postpones, perhaps indefinitely, technical growth. In one respect that's good for people who take the time for true self-development, as it creates endless long-term opportunity, but it can be a short-term hindrance. I try to rescue people from this when I can.I've also seen it used more than once now as an authority during arguments, again by newbies and sometimes supporting a wrong position. Unfortunately the proponent in such a case isn't equipped to realize their mistake easily, and if it's a particularly pushy person may even double down.Over-use of ChatGPT for technical work seems to go generally with a somewhat quick-and-easy/lazy mindset. Such personality types arguably aren't cut out for acquisition of deep expertise in the first place.","are you supposed to be surprised?","No duh. I don't know why people think AI tools are going to write perfect code. It can be a great assistant for sure...but you really don't want to just blindly trust it like Tesla autopilot.I'm very convinced at this point that we'll see a major global Internet security event due to someone being lazy using AI and not reviewing the code.Granted this could (and has) happen without AI in the picture, but AI only makes people even lazier...but you know, it's got what plants crave.","This is such a weird article and weird whitepaper. \"Churn\" is nebulous. Have any of you commenting on the \"churn\" in this paper even taken the time to lookup what it means? Aka read the whitepaper?I did.It means \"code that was significantly changed or removed within 2 weeks of commit\". Now. That could be significant, but is it a guarantee of \"churn\"? That could just be that we have the ability to refactor faster. Hell it might be a beneficial thing.I think this analysis of numbers without discernment is meaningless. And I think you should all take the time to read through things before you form hasty opinions.The only possible takeaway is that, code is written and updated faster. Whether that's good or bad is not able to be determined. Much less the wild ass leap this article took about code quality.","Better LLMs will fix this in the near future.","Because idiots think AI is intelligent in the sense of replacing them","GPT is great for i18n (copy paste entire Vue component, tell it to use vue-i18n component interpolation when necessary and to give you the extracted string in JSON format, done).Copilot is great to generate logging messages based on the context. Most of the time it just needs one example of how you like to format the string, and you then just write logger.info and tab to auto complete.As for finding complete solutions, they both suck, I almost never use them.","Should it be writing your core logic for you? No. But it does a pretty good job creating documentation (like javadocs) and initial unit tests. That alone is a big productivity boost.","I wonder how this looks if you break it down by how users are working with copilot. Personally (as a grad-student mind you, so project complexity is limited) I find it to be a very effective autocomplete if it's essentially blindingly obvious what I already want to write. However, the moment it tries to make any sort of structural decision I find it to be thoroughly unhelpful","If you give such a tool to someone without much experience (i.e. knows what good code means) and/or someone working in a team without good coding standards, it will decrease quality.Personally I've found these tools be to useful (I use CodeWhisperer daily at work). Helpful with completing simple/repetitive logic quicker, and it also picks up on your coding style after a while making it more robust. Writing skeleton tests, all in the same style, was a breeze for example. Overall, a time saver if used correctly.","AI coding assistant is a complement to a human developer. For example I was using it a few days ago.It was good at generating tests after I gave it the source and my examples. Saved me a lot of typing, but I still had cleanup to do, and had to correct a few cases.For another task, It was useful because it was more familiar with SQLAlchemy then I was. Although it couldn't solve the problem to save it's life (modify my query to search for email ignoring periods in the local part but not the domain part), it's multiple failed attempts (and wow were they failures) did educate me on the various mechanisms in the library available, allowing me to solve it myself.It's really at the level of a really exited intern that is really good at research, by lacks judgement.","My own experience with copilot (in python) is it's pretty decent and boilerplating the boring stuff. As soon as you start tinkering, needing to deal with edge cases and whatnot, it's easier and better to do it yourself as it takes more effort to engineer the prompt than it does to just write the code.","Has anyone used the AI \"tools\" - I get downvoted every time, but I'll keep saying it, they're terrible. Copilot is mediocre at best right now; I have every hope that it improves and I have little doubt it will, but right now it's at best marginally better than google half of the time","Turns out mindlessly copying code from any source isn't a good ideaWhich is why I always take issue with the folk wisdom about great developers copying.These things are great for getting a rough idea of something, but they cannot replace thinking or knowing your job.","There is a strange psychology with co-pilot autocomplete. The code completions look good on the surface and it builds a bad habit of accepting it and then debugging it later, as opposed to reasoning about it upfront.I‚Äôve found myself wasting more time fixing bad copilot code versus just writing it myself.","Yeah this matches what I found. You have to use it for small snippets and really test it out. Usually it's spot on but sometimes it inserts something that looks right but does something odd.","I‚Äôm mean, it was pretty damn obvious LLMs can‚Äôt make good code. Ask it to do anything non-trivial. But they are so useful for jumping into a new language quickly, learning the syntax."],"points":1223},{"text":["Java‚Äôs Static Final Variables Explained","Yesss finally some blogspam!"],"points":0},{"text":["Vague Feedback Blocking your Promotion to Senior Software Engineer?","Yes, but for Staff. Literally had a meeting about how to get to staff where they said to be in some leadership groups. These groups are focused on a certain technology and dictate certain directions. Guess what, I'm in 3 of them... That rug was pulled so fast, and moved to me needing to lead one of them"],"points":1},{"text":["Being a Senior IC","Key points:The post discusses the role and expectations of a Senior Individual Contributor (IC) in the tech industry, particularly at Meta (formerly Facebook). It delves into the unique challenges and responsibilities that come with this senior position, emphasizing the importance of not only technical expertise but also soft skills like leadership, mentorship, and the ability to influence without authority. The article provides insights into how Senior ICs can effectively navigate their roles within large tech companies, contributing to strategic decisions and fostering a collaborative work environment.If you don't like the summary, just downvote and I'll try to delete the comment eventually üëç","I hate it when I accidentally become a Senior Integrated Circuit"],"points":1},{"text":["Turns out organizations exist for a reason - The things nobody wants to pay for [LWN.net]","Found this great read that gives a little history over corporate contributions to OSS and how they haven't found a critical mass at creating a movement anymore then home-grown inspiration any more then the die-hards at GNU.If you've ever been a part of any large enterprise team, you might have seen this pattern too. Money thrown at engineering when there's a red-hot problem or the tech is the latest talk, but once long-term ownership sets in, you see it was less a commitment to the principles, and more an investment in a recent problem.IMO, this is one reason the Apache foundation exists, to hire engineers to provide some key \"extra\" roles such as localization or documentation for OSS code that is instrumental to most modern-day engineers.","Companies, working in their own interest, have built up our body of free software hugely; it is almost as if this capitalism thing actually works.If this is the highest you can dream, sure, but if you want something that works so well that you don't have to write articles about how poorly they're working, then capitalism doesn't seem too hot given the contents of this article."],"points":7},{"text":["üöÄ Elevate Your Unity Game Development with Zenject üéÆ"],"points":0},{"text":["Building Simple Http Client in Java"],"points":0},{"text":["Visualising Extendible Hash Tables"],"points":0},{"text":["Why hasn't structural editing caught on?","I think the simple answer is that it is really expensive to maintain correctly structured code while writing it.For example, we are used to writing \"[1, 2, 3\" and then finishing that off with a \"]\".But that initial fragment isn't structurally sound, so you couldn't have it in a structural editor, per se, or it would need to be handled as some special case.Which gives two approaches:force input to be structurally sound and figure out a way to make that efficientallow text to transition between structurally sound and unsound formsMost editors have focused on (2) with pretty good success.I have yet to see a reasonable solution for (1).","I'm the author of Combobulate, a structured editing and movement package for Emacs. So this is just my viewpoint, although I agree with Ethan pretty much all of what he says, even if his talk is a few years out of date now, and things have advanced a bit since then.The problem is there is usually an infinite number of choices that can reasonably follow most production rules, and you'll have to build an interface that can credibly provide just the ones a programmer think they'd want to see, which is a tricky thing indeed to get right. Then there's the fact -- as others have alluded to here -- that if you write invalid code, then it's much harder (or impossible) to provide the user with valid and useful editing options.Secondly, there's the hidden cost of tree editing: you have to format your newly-minted code! That is not trivial: whitespace, newlines, indentation and formatting styles have to be accounted for, at least a little bit.Most programmers want to put their code into a broken state all the time: whether it's refactoring or just typing out a line of code.Structured editing/movement adds a lot of value to all manner of ancillary tasks, though: select all words named \"foo\" and let me edit them in parallel; find all function calls called bar; expand ever-larger selections of text, by syntactic unit; better and more correct navigation; complex search and highlighting.So, having a concrete syntax tree is very useful, but you're also drinking from the fire hose, and all you've really done is formalise all the problems you had with regex/ad hoc parsing code. You haven't really 'solved' most of them with a CST.","Now I know what to call the thing I've been wishing for and advocating since like, 2000.","Because the tree structure provides little useful information for \"what comes next\". For example, you can give GPT a function name in totally bad pseudo code syntax and it will spew out something related. But you can't tell GPT to \"write a class with 2 methods\" and expect anything useful.That's why enforcing tree structure during edit provides little value: a missing or wrongly-placed } can totally change control flow and cause a disaster when running the program. But it doesn't make the code much harder to work with as an intermediate state. All names and comments are still there and one can still deduce the intention.","laughs in common lisp","I recently discovered this talk and I'm wondering why structural editing hasn't caught on? It looks faster, more able to avoid programming errors, and potentially more accessible to phone users and dictation. After structural editing some lisp code myself, I found it far superior to standard editing operations. Tree-edit also supports C, Java, and Python, and I'm wondering if anyone has used it to edit those languages, what they think about it. Is this the future of programming?","Well tree sitter can handle not quite correct code in many languages and I know lapce uses it for editing support.","I'm an anarchist. I just start writing.","There exists no scenario where I want characters that I did not type (or select via intellisense) to be inserted into my code.","Because typing skills are the easiest aspect of programming to acquire. Keyboards work well, so long as you're sitting at a desk. Moreover, your typing skills can gradually improve along with your conceptual understanding in a way that I suspect many developers barely notice. And when you get to the point where your physical typing speed is the bottle-neck, the automation afforded by a properly-configured editor or IDE is a serious force multiplier.There are times when I do wish I could do high-level structural transformations on code, but even then, I can usually cobble together some ad-hoc regex solution or a particular sequence of keystrokes to get the job done at a tolerable pace. In any case, sweeping changes to code like this are rare, and for good reason.So much of time is spent thinking: reading code to understand it, or trying to catch things in the debugger, or staring at log messages, or doing proper up-front design.For reasons that are both historical and theoretical, computer languages and computer programs are oriented around linear sequences of symbols, and so computer languages are naturally mapped onto text. There's a great deal of freedom that comes with this. There's a great deal of tooling and infrastructure that is predicated on the notion of code-as-text. Computer languages are carefully designed to be comprehensible when read linearly.I suspect structured editing would be a win on tablets and other devices that lack a physical keyboard, but you'd still be less efficient with it than someone with experience and even a basic keyboard.Given that the major tablet platforms don't exactly encourage direct development on said devices, we simply never got to see what serious structural editing on a touch-screen looks like.The place where I can see structured editing really thriving is not so much for code, but for documents. I think a lot of applications would benefit from directly exposing the document structure as one possible mode of interaction, and there you might find structured editing that is tailored to nature of the document data to be a productivity boost. Here I'm thinking of word processing, spreadsheets, and even vector drawing.","Because it's not useful? His demo shows about 16 lines of code and the AST tree structure is a lot lot longer. And anyone who's ever examined an AST for an expression... it's ok, you're in your safe place, the bad bad tree is gone... will know expressions generate really big wordy trees.And what problem does this funky editor actually solve? I'm spoiled by Visual Studio because it offers great intellisense, great problem highlighting (though that one character wide red squiggle can be hard to find sometimes)."],"points":150},{"text":["You are never taught how to build quality software","\"My uni didn't teach QA, therefore no one is ever taught to build quality\"Like, no? Computer Science focuses on algorithmic correctness & optimization, Software Engineering focuses on the process and quality of the craft. Sorry your schooling didn't include quality, but like a lot of things, it's not required to get an approximation of the job done (see boot camps).Quite a bit of generalization going on there.","People who study Computer Science expecting Software Engineering:","My anecdotal evidence:people who care about quality will make quality software, whether they were taught or notpeople who don't¬†care about quality will make crappy software, whether they were taught or not","Computer Science ‚â† Software Engineering","You will end up getting taught UML nonsense most likely.","Joke's on you, I'm self taught","Well, I think you might be projecting your personal experience upon all other programmers.But it's just not the case for everyone, not even close.A lot of programmers are absolutely taught how to build quality software, through things such as...A) Interactions/discussions with fellow employees, particularly more senior employees,B) Or just VERY actively (in a highly motivated fashion) seeking out and constantly hunting down the BEST discussion books, articles, blogs, forums, videos, etc... on the subject of that programming language.C) Or other venues, such as school, training, or some university programs (in which direct interaction with professors and fellow students is where the real learning/passion occurs), etc...","Sure wasn't. I figured it out with my peers.","Either you are happily building shit software, or somebody has taught you how to build quality software.","Let's be honest, this is a pretty vague and awful essay about how life is different than theory. It doesn't talk in detail about KPIs or any useful metrics, and alot of companies don't do great, but they do do better than whatever startup this poor dev encountered.Don't join a garage for your first job out of college. Join a company with experienced staff engineers. Learn. Don't have to be the initiator of the basics when you're 22.","A bit of clickbait, software quality is not the same as having processes for Quality Assurance. Basically just says that people should be doing more QA and that‚Äôs it.","I have had a lot of changes in my thought process over the years on what \"quality\" software is. Sure, this touches slightly on the QA issue, but in reality I would argue you could have the most algorithmically perfect and tested way of doing something, but still have shit software in terms of features.In reality I wouldn't want people to learn what \"quality\" software is because they won't benefit. Instead I would rather teach what can be standard practices to minimize workload and increase maintainability and couple that with a few lessons on case studies to build a solid foundation where the developer can feel comfortable breaking the rules for the right reason as they gain experience. The key for anyone looking to be senior or above is the ability to take in the business's domain into account and design around that in a way that satisfies the goal in the best way possible. I would argue some of the most \"quality\" software out there is probably not algorithmically beautiful, nor 100% tested. Maintainability is key ofc, but you also won't maintain anything if customers don't come, and I would love for all devs to be able to understant that at some level and realize we live in a world of tradeoffs.","Speak for yourself mate, never went to uni, taught by someone that was largely self taught. Wrote a lot of bad but functional software. Learned the pain of long term maintenance. Read lots of books on software engineering practices and improved over time.Classic baity article with extreme heading, that isn't even capatilized properly.","Building quality software is an art that takes years and years of practice.I'm happy if the new intern/dev can figure out how to change the color of a button.","Would it kill universities to have a class that goes through clean code, code complete, and domain driven design?I have, in my career, hosted about twenty of those book clubs. They changed my life when I first encountered them.I don't feel like this is a big ask. One or two classes, maybe.","Lol what, I attended University of Maryland back in the early 2000s and we covered all that shit it 400 level classes.The lack of QA is always a result of the people who control the money not allocating it to QA.","Because consumer and companies cares more about features. Tesla is a perfect example of this.Innovating takes corner cutting somewhere.Weapon systems, health monitor systems etc is another thing though, quality is a feature there","Nobody knows how to build quality software.","Most programmers don't care. Most write garbage code and use either \"the compiler will optimize it anyway\" or \"hardware is getting faster so who cares\" as a defense.","That‚Äôs what you team and srs are for","Brief overview:Florian Bellmann's blog post discusses the overlooked importance of Quality Assurance (QA) in software development. He notes that despite its crucial role, QA is often neglected inIf you don't like the summary, just downvote and I'll try to delete the comment eventually üëç","Law of r/programming: most contrarian comment floats to the top","You have to study the protocols in use, their flaws. Hardware systems and the nature of digital/analog signals. You didn't learn that stuff. I guess that's the premise about degradation in (public) education? Holistic explanation? I bet you can code your *** off in (language xyz) though. If you're not dead start supplementing your education. Arouse purpose. Before you do die. Maybe you won't die? I'm sorry for the paradox of the unnecessary. ..","I was never taught per se but I learned it as a part of the job.","Hope this helps. It shows the difference between using just testing Vs combining 2 reviews, tests and formal QA metrics.https://docs.google.com/spreadsheets/d/1h1bpuggseVZ65KiuPdNDrnvomfH5-lXHBMiCyyr4mRk/edit?usp=drivesdkPs. I have seen good and bad QA. A not so great one was for a 4 month project. The customer was reporting about 20 bugs a day when doing acceptance tests. I have also seen a 3 month project where only 1 bug was found by the end user. The only real difference between the two was the QA. Both similar complexity, skilled experienced Devs. ... The 4 month project became a 7 month project.results in the customer reporting 20 bugs a day when doing acceptance tests. maybe the customer reports 1 bug. reduces costs/dev time by 30-50%","that's what good leads are for though?","how OP knows what I think/my school career topics?","Taught? \"This feature needs to be finished by the end of this sprint!\"Also, no refactor, only features!","When I was at uni, we were allowed to use any style in our assignments, as long as we're consistent with it. People failed assignments because they used spaces in one place and tabs elsewhere ( within the same assignment).We were specifically given assignments with unrelated requirements, like function Y must return X, even though X isn't used anywhere.And several weeks later we were given assignments which would need function Y and its returned value X.We were given random assignments, and later had to \"stitch together\" each other's code.We were allowed to have, and reuse our assignments during exams.Lots of random things were constructed in a way, that were meant to teach us the value of code quality.There wasn't a dedicated course for \"code quality\" but they gave us a solid foundation for extrapolating and understanding \"quality\".","These (value of QA, how to do it and how to improve code base quality) were included on department specific courses starting freshman year in my university, department was Computer Science and Engineering. Also most of the common \"they don't teach this in school\" topics were possible majors in our department, and these days school requires a minor from another department, so everyone has at least one domain with relevant domain knowledge.It was in industry where no-one, especially the veterans and self taught code wizards did not really care about these at all.","QA is not about creating quality, it‚Äôs about measuring it.That‚Äôs like saying no one is rich because there‚Äôs taxes. It‚Äôs a non-sequitur.","teachings or not, there are a lot of factors college doesn't (or maybe cannot) address:team dynamicsturnoveroffice politicsbusiness/ economic wavesbeing taught to wing it because we don't need / have time to produce a properly designed solution is the norm (maybe since the 2000s ? I don't know)Give me a few angry engineers and some time and you'll get some good piece of software.. but 2 weeks with limited bullshitters and you'll get hacks.","That‚Äôs why you can‚Äôt have both hard deadlines and the inability to cut scope. Software estimation is not a precise art. Because then quality inevitably suffers. Sometimes that‚Äôs ok, but most of the time you‚Äôre tremendously adding to development costs later on."],"points":803},{"text":["Sharing a journey of building my first iOS app"],"points":0},{"text":["The Shocking Secret About Static Types","The premise seems silly. Static typing is not supposed to be a panacea against bugs. Static typing simply time-shifts detection of type errors from runtime to compile-time. It makes type errors easier to find. That's all.","Static type checking catches more type errors than dynamically typed language compilers do. This is almost an obvious tautology.It doesn‚Äôt make promises about catching logic errors. But it does give a way to leg into turning more and more logic errors into type errors if the type system is expressive enough.","TDD is just absolute garbage- almost as much as this article. Static typing is a tool that can let you write better code, but like anything else in programming you can‚Äôt go into it naively and expect to have everything work out.Look at programs that are commonly used as case studies in low defect programs- for example xmonad. They are almost always written in statically typed languages.","Essential Highlights:The post challenges the popular belief that static types significantly reduce bug density in software development. It references studies showing the limited impact of static types on bug reduction, compared to the more substantial benefits of Test Driven Development (TDD). The post also argues that while static types offer certain developer tools and can be useful, they provide a false sense of security regarding bug prevention. It concludes by advocating for TDD as a more effective method for reducing bugs while recognizing the ancillary benefits of static types. NOTE: This is not related to the actual summary, but this shows more that types have an effect on the wider programming market than an effect on a highly proficient team. So if you have control of the hiring, go for TDD and hire those skills, if you don't, typescript will probably be a great plumbing tape to get delivery going.If you don't like the summary, just downvote and I'll try to delete the comment eventually üëç"],"points":47},{"text":["Java‚Äôs Epic Quest for Performance Immortality","so valhalla pretty much introduces c#-like structs?","At first, C# seems like just a Microsoft-ed version of Java. But then you start using it and realize they‚Äôve fixed everything that you hated about Java, and they did it years and years ago.This article is just basically saying ‚Äúwe‚Äôre trying to add structs‚Äù which have been supported in C# since maybe 1.0?(Since I said ‚Äúeverything‚Äù was fixed in C#, here are some other things that I love in C# and am perpetually bugged that Java doesn‚Äôt have:Properties (don‚Äôt have to use getters and setters everywhere)Operator overloading, including [] for listsAsync/await (Java 21 recently released go-like green threads but up until then it had poor concurrency support at the language level)Extension methodsNo type erasureAnd tons of other syntactic-sugar type stuff. Note that many of these things are available in Kotlin for the JVM but not the performance-improving ones such as struct, since Kotlin is limited by the underlying JVM.)","The above was fine in 1995, when the first version of Java came out, as the speed of memory and CPU back in those days was about the same.However, in modern days the CPU is MUCH faster than memory, and so this memory layout becomes a significant drag on performance.I'm fairly certain that none of that \"was fine in 1995\" either. Even back then, we only had 8KB code and data caches on our P5s, but we were also running SIMMs on much narrower busses. RAM has always been slow...","The thing that was most impressive to me is actually not the numbers themselves, but the fact that a language as old as Java can still make such fundamental changes that have such a significant impactWell, if you had written that code in C or Rust, you would know that Java still has lots of overhead for problems like that... in fact, I bet even with Project Valhalla, this will still run at least 2x slower than those languages (because Java still will have more overhead from GC, JIT, thread schedulers etc that those languages don't).","This is very cool","Im trying to understand why this needs to leaked into the syntax. Can't this be done at compile time instead? I guess since java already takes a long time to compile?","Isn't the article outdated compared to the current form? I think they are not going to introduce primitive objects, but rather null restricted value objects, allowing the vm to make optimizations","java's epic quest to become a half-assed, badly designed imitation of C# 2.0 from 2005ftfy.EDIT: lol no, it's worse than that. Even C# 1.0 from 2002 actually supported struct. This is fucking ridiculous.","Instead of removing boxing, they invent this bullshit"],"points":75}]